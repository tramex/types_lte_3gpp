pub const ID_ABS_STATUS: u16 = 63;

pub const ID_ABS_INFORMATION: u16 = 61;

pub const ID_ACTIVATED_CELL_LIST: u16 = 58;

pub const ID_ACTIVATED_NR_CELL_LIST: u16 = 268;

pub const ID_ACTIVATION_ID: u16 = 256;

pub const ID_ADDITION_LOCATION_INFORMATION: u16 = 409;

pub const ID_ADDITIONAL_MEASUREMENT_TIMING_CONFIGURATION_LIST: u16 = 433;

pub const ID_ADDITIONAL_LISTOF_FORWARDING_GTP_TUNNEL_ENDPOINT: u16 = 441;

pub const ID_ADDITIONAL_RRM_PRIORITY_INDEX: u16 = 340;

pub const ID_ADDITIONAL_SPECIAL_SUBFRAME_INFO: u16 = 97;

pub const ID_ADDITIONAL_SPECIAL_SUBFRAME_EXTENSION_INFO: u16 = 179;

pub const ID_ADMITTED_SPLIT_SR_BS: u16 = 212;

pub const ID_ADMITTED_SPLIT_SR_BSRELEASE: u16 = 281;

pub const ID_AERIAL_U_ESUBSCRIPTION_INFORMATION: u16 = 277;

pub const ID_AVAILABLE_FAST_MCG_RECOVERY_VIA_SRB3: u16 = 344;

pub const ID_BPLMN_ID_INFO_EUTRA: u16 = 336;

pub const ID_BPLMN_ID_INFO_NR: u16 = 337;

pub const ID_BANDWIDTH_REDUCED_SI: u16 = 180;

pub const ID_BEARER_TYPE: u16 = 171;

pub const ID_BLUETOOTH_MEASUREMENT_CONFIGURATION: u16 = 303;

pub const ID_CHO_DC_EARLY_DATA_FORWARDING: u16 = 407;

pub const ID_CHO_DC_INDICATOR: u16 = 368;

pub const ID_CHO_TIME_BASED_INFORMATION: u16 = 446;

pub const ID_CH_OINFORMATION_ACK: u16 = 362;

pub const ID_CH_OINFORMATION_ADD_REQ: u16 = 420;

pub const ID_CH_OINFORMATION_MOD_REQ: u16 = 421;

pub const ID_CH_OINFORMATION_REQ: u16 = 361;

pub const ID_CN_TYPE_RESTRICTIONS: u16 = 301;

pub const ID_CPA_CINFORMATION_REQD: u16 = 428;

pub const ID_CP_AINFORMATION_MOD: u16 = 426;

pub const ID_CP_AINFORMATION_MOD_ACK: u16 = 427;

pub const ID_CP_AINFORMATION_REQ: u16 = 424;

pub const ID_CP_AINFORMATION_REQ_ACK: u16 = 425;

pub const ID_CPC_CANCEL: u8 = 59;

pub const ID_CP_CINFORMATION_CONF: u16 = 430;

pub const ID_CP_CINFORMATION_NOTIFY: u16 = 431;

pub const ID_CP_CINFORMATION_REQD: u16 = 429;

pub const ID_CP_CUPDATE_MOD: u16 = 432;

pub const ID_CSG_ID: u16 = 70;

pub const ID_CSG_MEMBERSHIP_STATUS: u16 = 71;

pub const ID_CSI_RS_TRANSMISSION_INDICATION: u16 = 380;

pub const ID_CSI_REPORT_LIST: u16 = 146;

pub const ID_CANDIDATE_CELLS_TO_BE_CANCELLED_LIST: u16 = 365;

pub const ID_CARRIER_LIST: u16 = 386;

pub const ID_CAUSE: u16 = 5;

pub const ID_CELL_ASSISTANCE_INFORMATION: u16 = 251;

pub const ID_CELL_INFORMATION: u16 = 6;

pub const ID_CELL_INFORMATION_ITEM: u16 = 7;

pub const ID_CELL_MEASUREMENT_RESULT: u16 = 32;

pub const ID_CELL_MEASUREMENT_RESULT_E_UTRA_ENDC: u16 = 401;

pub const ID_CELL_MEASUREMENT_RESULT_E_UTRA_ENDC_ITEM: u16 = 402;

pub const ID_CELL_MEASUREMENT_RESULT_ITEM: u16 = 33;

pub const ID_CELL_MEASUREMENT_RESULT_NR_ENDC: u16 = 393;

pub const ID_CELL_MEASUREMENT_RESULT_NR_ENDC_ITEM: u16 = 394;

pub const ID_CELL_REPORTING_INDICATOR: u16 = 170;

pub const ID_CELL_TO_REPORT: u16 = 29;

pub const ID_CELL_TO_REPORT_E_UTRA_ENDC: u16 = 403;

pub const ID_CELL_TO_REPORT_E_UTRA_ENDC_ITEM: u16 = 404;

pub const ID_CELL_TO_REPORT_ITEM: u16 = 31;

pub const ID_CELL_TO_REPORT_NR_ENDC: u16 = 391;

pub const ID_CELL_TO_REPORT_NR_ENDC_ITEM: u16 = 392;

pub const ID_CELLAND_CAPACITY_ASSIST_INFO: u16 = 351;

pub const ID_CO_MP_INFORMATION: u16 = 108;

pub const ID_COMPLETE_FAILURE_CAUSE_INFORMATION_ITEM: u16 = 69;

pub const ID_COMPLETE_FAILURE_CAUSE_INFORMATION_LIST: u16 = 68;

pub const ID_COMPOSITE_AVAILABLE_CAPACITY_GROUP: u16 = 42;

pub const ID_CORRELATION_ID: u16 = 166;

pub const ID_COVERAGE_MODIFICATION_LIST: u16 = 143;

pub const ID_CRITICALITY_DIAGNOSTICS: u16 = 17;

pub const ID_DAPS_REQUEST_INFO: u16 = 363;

pub const ID_DAPS_RESPONSE_INFO: u16 = 366;

pub const ID_DL_EARFCN_EXTENSION: u16 = 96;

pub const ID_DL_SCHEDULING_PDCCH_CCE_USAGE: u16 = 193;

pub const ID_DLCOUNT_VALUE_EXTENDED: u16 = 93;

pub const ID_DLCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 152;

pub const ID_DL_CARRIER_LIST: u16 = 381;

pub const ID_DATA_TRAFFIC_RESOURCE_INDICATION: u16 = 287;

pub const ID_DEACTIVATION_INDICATION: u16 = 59;

pub const ID_DESIRED_ACT_NOTIFICATION_LEVEL: u16 = 329;

pub const ID_DIRECT_FORWARDING_PATH_AVAILABILITY: u16 = 410;

pub const ID_DOWNLINK_PACKET_LOSS_RATE: u16 = 273;

pub const ID_DYNAMIC_DL_TRANSMISSION_INFORMATION: u16 = 106;

pub const ID_E_RAB_ITEM: u16 = 2;

pub const ID_E_RAB_USAGE_REPORT_ITEM: u16 = 263;

pub const ID_E_RA_BS_ADMITTED_ITEM: u16 = 0;

pub const ID_E_RA_BS_ADMITTED_LIST: u16 = 1;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_ITEM: u16 = 121;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_LIST: u16 = 120;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_MOD_ACK_ITEM: u16 = 131;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_MOD_ACK_LIST: u16 = 128;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_SG_NB_ADD_REQ_ACK_ITEM: u16 = 213;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_SG_NB_ADD_REQ_ACK_LIST: u16 = 210;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_SG_NB_MOD_ACK_ITEM: u16 = 222;

pub const ID_E_RA_BS_ADMITTED_TO_BE_ADDED_SG_NB_MOD_ACK_LIST: u16 = 219;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_MOD_ACK_ITEM: u16 = 132;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_MOD_ACK_LIST: u16 = 129;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_SG_NB_MOD_ACK_ITEM: u16 = 223;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_SG_NB_MOD_ACK_LIST: u16 = 220;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_MOD_ACK_ITEM: u16 = 133;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_MOD_ACK_LIST: u16 = 130;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_SG_NB_MOD_ACK_ITEM: u16 = 224;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_SG_NB_MOD_ACK_LIST: u16 = 221;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_SG_NB_REL_REQ_ACK_ITEM: u16 = 319;

pub const ID_E_RA_BS_ADMITTED_TO_BE_RELEASED_SG_NB_REL_REQ_ACK_LIST: u16 = 318;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_SG_NB_MOD_CONF_ITEM: u16 = 295;

pub const ID_E_RA_BS_ADMITTED_TO_BE_MODIFIED_SG_NB_MOD_CONF_LIST: u16 = 294;

pub const ID_E_RA_BS_DATA_FORWARDING_ADDRESS_ITEM: u16 = 308;

pub const ID_E_RA_BS_DATA_FORWARDING_ADDRESS_LIST: u16 = 307;

pub const ID_E_RA_BS_NOT_ADMITTED_LIST: u16 = 3;

pub const ID_E_RA_BS_SUBJECT_TO_COUNTER_CHECK_LIST: u16 = 141;

pub const ID_E_RA_BS_SUBJECT_TO_COUNTER_CHECK_ITEM: u16 = 142;

pub const ID_E_RA_BS_SUBJECT_TO_SG_NB_COUNTER_CHECK_ITEM: u16 = 236;

pub const ID_E_RA_BS_SUBJECT_TO_SG_NB_COUNTER_CHECK_LIST: u16 = 235;

pub const ID_E_RA_BS_SUBJECT_TO_STATUS_TRANSFER_ITEM: u16 = 19;

pub const ID_E_RA_BS_SUBJECT_TO_STATUS_TRANSFER_LIST: u16 = 18;

pub const ID_E_RA_BS_TO_BE_ADDED_ITEM: u16 = 118;

pub const ID_E_RA_BS_TO_BE_ADDED_LIST: u16 = 117;

pub const ID_E_RA_BS_TO_BE_ADDED_MOD_REQ_ITEM: u16 = 125;

pub const ID_E_RA_BS_TO_BE_ADDED_SG_NB_ADD_REQ_ITEM: u16 = 209;

pub const ID_E_RA_BS_TO_BE_ADDED_SG_NB_ADD_REQ_LIST: u16 = 205;

pub const ID_E_RA_BS_TO_BE_ADDED_SG_NB_MOD_REQ_ITEM: u16 = 216;

pub const ID_E_RA_BS_TO_BE_MODIFIED_MOD_REQ_ITEM: u16 = 126;

pub const ID_E_RA_BS_TO_BE_MODIFIED_SG_NB_MOD_REQ_ITEM: u16 = 217;

pub const ID_E_RA_BS_TO_BE_MODIFIED_SG_NB_MOD_REQD_ITEM: u16 = 228;

pub const ID_E_RA_BS_TO_BE_MODIFIED_SG_NB_MOD_REQD_LIST: u16 = 226;

pub const ID_E_RA_BS_TO_BE_RELEASED_LIST_REL_CONF: u16 = 139;

pub const ID_E_RA_BS_TO_BE_RELEASED_LIST_REL_REQ: u16 = 137;

pub const ID_E_RA_BS_TO_BE_RELEASED_MOD_REQ_ITEM: u16 = 127;

pub const ID_E_RA_BS_TO_BE_RELEASED_MOD_REQD: u16 = 134;

pub const ID_E_RA_BS_TO_BE_RELEASED_MOD_REQD_ITEM: u16 = 135;

pub const ID_E_RA_BS_TO_BE_RELEASED_REL_CONF_ITEM: u16 = 140;

pub const ID_E_RA_BS_TO_BE_RELEASED_REL_REQ_ITEM: u16 = 138;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_CHA_CONF_ITEM: u16 = 230;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_CHA_CONF_LIST: u16 = 229;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_MOD_REQ_ITEM: u16 = 218;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_MOD_REQD_ITEM: u16 = 227;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_MOD_REQD_LIST: u16 = 225;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_CONF_ITEM: u16 = 234;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_CONF_LIST: u16 = 233;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_REQ_ITEM: u16 = 232;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_REQ_LIST: u16 = 231;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_REQD_ITEM: u16 = 321;

pub const ID_E_RA_BS_TO_BE_RELEASED_SG_NB_REL_REQD_LIST: u16 = 320;

pub const ID_E_RA_BS_TO_BE_SETUP_ITEM: u16 = 4;

pub const ID_E_RA_BS_TO_BE_SETUP_RETRIEVE_ITEM: u16 = 174;

pub const ID_E_UTRAN_NODE1_MEASUREMENT_ID: u16 = 383;

pub const ID_E_UTRAN_NODE2_MEASUREMENT_ID: u16 = 384;

pub const ID_ECGI: u16 = 316;

pub const ID_ENB1_CELL_ID: u16 = 43;

pub const ID_ENB1_MEASUREMENT_ID: u16 = 39;

pub const ID_ENB1_MOBILITY_PARAMETERS: u16 = 46;

pub const ID_ENB2_CELL_ID: u16 = 44;

pub const ID_ENB2_MEASUREMENT_ID: u16 = 40;

pub const ID_ENB2_MOBILITY_PARAMETERS_MODIFICATION_RANGE: u16 = 47;

pub const ID_ENB2_PROPOSED_MOBILITY_PARAMETERS: u16 = 45;

pub const ID_EPC_HANDOVER_RESTRICTION_LIST_CONTAINER: u16 = 360;

pub const ID_ERAB_ACTIVITY_NOTIFY_ITEM_LIST: u16 = 297;

pub const ID_ERA_BS_TRANSFERRED_TO_ME_NB: u16 = 339;

pub const ID_EUTRAN_TRACE_ID: u16 = 333;

pub const ID_ETHERNET_TYPE: u16 = 369;

pub const ID_EXPECTED_UE_BEHAVIOUR: u16 = 104;

pub const ID_EXTENDED_UL_INTERFERENCE_OVERLOAD_INFO: u16 = 100;

pub const ID_F1C_TRAFFIC_CONTAINER: u16 = 397;

pub const ID_FAILURE_CELL_CRNTI: u16 = 50;

pub const ID_FAILURE_CELL_ECGI: u16 = 53;

pub const ID_FAILURE_CELL_PCI: u16 = 48;

pub const ID_FAST_MCG_RECOVERY_MN_TO_SN: u16 = 347;

pub const ID_FAST_MCG_RECOVERY_SN_TO_MN: u16 = 342;

pub const ID_FREQ_BAND_INDICATOR_PRIORITY: u16 = 160;

pub const ID_FREQUENCY_SHIFT7P5KHZ: u16 = 388;

pub const ID_GNB_OVERLOAD_INFORMATION: u16 = 310;

pub const ID_GU_GROUP_ID_LIST: u16 = 24;

pub const ID_GU_GROUP_ID_TO_ADD_LIST: u16 = 34;

pub const ID_GU_GROUP_ID_TO_DELETE_LIST: u16 = 35;

pub const ID_GUMMEI_ID: u16 = 23;

pub const ID_GW_TRANSPORT_LAYER_ADDRESS: u16 = 165;

pub const ID_GLOBAL_ENB_ID: u16 = 21;

pub const ID_GLOBALEN_G_NB_ID: u16 = 252;

pub const ID_HO_CAUSE: u16 = 80;

pub const ID_HANDOVER_REPORT_TYPE: u16 = 54;

pub const ID_HANDOVER_RESTRICTION_LIST: u16 = 240;

pub const ID_IAB_AUTHORIZED: u16 = 449;

pub const ID_IAB_NODE_INDICATION: u16 = 395;

pub const ID_IM_SVOICE_EP_SFALLBACKFROM5_G: u16 = 408;

pub const ID_INITIATING_NODE_TYPE_ENDC_CONFIG_UPDATE: u16 = 245;

pub const ID_INITIATING_NODE_TYPE_ENDC_X2_REMOVAL: u16 = 298;

pub const ID_INITIATING_NODE_TYPE_ENDC_X2_SETUP: u16 = 244;

pub const ID_INITIATING_NODE_TYPE_EUTRANR_CELL_RESOURCE_COORDINATION: u16 = 285;

pub const ID_INTENDED_TDD_DL_UL_CONFIGURATION_NR: u16 = 399;

pub const ID_INTENDED_ULDL_CONFIGURATION: u16 = 99;

pub const ID_INTERFACE_INSTANCE_INDICATION: u16 = 335;

pub const ID_INVOKE_INDICATION: u16 = 62;

pub const ID_LHN_ID: u16 = 159;

pub const ID_LAST_NG_RANPLMN_IDENTITY: u16 = 332;

pub const ID_LISTOF_EUTRA_CELLSIN_EUTRA_COORDINATION_REQ: u16 = 289;

pub const ID_LISTOF_EUTRA_CELLSIN_EUTRA_COORDINATION_RESP: u16 = 290;

pub const ID_LISTOF_EUTRA_CELLSIN_NR_COORDINATION_REQ: u16 = 291;

pub const ID_LISTOF_NR_CELLSIN_NR_COORDINATION_REQ: u16 = 292;

pub const ID_LISTOF_NR_CELLSIN_NR_COORDINATION_RESP: u16 = 293;

pub const ID_LOCATION_INFORMATION_SG_NB: u16 = 331;

pub const ID_LOCATION_INFORMATION_SG_NB_REPORTING: u16 = 330;

pub const ID_LOWER_LAYER_PRESENCE_STATUS_CHANGE: u16 = 341;

pub const ID_M3_CONFIGURATION: u16 = 85;

pub const ID_M4_CONFIGURATION: u16 = 86;

pub const ID_M4_REPORT_AMOUNT: u16 = 442;

pub const ID_M5_CONFIGURATION: u16 = 87;

pub const ID_M5_REPORT_AMOUNT: u16 = 443;

pub const ID_M6_CONFIGURATION: u16 = 161;

pub const ID_M6_REPORT_AMOUNT: u16 = 444;

pub const ID_M7_CONFIGURATION: u16 = 162;

pub const ID_M7_REPORT_AMOUNT: u16 = 445;

pub const ID_MBMS_SERVICE_AREA_LIST: u16 = 79;

pub const ID_MBSFN_SUBFRAME_INFO: u16 = 56;

pub const ID_MDT_LOCATION_INFO: u16 = 88;

pub const ID_MDT_CONFIGURATION: u16 = 72;

pub const ID_MDT_CONFIGURATION_NR: u16 = 375;

pub const ID_MIMOPR_BUSAGE_INFORMATION: u16 = 439;

pub const ID_MAKE_BEFORE_BREAK_INDICATOR: u16 = 181;

pub const ID_MANAGEMENT_BASED_MDTPLMN_LIST: u16 = 89;

pub const ID_MANAGEMENT_BASED_MD_TALLOWED: u16 = 74;

pub const ID_MASKED_IMEISV: u16 = 98;

pub const ID_MAXIMUM_CELL_LIST_SIZE: u16 = 349;

pub const ID_ME_NB_UE_X2AP_ID: u16 = 111;

pub const ID_ME_NB_UE_X2AP_ID_EXTENSION: u16 = 157;

pub const ID_ME_NB_CELL_ID: u16 = 279;

pub const ID_ME_NB_COORDINATION_ASSISTANCE_INFORMATION: u16 = 323;

pub const ID_ME_NB_RESOURCE_COORDINATION_INFORMATION: u16 = 257;

pub const ID_ME_N_BTO_SE_NB_CONTAINER: u16 = 119;

pub const ID_ME_N_BTO_SG_NB_CONTAINER: u16 = 206;

pub const ID_MEASUREMENT_ID: u16 = 37;

pub const ID_MEASUREMENT_FAILURE_CAUSE_ITEM: u16 = 67;

pub const ID_MEASUREMENT_INITIATION_RESULT_ITEM: u16 = 66;

pub const ID_MEASUREMENT_INITIATION_RESULT_LIST: u16 = 65;

pub const ID_MEASUREMENT_RESULTFOR_NR_CELLS_POSSIBLY_AGGREGATED: u16 = 417;

pub const ID_MESSAGE_OVERSIZE_NOTIFICATION: u16 = 350;

pub const ID_MOBILITY_INFORMATION: u16 = 82;

pub const ID_MULTIBAND_INFO_LIST: u16 = 84;

pub const ID_NB_IO_T_RLF_REPORT_CONTAINER: u16 = 374;

pub const ID_NB_IO_T_UL_DL_ALIGNMENT_OFFSET: u16 = 338;

pub const ID_NPRACH_CONFIGURATION: u16 = 373;

pub const ID_NRCGI: u16 = 322;

pub const ID_NR_CELL_PRACH_CONFIG: u16 = 390;

pub const ID_NR_NEIGHBOUR_INFO_TO_ADD: u16 = 327;

pub const ID_NR_NEIGHBOUR_INFO_TO_MODIFY: u16 = 328;

pub const ID_NRRA_REPORT: u16 = 414;

pub const ID_NRS_NSSS_POWER_OFFSET: u16 = 282;

pub const ID_NRUE_SECURITY_CAPABILITIES: u16 = 248;

pub const ID_NRUE_SIDELINK_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 371;

pub const ID_NR_UE_REPORT: u16 = 243;

pub const ID_NRV2X_SERVICES_AUTHORIZED: u16 = 370;

pub const ID_N_RRESTRICTIONIN5_GS: u16 = 305;

pub const ID_N_RRESTRICTIONIN_EP_SAS_SECONDARY_RAT: u16 = 202;

pub const ID_NSSS_NUM_OCCASION_DIFFERENT_PRECODER: u16 = 283;

pub const ID_NEIGHBOUR_TAC: u16 = 76;

pub const ID_NEW_E_NB_UE_X2AP_ID: u16 = 9;

pub const ID_NEW_E_NB_UE_X2AP_ID_EXTENSION: u16 = 155;

pub const ID_NEW_EUTRAN_CELL_IDENTIFIER: u16 = 175;

pub const ID_NUMBER_OF_ANTENNAPORTS: u16 = 41;

pub const ID_OFFSET_OF_NBIOT_CHANNEL_NUMBER_TO_DL_EARFCN: u16 = 177;

pub const ID_OFFSET_OF_NBIOT_CHANNEL_NUMBER_TO_UL_EARFCN: u16 = 178;

pub const ID_OLD_SG_NB_UE_X2AP_ID: u16 = 264;

pub const ID_OLD_E_NB_UE_X2AP_ID: u16 = 10;

pub const ID_OLD_E_NB_UE_X2AP_ID_EXTENSION: u16 = 156;

pub const ID_PC5_QO_S_PARAMETERS: u16 = 372;

pub const ID_PDCP_CHANGE_INDICATION: u16 = 249;

pub const ID_PRACH_CONFIGURATION: u16 = 55;

pub const ID_PS_CELL_UE_HISTORY_INFORMATION: u16 = 418;

pub const ID_PS_CELL_CHANGE_HISTORY: u16 = 419;

pub const ID_PS_CELL_HISTORY_INFORMATION_RETRIEVE: u16 = 416;

pub const ID_PS_CELL_LIST_CONTAINER: u16 = 448;

pub const ID_PARTIAL_LIST_INDICATOR: u16 = 348;

pub const ID_PARTIAL_SUCCESS_INDICATOR: u16 = 64;

pub const ID_PRIVACY_INDICATOR: u16 = 376;

pub const ID_PRO_SE_AUTHORIZED: u16 = 103;

pub const ID_PRO_SE_U_ETO_NETWORK_RELAYING: u16 = 149;

pub const ID_PROCEDURE_STAGE: u16 = 367;

pub const ID_PROTECTED_EUTRA_RESOURCE_INDICATION: u16 = 284;

pub const ID_QO_S_MAPPING_INFORMATION: u16 = 396;

pub const ID_RAT_RESTRICTIONS: u16 = 437;

pub const ID_RLC_STATUS: u16 = 300;

pub const ID_RLC_MODE_TRANSFERRED: u16 = 317;

pub const ID_RNL_HEADER: u16 = 101;

pub const ID_RRC_CONFIG_INDICATION: u16 = 272;

pub const ID_RRC_CONN_REESTAB_INDICATOR: u16 = 78;

pub const ID_RRC_CONN_SETUP_INDICATOR: u16 = 75;

pub const ID_RRC_CONTAINER: u16 = 237;

pub const ID_RSRPMR_LIST: u16 = 110;

pub const ID_RA_REPORT_INDICATION_LIST: u16 = 447;

pub const ID_RE_ESTABLISHMENT_CELL_ECGI: u16 = 49;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_EXTENDED: u16 = 91;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_PDCP_S_NLENGTH18: u16 = 150;

pub const ID_REGISTRATION_REQUEST: u16 = 28;

pub const ID_RELEASE_FAST_MCG_RECOVERY_VIA_SRB3: u16 = 346;

pub const ID_REPORT_CHARACTERISTICS: u16 = 38;

pub const ID_REPORTING_PERIODICITY: u16 = 30;

pub const ID_REPORTING_PERIODICITY_CSIR: u16 = 145;

pub const ID_REPORTING_PERIODICITY_RSRPMR: u16 = 109;

pub const ID_REQUESTED_FAST_MCG_RECOVERY_VIA_SRB3: u16 = 343;

pub const ID_REQUESTED_FAST_MCG_RECOVERY_VIA_SRB3_RELEASE: u16 = 345;

pub const ID_REQUESTED_SPLIT_SR_BS: u16 = 208;

pub const ID_REQUESTED_SPLIT_SR_BSRELEASE: u16 = 280;

pub const ID_REQUESTED_TARGET_CELL_ID: u16 = 364;

pub const ID_RESPONDING_NODE_TYPE_ENDC_CONFIG_UPDATE: u16 = 247;

pub const ID_RESPONDING_NODE_TYPE_ENDC_X2_REMOVAL: u16 = 299;

pub const ID_RESPONDING_NODE_TYPE_ENDC_X2_SETUP: u16 = 246;

pub const ID_RESPONDING_NODE_TYPE_EUTRANR_CELL_RESOURCE_COORDINATION: u16 = 286;

pub const ID_RESPONSE_INFORMATION_SE_NB_RECONF_COMP: u16 = 123;

pub const ID_RESPONSE_INFORMATION_SG_NB_RECONF_COMP: u16 = 214;

pub const ID_SCG_UE_HISTORY_INFORMATION: u16 = 415;

pub const ID_SCG_ACTIVATION_REQUEST: u16 = 423;

pub const ID_SCG_ACTIVATION_STATUS: u16 = 422;

pub const ID_SCG_CHANGE_INDICATION: u16 = 136;

pub const ID_SCG_CONFIGURATION_QUERY: u16 = 241;

pub const ID_SC_GRECONFIG_NOTIFICATION: u16 = 438;

pub const ID_SFN_OFFSET: u16 = 406;

pub const ID_SGNB_ADDITION_TRIGGER_IND: u16 = 278;

pub const ID_SIPTO_BEARER_DEACTIVATION_INDICATION: u16 = 164;

pub const ID_SIPTO_CORRELATION_ID: u16 = 167;

pub const ID_SIPTO_L_GW_TRANSPORT_LAYER_ADDRESS: u16 = 168;

pub const ID_S_NTRIGGERED: u16 = 379;

pub const ID_SRB_TYPE: u16 = 238;

pub const ID_SRVCC_OPERATION_POSSIBLE: u16 = 36;

pub const ID_SSB_POSITIONS_IN_BURST: u16 = 389;

pub const ID_SE_NB_UE_X2AP_ID: u16 = 112;

pub const ID_SE_NB_UE_X2AP_ID_EXTENSION: u16 = 158;

pub const ID_SE_NB_SECURITY_KEY: u16 = 114;

pub const ID_SE_NBUE_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 115;

pub const ID_SE_N_BTO_ME_NB_CONTAINER: u16 = 122;

pub const ID_SECONDARY_RAT_USAGE_REPORT: u16 = 255;

pub const ID_SECONDARY_RAT_USAGE_REPORT_ITEM: u16 = 266;

pub const ID_SECONDARY_RAT_USAGE_REPORT_LIST: u16 = 265;

pub const ID_SECURITY_INDICATION: u16 = 435;

pub const ID_SECURITY_RESULT: u16 = 436;

pub const ID_SELECTED_PLMN: u16 = 269;

pub const ID_SENSOR_MEASUREMENT_CONFIGURATION: u16 = 440;

pub const ID_SERVED_CELL_SPECIFIC_INFO_REQ_NR: u16 = 434;

pub const ID_SERVED_CELLS: u16 = 20;

pub const ID_SERVED_CELLS_TO_ACTIVATE: u16 = 57;

pub const ID_SERVED_CELLS_TO_ADD: u16 = 25;

pub const ID_SERVED_CELLS_TO_DELETE: u16 = 27;

pub const ID_SERVED_CELLS_TO_MODIFY: u16 = 26;

pub const ID_SERVED_EUTR_ACELLS_ENDCX2_MANAGEMENT_LIST: u16 = 250;

pub const ID_SERVED_EUTR_ACELLS_TO_DELETE_LIST_ENDC_CONF_UPD: u16 = 260;

pub const ID_SERVED_EUTR_ACELLS_TO_MODIFY_LIST_ENDC_CONF_UPD: u16 = 259;

pub const ID_SERVED_NR_CELLS_TO_ACTIVATE: u16 = 267;

pub const ID_SERVED_N_RCELLS_ENDCX2_MANAGEMENT_LIST: u16 = 253;

pub const ID_SERVED_N_RCELLS_TO_DELETE_LIST_ENDC_CONF_UPD: u16 = 262;

pub const ID_SERVED_N_RCELLS_TO_MODIFY_LIST_ENDC_CONF_UPD: u16 = 261;

pub const ID_SERVING_PLMN: u16 = 116;

pub const ID_SG_NB_UE_X2AP_ID: u16 = 207;

pub const ID_SG_NB_ACTIVITY_NOTIFICATION: u8 = 42;

pub const ID_SG_NB_COORDINATION_ASSISTANCE_INFORMATION: u16 = 324;

pub const ID_SG_NB_RESOURCE_COORDINATION_INFORMATION: u16 = 258;

pub const ID_SG_NB_SECURITY_KEY: u16 = 203;

pub const ID_SG_NBUE_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 204;

pub const ID_SG_N_BTO_ME_NB_CONTAINER: u16 = 211;

pub const ID_SHORT_MAC_I: u16 = 51;

pub const ID_SIGNALLING_BASED_MDTPLMN_LIST: u16 = 90;

pub const ID_SOURCE_CELL_CRNTI: u16 = 83;

pub const ID_SOURCE_CELL_ECGI: u16 = 52;

pub const ID_SOURCE_DL_FORWARDING_IP_ADDRESS: u16 = 412;

pub const ID_SOURCE_NODE_DL_FORWARDING_IP_ADDRESS: u16 = 413;

pub const ID_SPECTRUM_SHARING_GROUP_ID: u16 = 288;

pub const ID_SPLIT_SRB: u16 = 242;

pub const ID_SUBSCRIBER_PROFILE_I_DFOR_RFP: u16 = 275;

pub const ID_SUBSCRIPTION_BASED_UE_DIFFERENTIATION_INFO: u16 = 309;

pub const ID_TDDULDL_CONFIGURATION_COMMON_NR: u16 = 385;

pub const ID_TNLA_FAILED_TO_SETUP_LIST: u16 = 357;

pub const ID_TNLA_SETUP_LIST: u16 = 356;

pub const ID_TNLA_TO_ADD_LIST: u16 = 353;

pub const ID_TNLA_TO_REMOVE_LIST: u16 = 355;

pub const ID_TNLA_TO_UPDATE_LIST: u16 = 354;

pub const ID_TNL_CONFIGURATION_INFO: u16 = 352;

pub const ID_TARGET_SG_NB_ID: u16 = 239;

pub const ID_TARGET_CELL_ID: u16 = 11;

pub const ID_TARGET_CELL_IN_NGRAN: u16 = 382;

pub const ID_TARGET_CELL_IN_UTRAN: u16 = 81;

pub const ID_TARGETE_N_BTO_SOURCE_E_NB_TRANSPARENT_CONTAINER: u16 = 12;

pub const ID_TIME_UE_STAYED_IN_CELL_ENHANCED_GRANULARITY: u16 = 77;

pub const ID_TIME_TO_WAIT: u16 = 22;

pub const ID_TRACE_ACTIVATION: u16 = 13;

pub const ID_TRACE_COLLECTION_ENTITY_IP_ADDRESS: u16 = 377;

pub const ID_TRACE_COLLECTION_ENTITY_URI: u16 = 405;

pub const ID_TUNNEL_INFORMATION_FOR_BBF: u16 = 163;

pub const ID_UE_CONTEXT_INFORMATION: u16 = 14;

pub const ID_UE_CONTEXT_INFORMATION_SG_NB_MOD_REQ: u16 = 215;

pub const ID_UE_CONTEXT_INFORMATION_RETRIEVE: u16 = 173;

pub const ID_UE_CONTEXT_INFORMATION_SE_NB_MOD_REQ: u16 = 124;

pub const ID_UE_CONTEXT_KEPT_INDICATOR: u16 = 154;

pub const ID_UE_CONTEXT_REFERENCE_AT_SE_NB: u16 = 153;

pub const ID_UE_CONTEXT_REFERENCE_AT_SG_NB: u16 = 254;

pub const ID_UE_CONTEXT_REFERENCE_AT_WT: u16 = 182;

pub const ID_UE_HISTORY_INFORMATION: u16 = 15;

pub const ID_UE_HISTORY_INFORMATION_FROM_THE_UE: u16 = 105;

pub const ID_UE_RLF_REPORT_CONTAINER: u16 = 60;

pub const ID_UE_RLF_REPORT_CONTAINER_FOR_EXTENDED_BANDS: u16 = 107;

pub const ID_UE_SECURITY_CAPABILITIES: u16 = 113;

pub const ID_UE_X2AP_ID: u16 = 16;

pub const ID_UE_APP_LAYER_MEAS_CONFIG: u16 = 195;

pub const ID_UE_CONTEXT_LEVEL_USER_PLANE_ACTIVITY: u16 = 296;

pub const ID_UE_CONTEXT_REFERENCEAT_SOURCE_NGRAN: u16 = 359;

pub const ID_UEID: u16 = 147;

pub const ID_UE_RADIO_CAPABILITY: u16 = 400;

pub const ID_UE_RADIO_CAPABILITY_ID: u16 = 378;

pub const ID_UE_RADIO_CAPABILITY_ID_MAPPING: u8 = 56;

pub const ID_UE_SIDELINK_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 184;

pub const ID_U_ES_ADMITTED_TO_BE_RESET: u16 = 271;

pub const ID_U_ES_TO_BE_RESET: u16 = 270;

pub const ID_UL_EARFCN_EXTENSION: u16 = 95;

pub const ID_UL_SCHEDULING_PDCCH_CCE_USAGE: u16 = 194;

pub const ID_ULCOUNT_VALUE_EXTENDED: u16 = 92;

pub const ID_ULCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 151;

pub const ID_UL_CARRIER_LIST: u16 = 387;

pub const ID_UNLICENSED_SPECTRUM_RESTRICTION: u16 = 358;

pub const ID_UPLINK_PACKET_LOSS_RATE: u16 = 274;

pub const ID_V2X_SERVICES_AUTHORIZED: u16 = 176;

pub const ID_WLAN_MEASUREMENT_CONFIGURATION: u16 = 304;

pub const ID_WT_UE_CONTEXT_KEPT_INDICATOR: u16 = 183;

pub const ID_X2_REMOVAL_THRESHOLD: u16 = 169;

pub const ID_ACCESS_AND_MOBILITY_INDICATION: u8 = 57;

pub const ID_ADDITIONAL_PLM_NS_ITEM: u16 = 334;

pub const ID_CELL_ACTIVATION: u8 = 15;

pub const ID_CELL_TRAFFIC_TRACE: u8 = 52;

pub const ID_CONDITIONAL_HANDOVER_CANCEL: u8 = 50;

pub const ID_D_L_FORWARDING: u16 = 306;

pub const ID_D_LPDCP_SN_LENGTH: u16 = 311;

pub const ID_DATA_FORWARDING_ADDRESS_INDICATION: u8 = 44;

pub const ID_DEACTIVATE_TRACE: u8 = 46;

pub const ID_DUPLICATION_ACTIVATION: u16 = 315;

pub const ID_E_ARFCN_EXTENSION: u16 = 94;

pub const ID_E_NB_CONFIGURATION_UPDATE: u8 = 8;

pub const ID_E_UTRANR_CELL_RESOURCE_COORDINATION: u8 = 41;

pub const ID_EARLY_STATUS_TRANSFER: u8 = 51;

pub const ID_ENDC_CELL_ACTIVATION: u8 = 39;

pub const ID_ENDC_CONFIGURATION_TRANSFER: u8 = 48;

pub const ID_ENDC_CONFIGURATION_UPDATE: u8 = 37;

pub const ID_ENDC_PARTIAL_RESET: u8 = 40;

pub const ID_ENDC_SON_CONFIGURATION_TRANSFER: u16 = 326;

pub const ID_ENDC_X2_REMOVAL: u8 = 43;

pub const ID_ENDC_X2_SETUP: u8 = 36;

pub const ID_ENDCRESOURCE_STATUS_REPORTING: u8 = 53;

pub const ID_ENDCRESOURCE_STATUS_REPORTING_INITIATION: u8 = 54;

pub const ID_ENHANCED_RNTP: u16 = 148;

pub const ID_ERROR_INDICATION: u8 = 3;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_DL: u16 = 198;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_UL: u16 = 199;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_DL: u16 = 196;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_UL: u16 = 197;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_DOWNLINK: u16 = 200;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_UPLINK: u16 = 201;

pub const ID_F1_C_TRAFFIC_TRANSFER: u8 = 55;

pub const ID_G_NB_STATUS_INDICATION: u8 = 45;

pub const ID_HANDOVER_CANCEL: u8 = 1;

pub const ID_HANDOVER_PREPARATION: u8 = 0;

pub const ID_HANDOVER_REPORT: u8 = 14;

pub const ID_HANDOVER_SUCCESS: u8 = 49;

pub const ID_L_CID: u16 = 314;

pub const ID_LOAD_INDICATION: u8 = 2;

pub const ID_ME_N_BINITIATED_SE_NB_MODIFICATION_PREPARATION: u8 = 21;

pub const ID_ME_N_BINITIATED_SE_NB_RELEASE: u8 = 23;

pub const ID_ME_N_BINITIATED_SG_NB_MODIFICATION_PREPARATION: u8 = 29;

pub const ID_ME_N_BINITIATED_SG_NB_RELEASE: u8 = 31;

pub const ID_MOBILITY_SETTINGS_CHANGE: u8 = 12;

pub const ID_NEW_DRB_ID_REQ: u16 = 325;

pub const ID_PRIVATE_MESSAGE: u8 = 11;

pub const ID_PROCEDURE_CODE_58_NOT_TO_BE_USED: u8 = 58;

pub const ID_R_LF_INDICATION: u8 = 13;

pub const ID_R_RC_TRANSFER: u8 = 35;

pub const ID_RACH_INDICATION: u8 = 60;

pub const ID_RESET: u8 = 7;

pub const ID_RESOURCE_STATUS_REPORTING: u8 = 10;

pub const ID_RESOURCE_STATUS_REPORTING_INITIATION: u8 = 9;

pub const ID_RESUME_ID: u16 = 172;

pub const ID_RETRIEVE_UE_CONTEXT: u8 = 26;

pub const ID_SE_NB_ADDITION_PREPARATION: u8 = 19;

pub const ID_SE_NB_COUNTER_CHECK: u8 = 25;

pub const ID_SE_NB_RECONFIGURATION_COMPLETION: u8 = 20;

pub const ID_SE_N_BINITIATED_SE_NB_MODIFICATION: u8 = 22;

pub const ID_SE_N_BINITIATED_SE_NB_RELEASE: u8 = 24;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT: u8 = 38;

pub const ID_SECONDARYME_NBULGTPTEI_DAT_PDCP: u16 = 313;

pub const ID_SECONDARYSG_NBDLGTPTEI_DAT_PDCP: u16 = 312;

pub const ID_SERVICE_TYPE: u16 = 276;

pub const ID_SG_NB_ADDITION_PREPARATION: u8 = 27;

pub const ID_SG_NB_CHANGE: u8 = 34;

pub const ID_SG_NB_COUNTER_CHECK: u8 = 33;

pub const ID_SG_NB_RECONFIGURATION_COMPLETION: u8 = 28;

pub const ID_SG_N_BINITIATED_SG_NB_MODIFICATION: u8 = 30;

pub const ID_SG_N_BINITIATED_SG_NB_RELEASE: u8 = 32;

pub const ID_SN_STATUS_TRANSFER: u8 = 4;

pub const ID_SOURCE_NG_RAN_NODE_ID: u16 = 411;

pub const ID_TRACE_START: u8 = 47;

pub const ID_U_E_CONTEXT_RELEASE: u8 = 5;

pub const ID_U_L_GT_PTUNNEL_ENDPOINT: u16 = 185;

pub const ID_U_LP_DCP_SN_LENGTH: u16 = 302;

pub const ID_X2_AP_MESSAGE: u16 = 102;

pub const ID_X2_AP_MESSAGE_TRANSFER: u8 = 17;

pub const ID_X2_RELEASE: u8 = 16;

pub const ID_X2_REMOVAL: u8 = 18;

pub const ID_X2_SETUP: u8 = 6;

pub const MAX_CSI_PROCESS: i64 = 4;

pub const MAX_CSI_REPORT: i64 = 2;

pub const MAX_CELL_REPORT: i64 = 9;

pub const MAX_CELLINE_NB: i64 = 256;

pub const MAX_CELLINENG_NB: i64 = 16384;

pub const MAX_EARFCN: i64 = 65535;

pub const MAX_EARFCN_PLUS_ONE: i64 = 65536;

pub const MAX_FAILED_MEAS_OBJECTS: i64 = 32;

pub const MAX_INTERFACES: i64 = 16;

pub const MAX_NR_OF_ERRORS: i64 = 256;

pub const MAX_POOLS: i64 = 16;

pub const MAX_PRIVATE_I_ES: i64 = 65535;

pub const MAX_PROTOCOL_EXTENSIONS: i64 = 65535;

pub const MAX_PROTOCOL_I_ES: i64 = 65535;

pub const MAX_SUBBAND: i64 = 14;

pub const MAX_UE_REPORT: i64 = 128;

pub const MAX_U_ESINENG_NBDU: i64 = 8192;

pub const MAXNO_N_RCELLS_SPECTRUM_SHARING_WITH_E_UTRA: i64 = 64;

pub const MAXNOOF_ADDITIONAL_PLM_NS: i64 = 6;

pub const MAXNOOF_BPLM_NS: i64 = 6;

pub const MAXNOOF_BANDS: i64 = 16;

pub const MAXNOOF_BEARERS: i64 = 256;

pub const MAXNOOF_BLUETOOTH_NAME: i64 = 4;

pub const MAXNOOF_CSIR_SCONFIGURATIONS: i64 = 96;

pub const MAXNOOF_CSIR_SNEIGHBOUR_CELLS: i64 = 16;

pub const MAXNOOF_CSIR_SNEIGHBOUR_CELLS_IN_MTC: i64 = 16;

pub const MAXNOOF_CELL_I_DFOR_MDT: i64 = 32;

pub const MAXNOOF_CELL_I_DFOR_QMC: i64 = 32;

pub const MAXNOOF_CELLS: i64 = 16;

pub const MAXNOOF_CELLSIN_CHO: i64 = 8;

pub const MAXNOOF_CO_MP_CELLS: i64 = 32;

pub const MAXNOOF_CO_MP_HYPOTHESIS_SET: i64 = 256;

pub const MAXNOOF_EPLM_NS: i64 = 15;

pub const MAXNOOF_EPLM_NS_PLUS_ONE: i64 = 16;

pub const MAXNOOF_FORB_LA_CS: i64 = 4096;

pub const MAXNOOF_FORB_TA_CS: i64 = 4096;

pub const MAXNOOF_GTPTL_AS: i64 = 16;

pub const MAXNOOF_MBMS_SERVICE_AREA_IDENTITIES: i64 = 256;

pub const MAXNOOF_MBSFN: i64 = 8;

pub const MAXNOOF_MDTPLM_NS: i64 = 16;

pub const MAXNOOF_MTC_ITEMS: i64 = 16;

pub const MAXNOOF_NR_PHYSICAL_RESOURCE_BLOCKS: i64 = 275;

pub const MAXNOOF_NRSC_SS: i64 = 5;

pub const MAXNOOF_NEIGHBOURS: i64 = 512;

pub const MAXNOOF_NON_ANCHOR_CARRIER_FREQ_CONFIG: i64 = 15;

pub const MAXNOOF_NR_CELL_BANDS: i64 = 32;

pub const MAXNOOF_PA: i64 = 3;

pub const MAXNOOF_PC5_QO_S_FLOWS: i64 = 2048;

pub const MAXNOOF_PDCP_SN: i64 = 16;

pub const MAXNOOF_PLM_NFOR_QMC: i64 = 16;

pub const MAXNOOF_PR_BS: i64 = 110;

pub const MAXNOOF_PS_CELL_CANDIDATES: i64 = 8;

pub const MAXNOOF_PS_CELLS_PER_PRIMARY_CELLIN_UE_HISTORY_INFO: i64 = 8;

pub const MAXNOOF_PS_CELLS_PER_SN: i64 = 8;

pub const MAXNOOF_PROTECTED_RESOURCE_PATTERNS: i64 = 16;

pub const MAXNOOF_RA_REPORTS: i64 = 64;

pub const MAXNOOF_REPORTED_NR_CELLS_POSSIBLY_AGGREGATED: i64 = 16;

pub const MAXNOOF_SSB_AREAS: i64 = 64;

pub const MAXNOOF_SENSOR_NAME: i64 = 3;

pub const MAXNOOF_T_AFOR_MDT: i64 = 8;

pub const MAXNOOF_T_AFOR_QMC: i64 = 8;

pub const MAXNOOF_TL_AS: i64 = 16;

pub const MAXNOOF_TNL_ASSOCIATIONS: i64 = 32;

pub const MAXNOOF_TARGET_SG_N_BS: i64 = 8;

pub const MAXNOOF_TARGET_SG_N_BS_MINUS_ONE: i64 = 7;

pub const MAXNOOF_U_ESFOR_RA_REPORT_INDICATIONS: i64 = 64;

pub const MAXNOOF_WLAN_NAME: i64 = 4;

pub const MAXNOOFEXT_BPLM_NS: i64 = 12;

pub const MAXNOOFTIMEPERIODS: i64 = 2;

pub const MAXOF_NR_NEIGHBOURS: i64 = 1024;

pub const NEWMAX_EARFCN: i64 = 262143;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ABS_Status {
    pub dl_abs_status: DL_ABS_status,
    pub usable_abs_information: UsableABSInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ABS_StatusIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum ABSInformation {
    #[asn(key = 0, extended = false)]
    Fdd(ABSInformationFDD),
    #[asn(key = 1, extended = false)]
    Tdd(ABSInformationTDD),
    #[asn(key = 2, extended = false)]
    Abs_inactive(ABSInformation_abs_inactive),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ABSInformationFDD {
    pub abs_pattern_info: ABSInformationFDDAbs_pattern_info,
    pub number_of_cell_specific_antenna_ports: ABSInformationFDDNumberOfCellSpecificAntennaPorts,
    pub measurement_subset: ABSInformationFDDMeasurement_subset,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ABSInformationFDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ABSInformationTDD {
    pub abs_pattern_info: ABSInformationTDDAbs_pattern_info,
    pub number_of_cell_specific_antenna_ports: ABSInformationTDDNumberOfCellSpecificAntennaPorts,
    pub measurement_subset: ABSInformationTDDMeasurement_subset,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ABSInformationTDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AS_SecurityInformation {
    pub key_e_node_b_star: Key_eNodeB_Star,
    pub next_hop_chaining_count: NextHopChainingCount,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AS_SecurityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AccessAndMobilityIndication {
    pub protocol_i_es: AccessAndMobilityIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ActivatedCellList(pub Vec<ActivatedCellList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ActivatedCellList_Item {
    pub ecgi: ECGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ActivatedCellList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ActivatedNRCellList(pub Vec<ActivatedNRCellList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ActivatedNRCellList_Item {
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ActivatedNRCellList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ActivationID(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AdditionLocationInformation(pub u8);
impl AdditionLocationInformation {
    pub const INCLUDE_PS_CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Additional_Measurement_Timing_Configuration_Item {
    pub additional_measurement_timing_configuration:
        Additional_Measurement_Timing_Configuration_ItemAdditionalMeasurementTimingConfiguration,
    pub csi_rs_mtc_configuration_list: CSI_RS_MTC_Configuration_List,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Additional_Measurement_Timing_Configuration_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct Additional_Measurement_Timing_Configuration_List(
    pub Vec<Additional_Measurement_Timing_Configuration_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct AdditionalListofForwardingGTPTunnelEndpoint(
    pub Vec<AdditionalListofForwardingGTPTunnelEndpoint_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AdditionalListofForwardingGTPTunnelEndpoint_Item {
    #[asn(optional_idx = 0)]
    pub ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<AdditionalListofForwardingGTPTunnelEndpoint_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct AdditionalPLMNs_Item(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct AdditionalRRMPriorityIndex(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AdditionalSpecialSubframe_Info {
    pub additionalspecial_subframe_patterns: AdditionalSpecialSubframePatterns,
    pub cyclic_prefix_dl: CyclicPrefixDL,
    pub cyclic_prefix_ul: CyclicPrefixUL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AdditionalSpecialSubframe_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AdditionalSpecialSubframeExtension_Info {
    pub additionalspecial_subframe_patterns_extension: AdditionalSpecialSubframePatternsExtension,
    pub cyclic_prefix_dl: CyclicPrefixDL,
    pub cyclic_prefix_ul: CyclicPrefixUL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AdditionalSpecialSubframeExtension_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "9")]
pub struct AdditionalSpecialSubframePatterns(pub u8);
impl AdditionalSpecialSubframePatterns {
    pub const SSP0: u8 = 0u8;
    pub const SSP1: u8 = 1u8;
    pub const SSP2: u8 = 2u8;
    pub const SSP3: u8 = 3u8;
    pub const SSP4: u8 = 4u8;
    pub const SSP5: u8 = 5u8;
    pub const SSP6: u8 = 6u8;
    pub const SSP7: u8 = 7u8;
    pub const SSP8: u8 = 8u8;
    pub const SSP9: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AdditionalSpecialSubframePatternsExtension(pub u8);
impl AdditionalSpecialSubframePatternsExtension {
    pub const SSP10: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AerialUEsubscriptionInformation(pub u8);
impl AerialUEsubscriptionInformation {
    pub const ALLOWED: u8 = 0u8;
    pub const NOT_ALLOWED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: Pre_emptionCapability,
    pub pre_emption_vulnerability: Pre_emptionVulnerability,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum AreaScopeOfMDT {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(AreaScopeOfMDT_pLMNWide),
    #[asn(key = 0, extended = true)]
    TAIBased(TAIBasedMDT),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum AreaScopeOfQMC {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedQMC),
    #[asn(key = 1, extended = false)]
    TABased(TABasedQMC),
    #[asn(key = 2, extended = false)]
    TAIBased(TAIBasedQMC),
    #[asn(key = 3, extended = false)]
    PLMNAreaBased(PLMNAreaBasedQMC),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AvailableFastMCGRecoveryViaSRB3(pub u8);
impl AvailableFastMCGRecoveryViaSRB3 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct BPLMN_ID_Info_EUTRA(pub Vec<BPLMN_ID_Info_EUTRA_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BPLMN_ID_Info_EUTRA_Item {
    pub broadcast_plm_ns: BroadcastPLMNs_Item,
    pub tac: TAC,
    pub e_utra_ci: EUTRANCellIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<BPLMN_ID_Info_EUTRA_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct BPLMN_ID_Info_NR(pub Vec<BPLMN_ID_Info_NR_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct BPLMN_ID_Info_NR_Item {
    pub broadcast_plm_ns: BroadcastextPLMNs,
    #[asn(optional_idx = 0)]
    pub five_gs_tac: Option<FiveGS_TAC>,
    pub nr_ci: NRCellIdentifier,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<BPLMN_ID_Info_NR_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BandInfo {
    pub freq_band_indicator: FreqBandIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<BandInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BandwidthReducedSI(pub u8);
impl BandwidthReducedSI {
    pub const SCHEDULED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BearerType(pub u8);
impl BearerType {
    pub const NON_IP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "-101", ub = "100", extensible = true)]
pub struct BenefitMetric(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10000000000")]
pub struct BitRate(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasConfig(pub u8);
impl BluetoothMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BluetoothMeasConfigNameList(pub Vec<BluetoothName>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    #[asn(optional_idx = 0)]
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BluetoothName(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct BroadcastPLMNs_Item(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct BroadcastextPLMNs(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CHO_DC_EarlyDataForwarding(pub u8);
impl CHO_DC_EarlyDataForwarding {
    pub const STOP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CHO_DC_Indicator(pub u8);
impl CHO_DC_Indicator {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6000")]
pub struct CHO_HandoverWindowDuration(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct CHO_HandoverWindowStart(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct CHO_Probability(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CHOTimeBasedInformation {
    pub cho_ho_window_start: CHO_HandoverWindowStart,
    pub cho_ho_window_duration: CHO_HandoverWindowDuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CHOTimeBasedInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CHOinformation_ACK {
    pub requested_target_cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub max_ch_opreparations: Option<MaxCHOpreparations>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CHOinformation_ACKIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CHOinformation_AddReq {
    pub source_e_nb_id: GlobalENB_ID,
    pub source_e_nb_ue_x2ap_id: UE_X2AP_ID,
    #[asn(optional_idx = 0)]
    pub source_e_nb_ue_x2ap_id_ext: Option<UE_X2AP_ID_Extension>,
    #[asn(optional_idx = 1)]
    pub cho_estimated_arrival_probability: Option<CHO_Probability>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<CHOinformation_AddReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CHOinformation_ModReq {
    pub conditional_reconfig: CHOinformation_ModReqConditionalReconfig,
    #[asn(optional_idx = 0)]
    pub cho_estimated_arrival_probability: Option<CHO_Probability>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CHOinformation_ModReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CHOinformation_REQ {
    pub cho_trigger: CHOtrigger,
    #[asn(optional_idx = 0)]
    pub new_e_nb_ue_x2ap_id: Option<UE_X2AP_ID>,
    #[asn(optional_idx = 1)]
    pub new_e_nb_ue_x2ap_id_extension: Option<UE_X2AP_ID_Extension>,
    #[asn(optional_idx = 2)]
    pub cho_estimated_arrival_probability: Option<CHO_Probability>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<CHOinformation_REQIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CHOtrigger(pub u8);
impl CHOtrigger {
    pub const CHO_INITIATION: u8 = 0u8;
    pub const CHO_REPLACE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CNTypeRestrictions(pub Vec<CNTypeRestrictionsItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CNTypeRestrictionsItem {
    pub plmn_id: PLMN_Identity,
    pub cn_type: CNTypeRestrictionsItemCn_type,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CNTypeRestrictionsItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueExtended {
    pub pdcp_sn_extended: PDCP_SNExtended,
    pub hfn_modified: HFNModified,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueExtendedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvalue {
    pub pdcp_sn: PDCP_SN,
    pub hfn: HFN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvalueIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvaluePDCP_SNlength18 {
    pub pdcp_s_nlength18: PDCP_SNlength18,
    pub hf_nfor_pdcp_s_nlength18: HFNforPDCP_SNlength18,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvaluePDCP_SNlength18IE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPACcandidatePSCells_item {
    pub pscell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPACcandidatePSCells_itemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CPACcandidatePSCells_list(pub Vec<CPACcandidatePSCells_item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPACinformation_REQD {
    pub candidate_pscells: CPACcandidatePSCells_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPACinformation_REQDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CPAinformation_MOD {
    #[asn(optional_idx = 0)]
    pub max_no_of_pscells: Option<CPAinformation_MODMax_no_of_pscells>,
    #[asn(optional_idx = 1)]
    pub estimated_arrival_probability: Option<CHO_Probability>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<CPAinformation_MODIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPAinformation_MOD_ACK {
    pub candidate_pscells: CPACcandidatePSCells_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPAinformation_MOD_ACKIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CPAinformation_REQ {
    pub max_no_of_pscells: CPAinformation_REQMax_no_of_pscells,
    #[asn(optional_idx = 0)]
    pub estimated_arrival_probability: Option<CHO_Probability>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CPAinformation_REQIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPAinformation_REQ_ACK {
    pub candidate_pscells: CPACcandidatePSCells_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPAinformation_REQ_ACKIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CPC_cancel {
    pub protocol_i_es: CPC_cancelProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPC_target_SgNB_conf_item {
    pub target_sg_nb_id: GlobalGNB_ID,
    pub candidate_pscells: CPACcandidatePSCells_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPC_target_SgNB_conf_itemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CPC_target_SgNB_conf_list(pub Vec<CPC_target_SgNB_conf_item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPC_target_SgNB_mod_item {
    pub target_sg_nb_id: GlobalGNB_ID,
    pub candidate_pscells: CPACcandidatePSCells_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPC_target_SgNB_mod_itemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CPC_target_SgNB_mod_list(pub Vec<CPC_target_SgNB_mod_item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CPC_target_SgNB_reqd_item {
    pub target_sg_nb_id: GlobalGNB_ID,
    pub cpc_indicator: CPCindicator,
    pub max_no_of_pscells: CPC_target_SgNB_reqd_itemMax_no_of_pscells,
    #[asn(optional_idx = 0)]
    pub estimated_arrival_probability: Option<CHO_Probability>,
    pub sg_n_bto_me_nb_container: SgNBtoMeNBContainer,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CPC_target_SgNB_reqd_itemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CPC_target_SgNB_reqd_list(pub Vec<CPC_target_SgNB_reqd_item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CPCdataforwarding(pub u8);
impl CPCdataforwarding {
    pub const CPC_TRIGGERED: u8 = 0u8;
    pub const EARLY_DATA_TRANSMISSION_STOP: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CPCindicator(pub u8);
impl CPCindicator {
    pub const CPC_INITIATION: u8 = 0u8;
    pub const CPC_MODIFICATION: u8 = 1u8;
    pub const CPC_CANCEL: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPCinformation_CONF {
    pub cpc_target_sgnb_list: CPC_target_SgNB_conf_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPCinformation_CONFIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPCinformation_NOTIFY {
    pub cpc_indicator: CPCdataforwarding,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPCinformation_NOTIFYIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPCinformation_REQD {
    pub cpc_target_sgnb_list: CPC_target_SgNB_reqd_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPCinformation_REQDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CPCupdate_MOD {
    pub cpc_target_sgnb_list: CPC_target_SgNB_mod_list,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CPCupdate_MODIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum CPTransportLayerInformation {
    #[asn(key = 0, extended = false)]
    EndpointIPAddress(TransportLayerAddress),
    #[asn(key = 1, extended = false)]
    EndpointIPAddressAndPort(TransportLayerAddressAndPort),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct CRNTI(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "27", sz_ub = "27")]
pub struct CSG_Id(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSGMembershipStatus(pub u8);
impl CSGMembershipStatus {
    pub const MEMBER: u8 = 0u8;
    pub const NOT_MEMBER: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CSI_RS_MTC_Configuration_Item {
    pub csi_rs_index: CSI_RS_MTC_Configuration_ItemCsi_RS_Index,
    pub csi_rs_status: CSI_RS_MTC_Configuration_ItemCsi_RS_Status,
    #[asn(optional_idx = 0)]
    pub csi_rs_neighbour_list: Option<CSI_RS_Neighbour_List>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CSI_RS_MTC_Configuration_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "96")]
pub struct CSI_RS_MTC_Configuration_List(pub Vec<CSI_RS_MTC_Configuration_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSI_RS_MTC_Neighbour_Item {
    pub csi_rs_index: CSI_RS_MTC_Neighbour_ItemCsi_RS_Index,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CSI_RS_MTC_Neighbour_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CSI_RS_MTC_Neighbour_List(pub Vec<CSI_RS_MTC_Neighbour_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CSI_RS_Neighbour_Item {
    pub nr_cgi: NRCGI,
    #[asn(optional_idx = 0)]
    pub csi_rs_mtc_neighbour_list: Option<CSI_RS_MTC_Neighbour_List>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CSI_RS_Neighbour_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CSI_RS_Neighbour_List(pub Vec<CSI_RS_Neighbour_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CSI_RSTransmissionIndication(pub u8);
impl CSI_RSTransmissionIndication {
    pub const ACTIVATED: u8 = 0u8;
    pub const DEACTIVATED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct CSIReportList(pub Vec<CSIReportList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSIReportPerCSIProcess(pub Vec<CSIReportPerCSIProcess_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct CSIReportPerCSIProcessItem(pub Vec<CSIReportPerCSIProcessItem_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CandidateCellsToBeCancelledList(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct CapacityValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum Cause {
    #[asn(key = 0, extended = false)]
    RadioNetwork(CauseRadioNetwork),
    #[asn(key = 1, extended = false)]
    Transport(CauseTransport),
    #[asn(key = 2, extended = false)]
    Protocol(CauseProtocol),
    #[asn(key = 3, extended = false)]
    Misc(CauseMisc),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct CauseMisc(pub u8);
impl CauseMisc {
    pub const CONTROL_PROCESSING_OVERLOAD: u8 = 0u8;
    pub const HARDWARE_FAILURE: u8 = 1u8;
    pub const OM_INTERVENTION: u8 = 2u8;
    pub const NOT_ENOUGH_USER_PLANE_PROCESSING_RESOURCES: u8 = 3u8;
    pub const UNSPECIFIED: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct CauseProtocol(pub u8);
impl CauseProtocol {
    pub const TRANSFER_SYNTAX_ERROR: u8 = 0u8;
    pub const ABSTRACT_SYNTAX_ERROR_REJECT: u8 = 1u8;
    pub const ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY: u8 = 2u8;
    pub const MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE: u8 = 3u8;
    pub const SEMANTIC_ERROR: u8 = 4u8;
    pub const UNSPECIFIED: u8 = 5u8;
    pub const ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "21")]
pub struct CauseRadioNetwork(pub u8);
impl CauseRadioNetwork {
    pub const HANDOVER_DESIRABLE_FOR_RADIO_REASONS: u8 = 0u8;
    pub const TIME_CRITICAL_HANDOVER: u8 = 1u8;
    pub const RESOURCE_OPTIMISATION_HANDOVER: u8 = 2u8;
    pub const REDUCE_LOAD_IN_SERVING_CELL: u8 = 3u8;
    pub const PARTIAL_HANDOVER: u8 = 4u8;
    pub const UNKNOWN_NEW_E_NB_UE_X2AP_ID: u8 = 5u8;
    pub const UNKNOWN_OLD_E_NB_UE_X2AP_ID: u8 = 6u8;
    pub const UNKNOWN_PAIR_OF_UE_X2AP_ID: u8 = 7u8;
    pub const HO_TARGET_NOT_ALLOWED: u8 = 8u8;
    pub const TX2RELOCOVERALL_EXPIRY: u8 = 9u8;
    pub const TRELOCPREP_EXPIRY: u8 = 10u8;
    pub const CELL_NOT_AVAILABLE: u8 = 11u8;
    pub const NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL: u8 = 12u8;
    pub const INVALID_MME_GROUP_ID: u8 = 13u8;
    pub const UNKNOWN_MME_CODE: u8 = 14u8;
    pub const ENCRYPTION_AND_OR_INTEGRITY_PROTECTION_ALGORITHMS_NOT_SUPPORTED: u8 = 15u8;
    pub const REPORT_CHARACTERISTICS_EMPTY: u8 = 16u8;
    pub const NO_REPORT_PERIODICITY: u8 = 17u8;
    pub const EXISTING_MEASUREMENT_ID: u8 = 18u8;
    pub const UNKNOWN_E_NB_MEASUREMENT_ID: u8 = 19u8;
    pub const MEASUREMENT_TEMPORARILY_NOT_AVAILABLE: u8 = 20u8;
    pub const UNSPECIFIED: u8 = 21u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CauseTransport(pub u8);
impl CauseTransport {
    pub const TRANSPORT_RESOURCE_UNAVAILABLE: u8 = 0u8;
    pub const UNSPECIFIED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct Cell_Size(pub u8);
impl Cell_Size {
    pub const VERYSMALL: u8 = 0u8;
    pub const SMALL: u8 = 1u8;
    pub const MEDIUM: u8 = 2u8;
    pub const LARGE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellActivationFailure {
    pub protocol_i_es: CellActivationFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellActivationRequest {
    pub protocol_i_es: CellActivationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellActivationResponse {
    pub protocol_i_es: CellActivationResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum CellAssistanceInformation {
    #[asn(key = 0, extended = false)]
    Limited_list(Limited_list),
    #[asn(key = 1, extended = false)]
    Full_list(CellAssistanceInformation_full_list),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT {
    pub cell_id_listfor_mdt: CellIdListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedQMC {
    pub cell_id_listfor_qmc: CellIdListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedQMCIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100", extensible = true)]
pub struct CellCapacityClassValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CellDeploymentStatusIndicator(pub u8);
impl CellDeploymentStatusIndicator {
    pub const PRE_CHANGE_NOTIFICATION: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforQMC(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CellInformation_Item {
    pub cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub ul_interference_overload_indication: Option<UL_InterferenceOverloadIndication>,
    #[asn(optional_idx = 1)]
    pub ul_high_interference_indication_info: Option<UL_HighInterferenceIndicationInfo>,
    #[asn(optional_idx = 2)]
    pub relative_narrowband_tx_power: Option<RelativeNarrowbandTxPower>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<CellInformation_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellInformation_List(pub Vec<CellInformation_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CellMeasurementResult_E_UTRA_ENDC_Item {
    pub e_utra_cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub hw_load_indicator: Option<HWLoadIndicator>,
    #[asn(optional_idx = 1)]
    pub s1tnl_load_indicator: Option<S1TNLLoadIndicator>,
    #[asn(optional_idx = 2)]
    pub radio_resource_status: Option<RadioResourceStatus>,
    #[asn(optional_idx = 3)]
    pub composite_available_capacity_group: Option<CompositeAvailableCapacityGroup>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CellMeasurementResult_E_UTRA_ENDC_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellMeasurementResult_E_UTRA_ENDC_List(
    pub Vec<CellMeasurementResult_E_UTRA_ENDC_List_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CellMeasurementResult_Item {
    pub cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub hw_load_indicator: Option<HWLoadIndicator>,
    #[asn(optional_idx = 1)]
    pub s1tnl_load_indicator: Option<S1TNLLoadIndicator>,
    #[asn(optional_idx = 2)]
    pub radio_resource_status: Option<RadioResourceStatus>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<CellMeasurementResult_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellMeasurementResult_List(pub Vec<CellMeasurementResult_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CellMeasurementResult_NR_ENDC_Item {
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub nr_radio_resource_status: Option<NRRadioResourceStatus>,
    #[asn(optional_idx = 1)]
    pub tnl_capacity_indicator: Option<TNLCapacityIndicator>,
    #[asn(optional_idx = 2)]
    pub nr_composite_available_capacity_group: Option<NRCompositeAvailableCapacityGroup>,
    #[asn(optional_idx = 3)]
    pub numberof_active_u_es: Option<CellMeasurementResult_NR_ENDC_ItemNumberofActiveUEs>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CellMeasurementResult_NR_ENDC_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct CellMeasurementResult_NR_ENDC_List(pub Vec<CellMeasurementResult_NR_ENDC_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellReplacingInfo {
    pub replacing_cells_list: ReplacingCellsList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellReplacingInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CellReportingIndicator(pub u8);
impl CellReportingIndicator {
    pub const STOP_REQUEST: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellToReport_E_UTRA_ENDC_Item {
    pub e_utra_cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellToReport_E_UTRA_ENDC_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellToReport_E_UTRA_ENDC_List(pub Vec<CellToReport_E_UTRA_ENDC_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellToReport_Item {
    pub cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellToReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellToReport_List(pub Vec<CellToReport_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CellToReport_NR_ENDC_Item {
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ssb_to_report_list: Option<SSBToReport_List>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CellToReport_NR_ENDC_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct CellToReport_NR_ENDC_List(pub Vec<CellToReport_NR_ENDC_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellTrafficTrace {
    pub protocol_i_es: CellTrafficTraceProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellType {
    pub cell_size: Cell_Size,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellTypeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CellandCapacityAssistInfo {
    #[asn(optional_idx = 0)]
    pub maximum_cell_list_size: Option<MaximumCellListSize>,
    #[asn(optional_idx = 1)]
    pub cell_assistance_information: Option<CellAssistanceInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<CellandCapacityAssistInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CoMPHypothesisSet(pub Vec<CoMPHypothesisSetItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CoMPHypothesisSetItem {
    pub co_mp_cell_id: ECGI,
    pub co_mp_hypothesis: CoMPHypothesisSetItemCoMPHypothesis,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CoMPHypothesisSetItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CoMPInformation {
    pub co_mp_information_item: CoMPInformationItem,
    pub co_mp_information_start_time: CoMPInformationStartTime,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CoMPInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CoMPInformationItem(pub Vec<CoMPInformationItem_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "1")]
pub struct CoMPInformationStartTime(pub Vec<CoMPInformationStartTime_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompleteFailureCauseInformation_Item {
    pub cell_id: ECGI,
    pub measurement_failure_cause_list: MeasurementFailureCause_List,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompleteFailureCauseInformation_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CompleteFailureCauseInformation_List(
    pub Vec<CompleteFailureCauseInformation_List_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CompositeAvailableCapacity {
    #[asn(optional_idx = 0)]
    pub cell_capacity_class_value: Option<CellCapacityClassValue>,
    pub capacity_value: CapacityValue,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CompositeAvailableCapacityIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompositeAvailableCapacityGroup {
    pub dl_composite_available_capacity: CompositeAvailableCapacity,
    pub ul_composite_available_capacity: CompositeAvailableCapacity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompositeAvailableCapacityGroupIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ConditionalHandoverCancel {
    pub protocol_i_es: ConditionalHandoverCancelProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct Correlation_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CoverageModification_Item {
    pub ecgi: ECGI,
    pub coverage_state: CoverageModification_ItemCoverageState,
    #[asn(optional_idx = 0)]
    pub cell_deployment_status_indicator: Option<CellDeploymentStatusIndicator>,
    #[asn(optional_idx = 1)]
    pub cell_replacing_info: Option<CellReplacingInfo>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CoverageModificationList(pub Vec<CoverageModification_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Criticality(pub u8);
impl Criticality {
    pub const REJECT: u8 = 0u8;
    pub const IGNORE: u8 = 1u8;
    pub const NOTIFY: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CriticalityDiagnostics {
    #[asn(optional_idx = 0)]
    pub procedure_code: Option<ProcedureCode>,
    #[asn(optional_idx = 1)]
    pub triggering_message: Option<TriggeringMessage>,
    #[asn(optional_idx = 2)]
    pub procedure_criticality: Option<Criticality>,
    #[asn(optional_idx = 3)]
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CriticalityDiagnosticsIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CriticalityDiagnostics_IE_List(pub Vec<CriticalityDiagnostics_IE_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CyclicPrefixDL(pub u8);
impl CyclicPrefixDL {
    pub const NORMAL: u8 = 0u8;
    pub const EXTENDED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CyclicPrefixUL(pub u8);
impl CyclicPrefixUL {
    pub const NORMAL: u8 = 0u8;
    pub const EXTENDED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSRequestInfo {
    pub daps_indicator: DAPSRequestInfoDAPSIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSRequestInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfo {
    pub daps_response_indicator: DAPSResponseInfoDAPSResponseIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_ABS_status(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DL_Forwarding(pub u8);
impl DL_Forwarding {
    pub const D_L_FORWARDING_PROPOSED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_GBR_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_GBR_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_Total_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_Total_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_non_GBR_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_non_GBR_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct DL_scheduling_PDCCH_CCE_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DLDiscarding {
    pub e_ra_bs_subject_to_dl_discarding_list: E_RABsSubjectToDLDiscarding_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DLDiscardingIE_Extension>,
}

pub type DLResourceBitmapULandDLSharing = DataTrafficResources;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum DLResourcesULandDLSharing {
    #[asn(key = 0, extended = false)]
    Unchanged(DLResourcesULandDLSharing_unchanged),
    #[asn(key = 1, extended = false)]
    Changed(DLResourceBitmapULandDLSharing),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct DRB_ID(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DataForwardingAddressIndication {
    pub protocol_i_es: DataForwardingAddressIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DataTrafficResourceIndication {
    pub activation_sfn: DataTrafficResourceIndicationActivationSFN,
    pub shared_resource_type: SharedResourceType,
    #[asn(optional_idx = 0)]
    pub reserved_subframe_pattern: Option<ReservedSubframePattern>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<DataTrafficResourceIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "6",
    sz_ub = "17600"
)]
pub struct DataTrafficResources(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeactivateTrace {
    pub protocol_i_es: DeactivateTraceProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DeactivationIndication(pub u8);
impl DeactivationIndication {
    pub const DEACTIVATED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DeliveryStatus {
    pub highest_success_delivered_pdcpsn: DeliveryStatusHighestSuccessDeliveredPDCPSN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DeliveryStatusIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct DesiredActNotificationLevel(pub u8);
impl DesiredActNotificationLevel {
    pub const NONE: u8 = 0u8;
    pub const E_RAB: u8 = 1u8;
    pub const UE_LEVEL: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DirectForwardingPathAvailability(pub u8);
impl DirectForwardingPathAvailability {
    pub const DIRECT_PATH_AVAILABLE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DuplicationActivation(pub u8);
impl DuplicationActivation {
    pub const ACTIVE: u8 = 0u8;
    pub const INACTIVE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum DynamicDLTransmissionInformation {
    #[asn(key = 0, extended = false)]
    Naics_active(DynamicNAICSInformation),
    #[asn(key = 1, extended = false)]
    Naics_inactive(DynamicDLTransmissionInformation_naics_inactive),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct DynamicNAICSInformation {
    #[asn(optional_idx = 0)]
    pub transmission_modes: Option<DynamicNAICSInformationTransmissionModes>,
    #[asn(optional_idx = 1)]
    pub pb_information: Option<DynamicNAICSInformationPB_information>,
    pub pa_list: DynamicNAICSInformationPA_list,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<DynamicNAICSInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct E_RAB_ID(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RAB_Item {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RAB_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RAB_Level_QoS_Parameters {
    pub qci: QCI,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    #[asn(optional_idx = 0)]
    pub gbr_qos_information: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RAB_Level_QoS_ParametersIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RAB_List(pub Vec<E_RAB_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABUsageReport_Item {
    pub start_time_stamp: E_RABUsageReport_ItemStartTimeStamp,
    pub end_time_stamp: E_RABUsageReport_ItemEndTimeStamp,
    pub usage_count_ul: E_RABUsageReport_ItemUsageCountUL,
    pub usage_count_dl: E_RABUsageReport_ItemUsageCountDL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABUsageReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct E_RABUsageReportList(pub Vec<E_RABUsageReportList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_Admitted_Item {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ul_gtp_tunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_gtp_tunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_Admitted_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_List(pub Vec<E_RABs_Admitted_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeAdded_Item {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_Admitted_ToBeAdded_Item_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_Admitted_ToBeAdded_Item_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_Admitted_ToBeAdded_Item_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub s1_dl_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeAdded_Item_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub se_nb_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeAdded_List(pub Vec<E_RABs_Admitted_ToBeAdded_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeAdded_ModAckItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_Admitted_ToBeAdded_ModAckItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub s1_dl_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub se_nb_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckList(
    pub Vec<E_RABs_Admitted_ToBeAdded_ModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresent {
    pub sg_nb_dl_gtp_tei_dat_scg: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub secondary_sg_nb_dl_gtp_tei_dat_scg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresent {
    pub s1_dl_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub sg_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub rlc_mode: Option<RLCMode>,
    #[asn(optional_idx = 2)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 3)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 4)]
    pub mcg_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 5)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 6)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresent {
    pub sg_nb_dl_gtp_tei_dat_scg: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub secondary_sg_nb_dl_gtp_tei_dat_scg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresent {
    pub s1_dl_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub sg_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub rlc_mode: Option<RLCMode>,
    #[asn(optional_idx = 2)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 3)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 4)]
    pub mcg_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 5)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 6)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAckList(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeModified_ModAckItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_Admitted_ToBeModified_ModAckItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_Admitted_ToBeModified_ModAckItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub s1_dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub se_nb_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeModified_ModAckList(
    pub Vec<E_RABs_Admitted_ToBeModified_ModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_Admitted_ToBeModified_SgNBModAck_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub sg_nb_dl_gtp_tei_dat_scg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub s1_dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub sg_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub mcg_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 3)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 4)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAckList(
    pub Vec<E_RABs_Admitted_ToBeModified_SgNBModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckList(
    pub Vec<E_RABs_Admitted_ToBeReleased_ModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions:
        Option<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAckList(
    pub Vec<E_RABs_Admitted_ToBeReleased_SgNBModAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item {
    pub e_rab_id: E_RAB_ID,
    pub rlc_mode_transferred: RLCMode,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList(
    pub Vec<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToReleased_ModAckItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_Admitted_ToBeReleased_ModAckItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_Admitted_ToReleased_SgNBModAck_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_Admitted_ToReleased_SgNBModAck_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_Admitted_ToReleased_SgNBModAck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_AdmittedToBeModified_SgNBModConf_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_AdmittedToBeModified_SgNBModConf_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub secondary_me_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions:
        Option<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions:
        Option<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConfList(
    pub Vec<E_RABs_AdmittedToBeModified_SgNBModConfList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_DataForwardingAddress_Item {
    pub e_rab_id: E_RAB_ID,
    pub dl_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_DataForwardingAddress_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_DataForwardingAddress_List(pub Vec<E_RABs_DataForwardingAddress_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_SubjectToCounterCheck_List(pub Vec<E_RABs_SubjectToCounterCheck_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_SubjectToCounterCheckItem {
    pub e_rab_id: E_RAB_ID,
    pub ul_count: E_RABs_SubjectToCounterCheckItemUL_Count,
    pub dl_count: E_RABs_SubjectToCounterCheckItemDL_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_SubjectToCounterCheckItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_SubjectToSgNBCounterCheck_Item {
    pub e_rab_id: E_RAB_ID,
    pub ul_count: E_RABs_SubjectToSgNBCounterCheck_ItemUL_Count,
    pub dl_count: E_RABs_SubjectToSgNBCounterCheck_ItemDL_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_SubjectToSgNBCounterCheck_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_SubjectToSgNBCounterCheck_List(
    pub Vec<E_RABs_SubjectToSgNBCounterCheck_List_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_SubjectToStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub receive_statusof_ulpdcpsd_us: Option<ReceiveStatusofULPDCPSDUs>,
    pub ul_coun_tvalue: COUNTvalue,
    pub dl_coun_tvalue: COUNTvalue,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_SubjectToStatusTransfer_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_SubjectToStatusTransfer_List(pub Vec<E_RABs_SubjectToStatusTransfer_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeAdded_Item {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeAdded_Item_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeAdded_Item_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeAdded_Item_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DL_Forwarding>,
    pub s1_ul_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeAdded_Item_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    pub me_nb_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeAdded_List(pub Vec<E_RABs_ToBeAdded_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeAdded_List_ModReq(pub Vec<E_RABs_ToBeAdded_List_ModReq_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeAdded_ModReqItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeAdded_ModReqItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeAdded_ModReqItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeAdded_ModReqItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DL_Forwarding>,
    pub s1_ul_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeAdded_ModReqItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    pub me_nb_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item {
    pub e_rab_id: E_RAB_ID,
    pub drb_id: DRB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeAdded_SgNBAddReq_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBAddReq_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresent {
    pub requested_scg_e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    pub me_nb_ul_gtp_tei_dat_pdcp: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub secondary_me_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    pub rlc_mode: RLCMode,
    #[asn(optional_idx = 1)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresent {
    pub full_e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub max_mcg_admit_e_rab_level_qo_s_parameters: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub dl_forwarding: Option<DL_Forwarding>,
    #[asn(optional_idx = 2)]
    pub me_nb_dl_gtp_tei_dat_mcg: Option<GTPtunnelEndpoint>,
    pub s1_ul_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeAdded_SgNBAddReqList(pub Vec<E_RABs_ToBeAdded_SgNBAddReqList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item {
    pub e_rab_id: E_RAB_ID,
    pub drb_id: DRB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeAdded_SgNBModReq_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBModReq_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresent {
    pub requested_scg_e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    pub me_nb_ul_gtp_tei_dat_pdcp: GTPtunnelEndpoint,
    #[asn(optional_idx = 0)]
    pub secondary_me_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    pub rlc_mode: RLCMode,
    #[asn(optional_idx = 1)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresent {
    pub full_e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub max_mn_admit_e_rab_level_qo_s_parameters: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub dl_forwarding: Option<DL_Forwarding>,
    #[asn(optional_idx = 2)]
    pub me_nb_dl_gtp_tei_dat_mcg: Option<GTPtunnelEndpoint>,
    pub s1_ul_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeAdded_SgNBModReq_List(pub Vec<E_RABs_ToBeAdded_SgNBModReq_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeModified_List_ModReq(pub Vec<E_RABs_ToBeModified_List_ModReq_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeModified_ModReqItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeModified_ModReqItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeModified_ModReqItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeModified_ModReqItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 1)]
    pub s1_ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeModified_ModReqItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeModified_ModReqItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 1)]
    pub me_nb_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeModified_ModReqItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeModified_SgNBModReq_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReq_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub requested_scg_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 1)]
    pub me_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub full_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 1)]
    pub max_mn_admit_e_rab_level_qo_s_parameters: Option<GBR_QosInformation>,
    #[asn(optional_idx = 2)]
    pub me_nb_dl_gtp_tei_dat_mcg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 3)]
    pub s1_ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeModified_SgNBModReq_List(pub Vec<E_RABs_ToBeModified_SgNBModReq_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeModified_SgNBModReqd_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReqd_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub sg_nb_dl_gtp_tei_dat_scg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub secondary_sg_nb_dl_gtp_tei_dat_scg: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub requested_mcg_e_rab_level_qo_s_parameters: Option<E_RAB_Level_QoS_Parameters>,
    #[asn(optional_idx = 1)]
    pub ul_configuration: Option<ULConfiguration>,
    #[asn(optional_idx = 2)]
    pub sg_nb_ul_gtp_tei_dat_pdcp: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 3)]
    pub s1_dl_gtp_tei_dat_sg_nb: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeModified_SgNBModReqdList(pub Vec<E_RABs_ToBeModified_SgNBModReqdList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_List_ModReq(pub Vec<E_RABs_ToBeReleased_List_ModReq_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_List_RelConf(pub Vec<E_RABs_ToBeReleased_List_RelConf_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_List_RelReq(pub Vec<E_RABs_ToBeReleased_List_RelReq_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_ModReqItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeReleased_ModReqItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeReleased_ModReqItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_ModReqItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_ModReqItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeReleased_ModReqItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_ModReqItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_ModReqd(pub Vec<E_RABs_ToBeReleased_ModReqd_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_ModReqdItem {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_ModReqdItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_RelConfItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeReleased_RelConfItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeReleased_RelConfItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_RelConfItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_RelConfItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeReleased_RelConfItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_RelConfItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_RelReqItem {
    #[asn(key = 0, extended = false)]
    SCG_Bearer(E_RABs_ToBeReleased_RelReqItem_SCG_Bearer),
    #[asn(key = 1, extended = false)]
    Split_Bearer(E_RABs_ToBeReleased_RelReqItem_Split_Bearer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_RelReqItem_SCG_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ul_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_RelReqItem_SCG_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeReleased_RelReqItem_Split_Bearer {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_RelReqItem_Split_BearerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeReleased_SgNBChaConf_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBChaConf_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBChaConfList(pub Vec<E_RABs_ToBeReleased_SgNBChaConfList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeReleased_SgNBModReq_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBModReq_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBModReq_List(pub Vec<E_RABs_ToBeReleased_SgNBModReq_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBModReqd_Item {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBModReqdList(pub Vec<E_RABs_ToBeReleased_SgNBModReqdList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeReleased_SgNBRelConf_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelConf_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBRelConfList(pub Vec<E_RABs_ToBeReleased_SgNBRelConfList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item {
    pub e_rab_id: E_RAB_ID,
    pub en_dc_resource_configuration: EN_DC_ResourceConfiguration,
    pub resource_configuration: E_RABs_ToBeReleased_SgNBRelReq_ItemResource_configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelReq_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresent {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresent {
    #[asn(optional_idx = 0)]
    pub ul_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 1)]
    pub dl_gt_ptunnel_endpoint: Option<GTPtunnelEndpoint>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReqList(pub Vec<E_RABs_ToBeReleased_SgNBRelReqList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABs_ToBeReleased_SgNBRelReqd_Item {
    pub e_rab_id: E_RAB_ID,
    pub rlc_mode_transferred: RLCMode,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABs_ToBeReleased_SgNBRelReqd_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReqdList(pub Vec<E_RABs_ToBeReleased_SgNBRelReqdList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeSetup_Item {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DL_Forwarding>,
    pub ul_gt_ptunnel_endpoint: GTPtunnelEndpoint,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeSetup_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeSetup_List(pub Vec<E_RABs_ToBeSetup_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABs_ToBeSetup_ListRetrieve(pub Vec<E_RABs_ToBeSetup_ListRetrieve_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABs_ToBeSetupRetrieve_Item {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RAB_Level_QoS_Parameters,
    #[asn(optional_idx = 0)]
    pub bearer_type: Option<BearerType>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABs_ToBeSetupRetrieve_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABsSubjectToDLDiscarding_Item {
    pub e_rab_id: E_RAB_ID,
    pub discard_dl_count_value: COUNTvalue,
    #[asn(optional_idx = 0)]
    pub discard_dl_count_value_extended: Option<COUNTValueExtended>,
    #[asn(optional_idx = 1)]
    pub discard_dl_count_valuefor_pdcpsn_length18: Option<COUNTvaluePDCP_SNlength18>,
    #[asn(optional_idx = 2)]
    pub ie_extension: Option<E_RABsSubjectToDLDiscarding_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABsSubjectToDLDiscarding_List(pub Vec<E_RABsSubjectToDLDiscarding_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct E_RABsSubjectToEarlyStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    pub first_dl_count_value: COUNTvalue,
    #[asn(optional_idx = 0)]
    pub first_dl_count_value_extended: Option<COUNTValueExtended>,
    #[asn(optional_idx = 1)]
    pub first_dl_count_valuefor_pdcpsn_length18: Option<COUNTvaluePDCP_SNlength18>,
    #[asn(optional_idx = 2)]
    pub ie_extension: Option<E_RABsSubjectToEarlyStatusTransfer_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABsSubjectToEarlyStatusTransfer_List(
    pub Vec<E_RABsSubjectToEarlyStatusTransfer_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct EARFCN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "65536", ub = "262143", extensible = true)]
pub struct EARFCNExtension(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ECGI {
    pub plmn_identity: PLMN_Identity,
    pub eutra_ncell_identifier: EUTRANCellIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ECGIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DC_ResourceConfiguration {
    pub pdc_pat_sg_nb: EN_DC_ResourceConfigurationPDCPatSgNB,
    pub mc_gresources: EN_DC_ResourceConfigurationMCGresources,
    pub sc_gresources: EN_DC_ResourceConfigurationSCGresources,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DC_ResourceConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ENB_ID {
    #[asn(key = 0, extended = false)]
    Macro_eNB_ID(ENB_ID_macro_eNB_ID),
    #[asn(key = 1, extended = false)]
    Home_eNB_ID(ENB_ID_home_eNB_ID),
    #[asn(key = 0, extended = true)]
    Short_Macro_eNB_ID(ENB_ID_short_Macro_eNB_ID),
    #[asn(key = 1, extended = true)]
    Long_Macro_eNB_ID(ENB_ID_long_Macro_eNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdate {
    pub protocol_i_es: ENBConfigurationUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateAcknowledge {
    pub protocol_i_es: ENBConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateFailure {
    pub protocol_i_es: ENBConfigurationUpdateFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCCellActivationFailure {
    pub protocol_i_es: ENDCCellActivationFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCCellActivationRequest {
    pub protocol_i_es: ENDCCellActivationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCCellActivationResponse {
    pub protocol_i_es: ENDCCellActivationResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCConfigurationTransfer {
    pub protocol_i_es: ENDCConfigurationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCConfigurationUpdate {
    pub protocol_i_es: ENDCConfigurationUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCConfigurationUpdateAcknowledge {
    pub protocol_i_es: ENDCConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCConfigurationUpdateFailure {
    pub protocol_i_es: ENDCConfigurationUpdateFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCPartialResetConfirm {
    pub protocol_i_es: ENDCPartialResetConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCPartialResetRequired {
    pub protocol_i_es: ENDCPartialResetRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCResourceStatusFailure {
    pub protocol_i_es: ENDCResourceStatusFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCResourceStatusRequest {
    pub protocol_i_es: ENDCResourceStatusRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCResourceStatusResponse {
    pub protocol_i_es: ENDCResourceStatusResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCResourceStatusUpdate {
    pub protocol_i_es: ENDCResourceStatusUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2RemovalFailure {
    pub protocol_i_es: ENDCX2RemovalFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2RemovalRequest {
    pub protocol_i_es: ENDCX2RemovalRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2RemovalResponse {
    pub protocol_i_es: ENDCX2RemovalResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2SetupFailure {
    pub protocol_i_es: ENDCX2SetupFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2SetupRequest {
    pub protocol_i_es: ENDCX2SetupRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENDCX2SetupResponse {
    pub protocol_i_es: ENDCX2SetupResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct EPCHandoverRestrictionListContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct EPLMNs(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ERABActivityNotifyItem {
    pub e_rab_id: E_RAB_ID,
    pub activity_report: UserPlaneTrafficActivityReport,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ERABActivityNotifyItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ERABActivityNotifyItemList(pub Vec<ERABActivityNotifyItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum EUTRA_Mode_Info {
    #[asn(key = 0, extended = false)]
    FDD(FDD_Info),
    #[asn(key = 1, extended = false)]
    TDD(TDD_Info),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct EUTRANCellIdentifier(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANRCellResourceCoordinationRequest {
    pub protocol_i_es: EUTRANRCellResourceCoordinationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANRCellResourceCoordinationResponse {
    pub protocol_i_es: EUTRANRCellResourceCoordinationResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct EUTRANTraceID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EarlyStatusTransfer {
    pub protocol_i_es: EarlyStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EncryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct EndcSONConfigurationTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EnhancedRNTP {
    pub enhanced_rntp_bitmap: EnhancedRNTPEnhancedRNTPBitmap,
    pub rntp_high_power_threshold: RNTP_Threshold,
    #[asn(optional_idx = 0)]
    pub enhanced_rntp_start_time: Option<EnhancedRNTPStartTime>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<EnhancedRNTPIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EnhancedRNTPStartTime {
    pub start_sfn: EnhancedRNTPStartTimeStartSFN,
    pub start_subframe_number: EnhancedRNTPStartTimeStartSubframeNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EnhancedRNTPStartTimeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ErrorIndication {
    pub protocol_i_es: ErrorIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Ethernet_Type(pub u8);
impl Ethernet_Type {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EventType(pub u8);
impl EventType {
    pub const CHANGE_OF_SERVING_CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedActivityPeriod(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct ExpectedHOInterval(pub u8);
impl ExpectedHOInterval {
    pub const SEC15: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC90: u8 = 3u8;
    pub const SEC120: u8 = 4u8;
    pub const SEC180: u8 = 5u8;
    pub const LONG_TIME: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedIdlePeriod(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ExpectedUEActivityBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    #[asn(optional_idx = 1)]
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    #[asn(optional_idx = 2)]
    pub sourceof_ue_activity_behaviour_information: Option<SourceOfUEActivityBehaviourInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ExpectedUEBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity: Option<ExpectedUEActivityBehaviour>,
    #[asn(optional_idx = 1)]
    pub expected_ho_interval: Option<ExpectedHOInterval>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ExpectedUEBehaviourIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "INTEGER",
    lb = "10000000001",
    ub = "4000000000000",
    extensible = true
)]
pub struct ExtendedBitRate(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ExtendedULInterferenceOverloadInfo {
    pub associated_subframes: ExtendedULInterferenceOverloadInfoAssociatedSubframes,
    pub extended_ul_interference_overload_indication: UL_InterferenceOverloadIndication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ExtendedULInterferenceOverloadInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct F1CTrafficContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct F1CTrafficTransfer {
    pub protocol_i_es: F1CTrafficTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FDD_Info {
    pub ul_earfcn: EARFCN,
    pub dl_earfcn: EARFCN,
    pub ul_transmission_bandwidth: Transmission_Bandwidth,
    pub dl_transmission_bandwidth: Transmission_Bandwidth,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FDD_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FDD_InfoNeighbourServedNRCell_Information {
    pub ul_nr_freq_info: NRFreqInfo,
    pub dl_nr_freq_info: NRFreqInfo,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FDD_InfoNeighbourServedNRCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FDD_InfoServedNRCell_Information {
    pub ul_nr_freq_info: NRFreqInfo,
    pub dl_nr_freq_info: NRFreqInfo,
    pub ul_nr_tx_bw: NR_TxBW,
    pub dl_nr_tx_bw: NR_TxBW,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FDD_InfoServedNRCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct FastMCGRecovery {
    #[asn(optional_idx = 0)]
    pub rrc_container: Option<RRCContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<FastMCGRecoveryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FirstDLCount {
    pub e_ra_bs_subject_to_early_status_transfer: E_RABsSubjectToEarlyStatusTransfer_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<FirstDLCountIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct FiveGS_TAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct FiveQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ForbiddenInterRATs(pub u8);
impl ForbiddenInterRATs {
    pub const ALL: u8 = 0u8;
    pub const GERAN: u8 = 1u8;
    pub const UTRAN: u8 = 2u8;
    pub const CDMA2000: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenLACs(pub Vec<LAC>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenLAs(pub Vec<ForbiddenLAs_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenLAs_Item {
    pub plmn_identity: PLMN_Identity,
    pub forbidden_la_cs: ForbiddenLACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenLAs_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenTACs(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenTAs(pub Vec<ForbiddenTAs_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenTAs_Item {
    pub plmn_identity: PLMN_Identity,
    pub forbidden_ta_cs: ForbiddenTACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenTAs_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct Fourframes(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256", extensible = true)]
pub struct FreqBandIndicator(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct FreqBandIndicatorPriority(pub u8);
impl FreqBandIndicatorPriority {
    pub const NOT_BROADCASTED: u8 = 0u8;
    pub const BROADCASTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FreqBandNrItem {
    pub freq_band_indicator_nr: FreqBandNrItemFreqBandIndicatorNr,
    pub supported_sul_band_list: FreqBandNrItemSupportedSULBandList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FreqBandNrItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct FrequencyShift7p5khz(pub u8);
impl FrequencyShift7p5khz {
    pub const FALSE: u8 = 0u8;
    pub const TRUE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GBR_QosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GBR_QosInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum GNB_ID {
    #[asn(key = 0, extended = false)]
    GNB_ID(GNB_ID_gNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct GNBOverloadInformation(pub u8);
impl GNBOverloadInformation {
    pub const OVERLOADED: u8 = 0u8;
    pub const NOT_OVERLOADED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct GNBStatusIndication {
    pub protocol_i_es: GNBStatusIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct GTP_TEI(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GTPTLA_Item {
    pub gtp_transport_layer_addresses: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GTPTLA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct GTPTLAs(pub Vec<GTPTLA_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GTPtunnelEndpoint {
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GTPtunnelEndpointIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GU_Group_ID {
    pub plmn_identity: PLMN_Identity,
    pub mme_group_id: MME_Group_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GU_Group_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct GUGroupIDList(pub Vec<GU_Group_ID>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GUMMEI {
    pub gu_group_id: GU_Group_ID,
    pub mme_code: MME_Code,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GUMMEIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum Global_RAN_NODE_ID {
    #[asn(key = 0, extended = false)]
    GNB(GlobalGNB_ID),
    #[asn(key = 1, extended = false)]
    Choice_extension(Global_RAN_NODE_ID_choice_extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalENB_ID {
    pub plmn_identity: PLMN_Identity,
    pub enb_id: ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalENB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalGNB_ID {
    pub plmn_identity: PLMN_Identity,
    pub gnb_id: GNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalGNB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct HFN(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "131071")]
pub struct HFNModified(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct HFNforPDCP_SNlength18(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct HWLoadIndicator {
    pub dlhw_load_indicator: LoadIndicator,
    pub ulhw_load_indicator: LoadIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<HWLoadIndicatorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancel {
    pub protocol_i_es: HandoverCancelProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverPreparationFailure {
    pub protocol_i_es: HandoverPreparationFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverReport {
    pub protocol_i_es: HandoverReportProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct HandoverReportType(pub u8);
impl HandoverReportType {
    pub const HO_TOO_EARLY: u8 = 0u8;
    pub const HO_TO_WRONG_CELL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequest {
    pub protocol_i_es: HandoverRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequestAcknowledge {
    pub protocol_i_es: HandoverRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct HandoverRestrictionList {
    pub serving_plmn: PLMN_Identity,
    #[asn(optional_idx = 0)]
    pub equivalent_plm_ns: Option<EPLMNs>,
    #[asn(optional_idx = 1)]
    pub forbidden_t_as: Option<ForbiddenTAs>,
    #[asn(optional_idx = 2)]
    pub forbidden_l_as: Option<ForbiddenLAs>,
    #[asn(optional_idx = 3)]
    pub forbidden_inter_ra_ts: Option<ForbiddenInterRATs>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<HandoverRestrictionListIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverSuccess {
    pub protocol_i_es: HandoverSuccessProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IABAuthorized(pub u8);
impl IABAuthorized {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IABNodeIndication(pub u8);
impl IABNodeIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IMSvoiceEPSfallbackfrom5G(pub u8);
impl IMSvoiceEPSfallbackfrom5G {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingMessage {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: InitiatingMessageValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum InitiatingNodeType_EndcConfigUpdate {
    #[asn(key = 0, extended = false)]
    Init_eNB(InitiatingNodeType_EndcConfigUpdate_init_eNB),
    #[asn(key = 1, extended = false)]
    Init_en_gNB(InitiatingNodeType_EndcConfigUpdate_init_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum InitiatingNodeType_EndcX2Removal {
    #[asn(key = 0, extended = false)]
    Init_eNB(InitiatingNodeType_EndcX2Removal_init_eNB),
    #[asn(key = 1, extended = false)]
    Init_en_gNB(InitiatingNodeType_EndcX2Removal_init_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum InitiatingNodeType_EndcX2Setup {
    #[asn(key = 0, extended = false)]
    Init_eNB(InitiatingNodeType_EndcX2Setup_init_eNB),
    #[asn(key = 1, extended = false)]
    Init_en_gNB(InitiatingNodeType_EndcX2Setup_init_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum InitiatingNodeType_EutranrCellResourceCoordination {
    #[asn(key = 0, extended = false)]
    Initiate_eNB(InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB),
    #[asn(key = 1, extended = false)]
    Initiate_en_gNB(InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct IntegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct IntegrityProtectionIndication(pub u8);
impl IntegrityProtectionIndication {
    pub const REQUIRED: u8 = 0u8;
    pub const PREFERRED: u8 = 1u8;
    pub const NOTNEEDED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IntegrityProtectionResult(pub u8);
impl IntegrityProtectionResult {
    pub const PERFORMED: u8 = 0u8;
    pub const NOTPERFORMED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IntendedTDD_DL_ULConfiguration_NR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct InterfaceInstanceIndication(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct InterfacesToTrace(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct InvokeIndication(pub u8);
impl InvokeIndication {
    pub const ABS_INFORMATION: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct Key_eNodeB_Star(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32", extensible = true)]
pub struct LCID(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "256"
)]
pub struct LHN_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum LastVisitedCell_Item {
    #[asn(key = 0, extended = false)]
    E_UTRAN_Cell(LastVisitedEUTRANCellInformation),
    #[asn(key = 1, extended = false)]
    UTRAN_Cell(LastVisitedUTRANCellInformation),
    #[asn(key = 2, extended = false)]
    GERAN_Cell(LastVisitedGERANCellInformation),
    #[asn(key = 0, extended = true)]
    NG_RAN_Cell(LastVisitedNGRANCellInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LastVisitedEUTRANCellInformation {
    pub global_cell_id: ECGI,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: Time_UE_StayedInCell,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LastVisitedEUTRANCellInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum LastVisitedGERANCellInformation {
    #[asn(key = 0, extended = false)]
    Undefined(LastVisitedGERANCellInformation_undefined),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedNGRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedPSCell_Item(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct Limited_list(pub Vec<Limited_list_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Links_to_log(pub u8);
impl Links_to_log {
    pub const UPLINK: u8 = 0u8;
    pub const DOWNLINK: u8 = 1u8;
    pub const BOTH_UPLINK_AND_DOWNLINK: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ListofEUTRACellsinEUTRACoordinationReq(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ListofEUTRACellsinEUTRACoordinationResp(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ListofEUTRACellsinNRCoordinationReq(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "64")]
pub struct ListofNRCellsinNRCoordinationReq(pub Vec<NRCGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "64")]
pub struct ListofNRCellsinNRCoordinationResp(pub Vec<NRCGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct LoadIndicator(pub u8);
impl LoadIndicator {
    pub const LOW_LOAD: u8 = 0u8;
    pub const MEDIUM_LOAD: u8 = 1u8;
    pub const HIGH_LOAD: u8 = 2u8;
    pub const OVER_LOAD: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LoadInformation {
    pub protocol_i_es: LoadInformationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LocationInformationSgNB {
    pub ps_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LocationInformationSgNBIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LocationInformationSgNBReporting(pub u8);
impl LocationInformationSgNBReporting {
    pub const P_S_CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LocationReportingInformation {
    pub event_type: EventType,
    pub report_area: ReportArea,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LocationReportingInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct LowerLayerPresenceStatusChange(pub u8);
impl LowerLayerPresenceStatusChange {
    pub const RELEASE_LOWER_LAYERS: u8 = 0u8;
    pub const RE_ESTABLISH_LOWER_LAYERS: u8 = 1u8;
    pub const SUSPEND_LOWER_LAYERS: u8 = 2u8;
    pub const RESUME_LOWER_LAYERS: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMDT,
    pub report_amount: ReportAmountMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1PeriodicReportingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct M1ReportingTrigger(pub u8);
impl M1ReportingTrigger {
    pub const PERIODIC: u8 = 0u8;
    pub const A2EVENTTRIGGERED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1ThresholdEventA2 {
    pub measurement_threshold: MeasurementThresholdA2,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1ThresholdEventA2IE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M3Configuration {
    pub m3period: M3period,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M3ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct M3period(pub u8);
impl M3period {
    pub const MS100: u8 = 0u8;
    pub const MS1000: u8 = 1u8;
    pub const MS10000: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M4ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct M4ReportAmountMDT(pub u8);
impl M4ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M4period(pub u8);
impl M4period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M5ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct M5ReportAmountMDT(pub u8);
impl M5ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M5period(pub u8);
impl M5period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct M6Configuration {
    pub m6report_interval: M6report_interval,
    #[asn(optional_idx = 0)]
    pub m6delay_threshold: Option<M6delay_threshold>,
    pub m6_links_to_log: Links_to_log,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<M6ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct M6ReportAmountMDT(pub u8);
impl M6ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "11")]
pub struct M6delay_threshold(pub u8);
impl M6delay_threshold {
    pub const MS30: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS50: u8 = 2u8;
    pub const MS60: u8 = 3u8;
    pub const MS70: u8 = 4u8;
    pub const MS80: u8 = 5u8;
    pub const MS90: u8 = 6u8;
    pub const MS100: u8 = 7u8;
    pub const MS150: u8 = 8u8;
    pub const MS300: u8 = 9u8;
    pub const MS500: u8 = 10u8;
    pub const MS750: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct M6report_interval(pub u8);
impl M6report_interval {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M7ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct M7ReportAmountMDT(pub u8);
impl M7ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "60", extensible = true)]
pub struct M7period(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MBMS_Service_Area_Identity(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct MBMS_Service_Area_Identity_List(pub Vec<MBMS_Service_Area_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MBSFN_Subframe_Info {
    pub radioframe_allocation_period: RadioframeAllocationPeriod,
    pub radioframe_allocation_offset: RadioframeAllocationOffset,
    pub subframe_allocation: SubframeAllocation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MBSFN_Subframe_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_Subframe_Infolist(pub Vec<MBSFN_Subframe_Info>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct MDT_Activation(pub u8);
impl MDT_Activation {
    pub const IMMEDIATE_MDT_ONLY: u8 = 0u8;
    pub const IMMEDIATE_MDT_AND_TRACE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MDT_Configuration {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT,
    pub measurements_to_activate: MeasurementsToActivate,
    pub m1reporting_trigger: M1ReportingTrigger,
    #[asn(optional_idx = 0)]
    pub m1thresholdevent_a2: Option<M1ThresholdEventA2>,
    #[asn(optional_idx = 1)]
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<MDT_ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MDT_ConfigurationNR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MDT_Location_Info(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MDTPLMNList(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MIMOPRBusageInformation {
    pub dl_gbr_prb_usage_for_mimo: DL_GBR_PRB_usage_for_MIMO,
    pub ul_gbr_prb_usage_for_mimo: UL_GBR_PRB_usage_for_MIMO,
    pub dl_non_gbr_prb_usage_for_mimo: DL_non_GBR_PRB_usage_for_MIMO,
    pub ul_non_gbr_prb_usage_for_mimo: UL_non_GBR_PRB_usage_for_MIMO,
    pub dl_total_prb_usage_for_mimo: DL_Total_PRB_usage_for_MIMO,
    pub ul_total_prb_usage_for_mimo: UL_Total_PRB_usage_for_MIMO,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MIMOPRBusageInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MME_Code(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MME_Group_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MakeBeforeBreakIndicator(pub u8);
impl MakeBeforeBreakIndicator {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ManagementBasedMDTallowed(pub u8);
impl ManagementBasedMDTallowed {
    pub const ALLOWED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct Masked_IMEISV(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8", extensible = true)]
pub struct MaxCHOpreparations(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16384", extensible = true)]
pub struct MaximumCellListSize(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MeNBCoordinationAssistanceInformation(pub u8);
impl MeNBCoordinationAssistanceInformation {
    pub const COORDINATION_NOT_REQUIRED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeNBResourceCoordinationInformation {
    pub eutra_cell_id: ECGI,
    pub ul_coordination_information: MeNBResourceCoordinationInformationULCoordinationInformation,
    #[asn(optional_idx = 0)]
    pub dl_coordination_information:
        Option<MeNBResourceCoordinationInformationDLCoordinationInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MeNBResourceCoordinationInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MeNBtoSeNBContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MeNBtoSgNBContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4095", extensible = true)]
pub struct Measurement_ID(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4095", extensible = true)]
pub struct Measurement_ID_ENDC(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasurementFailureCause_Item {
    pub measurement_failed_report_characteristics: ReportCharacteristics,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MeasurementFailureCause_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasurementFailureCause_List(pub Vec<MeasurementFailureCause_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasurementInitiationResult_Item {
    pub cell_id: ECGI,
    #[asn(optional_idx = 0)]
    pub measurement_failure_cause_list: Option<MeasurementFailureCause_List>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MeasurementInitiationResult_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct MeasurementInitiationResult_List(pub Vec<MeasurementInitiationResult_List_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MeasurementResultforNRCellsPossiblyAggregated(
    pub Vec<MeasurementResultforNRCellsPossiblyAggregated_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasurementResultforNRCellsPossiblyAggregated_Item {
    pub cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub nr_composite_available_capacity_group: Option<NRCompositeAvailableCapacityGroup>,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<MeasurementResultforNRCellsPossiblyAggregated_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MeasurementThresholdA2 {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasurementsToActivate(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MessageOversizeNotification {
    pub maximum_cell_list_size: MaximumCellListSize,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MessageOversizeNotificationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MobilityChangeAcknowledge {
    pub protocol_i_es: MobilityChangeAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MobilityChangeFailure {
    pub protocol_i_es: MobilityChangeFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MobilityChangeRequest {
    pub protocol_i_es: MobilityChangeRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct MobilityInformation(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MobilityParametersInformation {
    pub handover_trigger_change: MobilityParametersInformationHandoverTriggerChange,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MobilityParametersModificationRange {
    pub handover_trigger_change_lower_limit:
        MobilityParametersModificationRangeHandoverTriggerChangeLowerLimit,
    pub handover_trigger_change_upper_limit:
        MobilityParametersModificationRangeHandoverTriggerChangeUpperLimit,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MultibandInfoList(pub Vec<BandInfo>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NBIoT_RLF_Report_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct NBIoT_UL_DL_AlignmentOffset(pub u8);
impl NBIoT_UL_DL_AlignmentOffset {
    pub const KHZ_7DOT5: u8 = 0u8;
    pub const KHZ0: u8 = 1u8;
    pub const KHZ7DOT5: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NPRACH_CP_Length(pub u8);
impl NPRACH_CP_Length {
    pub const US66DOT7: u8 = 0u8;
    pub const US266DOT7: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct NPRACH_preambleFormat(pub u8);
impl NPRACH_preambleFormat {
    pub const FMT0: u8 = 0u8;
    pub const FMT1: u8 = 1u8;
    pub const FMT2: u8 = 2u8;
    pub const FMT0A: u8 = 3u8;
    pub const FMT1A: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NPRACHConfiguration {
    pub fdd_or_tdd: NPRACHConfigurationFdd_or_tdd,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NPRACHConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct NPRACHConfiguration_FDD {
    pub nprach_cp_length: NPRACH_CP_Length,
    pub anchor_carrier_nprach_config: NPRACHConfiguration_FDDAnchorCarrier_NPRACHConfig,
    #[asn(optional_idx = 0)]
    pub anchor_carrier_edt_nprach_config:
        Option<NPRACHConfiguration_FDDAnchorCarrier_EDT_NPRACHConfig>,
    #[asn(optional_idx = 1)]
    pub anchor_carrier_format2_nprach_config:
        Option<NPRACHConfiguration_FDDAnchorCarrier_Format2_NPRACHConfig>,
    #[asn(optional_idx = 2)]
    pub anchor_carrier_format2_edt_nprach_config:
        Option<NPRACHConfiguration_FDDAnchorCarrier_Format2_EDT_NPRACHConfig>,
    #[asn(optional_idx = 3)]
    pub non_anchor_carrier_nprach_config:
        Option<NPRACHConfiguration_FDDNon_anchorCarrier_NPRACHConfig>,
    #[asn(optional_idx = 4)]
    pub non_anchor_carrier_format2_nprach_config:
        Option<NPRACHConfiguration_FDDNon_anchorCarrier_Format2_NPRACHConfig>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<NPRACHConfiguration_FDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NPRACHConfiguration_TDD {
    pub nprach_preamble_format: NPRACH_preambleFormat,
    pub anchor_carrier_nprach_config_tdd: NPRACHConfiguration_TDDAnchorCarrier_NPRACHConfigTDD,
    #[asn(optional_idx = 0)]
    pub non_anchor_carrier_fequency_configlist: Option<Non_AnchorCarrierFrequencylist>,
    #[asn(optional_idx = 1)]
    pub non_anchor_carrier_nprach_config_tdd:
        Option<NPRACHConfiguration_TDDNon_anchorCarrier_NPRACHConfigTDD>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NPRACHConfiguration_TDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NR_TxBW {
    pub nrscs: NRSCS,
    pub nrnrb: NRNRB,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NR_TxBWIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRCGI {
    pub plmn_identity: PLMN_Identity,
    pub n_rcell_identifier: NRCellIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRCGIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NRCapacityValue {
    pub capacity_value: NRCapacityValueCapacityValue,
    #[asn(optional_idx = 0)]
    pub ssb_area_capacity_value_list: Option<SSBAreaCapacityValue_List>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NRCapacityValueIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRCarrierItem {
    pub carrier_scs: NRSCS,
    pub offset_to_carrier: NRCarrierItemOffsetToCarrier,
    pub carrier_bandwidth: NRCarrierItemCarrierBandwidth,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<NRCarrierItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct NRCarrierList(pub Vec<NRCarrierItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100", extensible = true)]
pub struct NRCellCapacityClassValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct NRCellIdentifier(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRCellPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NRCompositeAvailableCapacity {
    #[asn(optional_idx = 0)]
    pub cell_capacity_class_value: Option<NRCellCapacityClassValue>,
    pub capacity_value: NRCapacityValue,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NRCompositeAvailableCapacityIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRCompositeAvailableCapacityGroup {
    pub composite_available_capacity_dl: NRCompositeAvailableCapacity,
    pub composite_available_capacity_ul: NRCompositeAvailableCapacity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRCompositeAvailableCapacityGroupIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NRFreqInfo {
    pub nrarfcn: NRFreqInfoNRARFCN,
    pub freq_band_list_nr: NRFreqInfoFreqBandListNr,
    #[asn(optional_idx = 0)]
    pub sul_information: Option<SULInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NRFreqInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "28")]
pub struct NRNRB(pub u8);
impl NRNRB {
    pub const NRB11: u8 = 0u8;
    pub const NRB18: u8 = 1u8;
    pub const NRB24: u8 = 2u8;
    pub const NRB25: u8 = 3u8;
    pub const NRB31: u8 = 4u8;
    pub const NRB32: u8 = 5u8;
    pub const NRB38: u8 = 6u8;
    pub const NRB51: u8 = 7u8;
    pub const NRB52: u8 = 8u8;
    pub const NRB65: u8 = 9u8;
    pub const NRB66: u8 = 10u8;
    pub const NRB78: u8 = 11u8;
    pub const NRB79: u8 = 12u8;
    pub const NRB93: u8 = 13u8;
    pub const NRB106: u8 = 14u8;
    pub const NRB107: u8 = 15u8;
    pub const NRB121: u8 = 16u8;
    pub const NRB132: u8 = 17u8;
    pub const NRB133: u8 = 18u8;
    pub const NRB135: u8 = 19u8;
    pub const NRB160: u8 = 20u8;
    pub const NRB162: u8 = 21u8;
    pub const NRB189: u8 = 22u8;
    pub const NRB216: u8 = 23u8;
    pub const NRB217: u8 = 24u8;
    pub const NRB245: u8 = 25u8;
    pub const NRB264: u8 = 26u8;
    pub const NRB270: u8 = 27u8;
    pub const NRB273: u8 = 28u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct NRNeighbour_Information(pub Vec<NRNeighbour_Information_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007")]
pub struct NRPCI(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct NRRAReport(pub Vec<NRRAReportList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRRAReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NRRAReportList_Item {
    pub nrra_report: NRRAReportContainer,
    #[asn(optional_idx = 0)]
    pub ue_assitant_identifier: Option<SgNB_UE_X2AP_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NRRAReportList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRRadioResourceStatus {
    pub ssb_area_radio_resource_status_list: SSBAreaRadioResourceStatus_List,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRRadioResourceStatusIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct NRS_NSSS_PowerOffset(pub u8);
impl NRS_NSSS_PowerOffset {
    pub const MINUS_THREE: u8 = 0u8;
    pub const ZERO: u8 = 1u8;
    pub const THREE: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct NRSCS(pub u8);
impl NRSCS {
    pub const SCS15: u8 = 0u8;
    pub const SCS30: u8 = 1u8;
    pub const SCS60: u8 = 2u8;
    pub const SCS120: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESecurityCapabilities {
    pub n_rencryption_algorithms: NRencryptionAlgorithms,
    pub n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESecurityCapabilitiesIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESidelinkAggregateMaximumBitRate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESidelinkAggregateMaximumBitRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUeReport {
    pub uenr_measurements: RRCContainer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUeReportIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRencryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRintegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictionin5GS(pub u8);
impl NRrestrictionin5GS {
    pub const N_RRESTRICTEDIN5_GS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictioninEPSasSecondaryRAT(pub u8);
impl NRrestrictioninEPSasSecondaryRAT {
    pub const N_RRESTRICTEDIN_EP_SAS_SECONDARY_RAT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct NSSS_NumOccasionDifferentPrecoder(pub u8);
impl NSSS_NumOccasionDifferentPrecoder {
    pub const TWO: u8 = 0u8;
    pub const FOUR: u8 = 1u8;
    pub const EIGHT: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "512"
)]
pub struct Neighbour_Information(pub Vec<Neighbour_Information_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NewDRBIDrequest(pub u8);
impl NewDRBIDrequest {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct NextHopChainingCount(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct Non_AnchorCarrierFrequencylist(pub Vec<Non_AnchorCarrierFrequencylist_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Number_of_Antennaports(pub u8);
impl Number_of_Antennaports {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "20")]
pub struct OffsetOfNbiotChannelNumberToEARFCN(pub u8);
impl OffsetOfNbiotChannelNumberToEARFCN {
    pub const MINUS_TEN: u8 = 0u8;
    pub const MINUS_NINE: u8 = 1u8;
    pub const MINUS_EIGHT: u8 = 2u8;
    pub const MINUS_SEVEN: u8 = 3u8;
    pub const MINUS_SIX: u8 = 4u8;
    pub const MINUS_FIVE: u8 = 5u8;
    pub const MINUS_FOUR: u8 = 6u8;
    pub const MINUS_THREE: u8 = 7u8;
    pub const MINUS_TWO: u8 = 8u8;
    pub const MINUS_ONE: u8 = 9u8;
    pub const MINUS_ZERO_DOT_FIVE: u8 = 10u8;
    pub const ZERO: u8 = 11u8;
    pub const ONE: u8 = 12u8;
    pub const TWO: u8 = 13u8;
    pub const THREE: u8 = 14u8;
    pub const FOUR: u8 = 15u8;
    pub const FIVE: u8 = 16u8;
    pub const SIX: u8 = 17u8;
    pub const SEVEN: u8 = 18u8;
    pub const EIGHT: u8 = 19u8;
    pub const NINE: u8 = 20u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Old_ECGIs(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct Oneframe(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct PA_Values(pub u8);
impl PA_Values {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4DOT77: u8 = 1u8;
    pub const D_B_3: u8 = 2u8;
    pub const D_B_1DOT77: u8 = 3u8;
    pub const D_B0: u8 = 4u8;
    pub const D_B1: u8 = 5u8;
    pub const D_B2: u8 = 6u8;
    pub const D_B3: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PC5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PC5FlowBitRatesIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PC5QoSFlowItem {
    pub pqi: FiveQI,
    #[asn(optional_idx = 0)]
    pub pc5_flow_bit_rates: Option<PC5FlowBitRates>,
    #[asn(optional_idx = 1)]
    pub range: Option<Range>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PC5QoSFlowItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct PC5QoSFlowList(pub Vec<PC5QoSFlowItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PC5QoSParameters {
    pub pc5_qo_s_flow_list: PC5QoSFlowList,
    #[asn(optional_idx = 0)]
    pub pc5_link_aggregated_bit_rates: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PC5QoSParametersIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503", extensible = true)]
pub struct PCI(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct PDCP_SN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32767")]
pub struct PDCP_SNExtended(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct PDCP_SNlength18(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PDCPChangeIndication(pub u8);
impl PDCPChangeIndication {
    pub const S_KG_NB_UPDATE_REQUIRED: u8 = 0u8;
    pub const P_DCP_DATA_RECOVERY_REQUIRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PDCPSnLength(pub u8);
impl PDCPSnLength {
    pub const TWELVE_BITS: u8 = 0u8;
    pub const EIGHTEEN_BITS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PLMN_Identity(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PLMNAreaBasedQMC {
    pub plmn_listfor_qmc: PLMNListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PLMNAreaBasedQMCIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PLMNListforQMC(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PRACH_Configuration {
    pub root_sequence_index: PRACH_ConfigurationRootSequenceIndex,
    pub zero_correlation_index: PRACH_ConfigurationZeroCorrelationIndex,
    pub high_speed_flag: PRACH_ConfigurationHighSpeedFlag,
    pub prach_freq_offset: PRACH_ConfigurationPrach_FreqOffset,
    #[asn(optional_idx = 0)]
    pub prach_config_index: Option<PRACH_ConfigurationPrach_ConfigIndex>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PRACH_ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct PSCell_UE_HistoryInformation(pub Vec<LastVisitedPSCell_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PSCellChangeHistory(pub u8);
impl PSCellChangeHistory {
    pub const REPORTING_FULL_HISTORY: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PSCellHistoryInformationRetrieve(pub u8);
impl PSCellHistoryInformationRetrieve {
    pub const QUERY: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PSCellListContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct Packet_LossRate(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PartialListIndicator(pub u8);
impl PartialListIndicator {
    pub const PARTIAL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PartialSuccessIndicator(pub u8);
impl PartialSuccessIndicator {
    pub const PARTIAL_SUCCESS_ALLOWED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PedestrianUE(pub u8);
impl PedestrianUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct Port_Number(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionCapability(pub u8);
impl Pre_emptionCapability {
    pub const SHALL_NOT_TRIGGER_PRE_EMPTION: u8 = 0u8;
    pub const MAY_TRIGGER_PRE_EMPTION: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionVulnerability(pub u8);
impl Pre_emptionVulnerability {
    pub const NOT_PRE_EMPTABLE: u8 = 0u8;
    pub const PRE_EMPTABLE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Presence(pub u8);
impl Presence {
    pub const OPTIONAL: u8 = 0u8;
    pub const CONDITIONAL: u8 = 1u8;
    pub const MANDATORY: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PriorityLevel(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PrivacyIndicator(pub u8);
impl PrivacyIndicator {
    pub const IMMEDIATE_MDT: u8 = 0u8;
    pub const LOGGED_MDT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PrivateIE_ID {
    #[asn(key = 0, extended = false)]
    Local(PrivateIE_ID_local),
    #[asn(key = 1, extended = false)]
    Global(PrivateIE_ID_global),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PrivateMessage {
    pub private_i_es: PrivateMessagePrivateIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ProSeAuthorized {
    #[asn(optional_idx = 0)]
    pub pro_se_direct_discovery: Option<ProSeDirectDiscovery>,
    #[asn(optional_idx = 1)]
    pub pro_se_direct_communication: Option<ProSeDirectCommunication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ProSeAuthorizedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectCommunication(pub u8);
impl ProSeDirectCommunication {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectDiscovery(pub u8);
impl ProSeDirectDiscovery {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeUEtoNetworkRelaying(pub u8);
impl ProSeUEtoNetworkRelaying {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ProcedureCode(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ProcedureStageChoice {
    #[asn(key = 0, extended = false)]
    First_dl_count(FirstDLCount),
    #[asn(key = 1, extended = false)]
    Dl_discarding(DLDiscarding),
    #[asn(key = 2, extended = false)]
    Choice_extension(ProcedureStageChoice_choice_extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ProtectedEUTRAResourceIndication {
    pub activation_sfn: ProtectedEUTRAResourceIndicationActivationSFN,
    pub protected_resource_list: ProtectedResourceList,
    #[asn(optional_idx = 0)]
    pub mbsfn_control_region_length:
        Option<ProtectedEUTRAResourceIndicationMBSFNControlRegionLength>,
    #[asn(optional_idx = 1)]
    pub pdcch_region_length: Option<ProtectedEUTRAResourceIndicationPDCCHRegionLength>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ProtectedEUTRAResourceIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ProtectedFootprintTimePattern {
    pub protected_footprint_time_periodicity:
        ProtectedFootprintTimePatternProtectedFootprintTimePeriodicity,
    pub protected_footprint_start_time: ProtectedFootprintTimePatternProtectedFootprintStartTime,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ProtectedFootprintTimePatternIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ProtectedResourceList(pub Vec<ProtectedResourceList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ProtectedResourceList_Item {
    pub resource_type: ResourceType,
    pub intra_prb_protected_resource_footprint:
        ProtectedResourceList_ItemIntraPRBProtectedResourceFootprint,
    pub protected_footprint_frequency_pattern:
        ProtectedResourceList_ItemProtectedFootprintFrequencyPattern,
    pub protected_footprint_time_pattern: ProtectedFootprintTimePattern,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ProtectedResourceList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolIE_ID(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct QCI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct QoS_Mapping_Information {
    #[asn(optional_idx = 0)]
    pub dscp: Option<QoS_Mapping_InformationDscp>,
    #[asn(optional_idx = 1)]
    pub flow_label: Option<QoS_Mapping_InformationFlow_label>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<QoS_Mapping_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct RAN_UE_NGAP_ID(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RAT_Restrictions(pub Vec<RAT_RestrictionsItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RAT_RestrictionsItem {
    pub plmn_identity: PLMN_Identity,
    pub rat_restriction_information: RAT_RestrictionsItemRAT_RestrictionInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RAT_RestrictionsItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RLC_Status {
    pub reestablishment_indication: Reestablishment_Indication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RLC_StatusIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct RLCMode(pub u8);
impl RLCMode {
    pub const RLC_AM: u8 = 0u8;
    pub const RLC_UM_BIDIRECTIONAL: u8 = 1u8;
    pub const RLC_UM_UNIDIRECTIONAL_UL: u8 = 2u8;
    pub const RLC_UM_UNIDIRECTIONAL_DL: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RLFIndication {
    pub protocol_i_es: RLFIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RNL_Header {
    pub source_global_enb_id: GlobalENB_ID,
    #[asn(optional_idx = 0)]
    pub target_global_enb_id: Option<GlobalENB_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RNL_HeaderIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct RNTP_Threshold(pub u8);
impl RNTP_Threshold {
    pub const MINUS_INFINITY: u8 = 0u8;
    pub const MINUS_ELEVEN: u8 = 1u8;
    pub const MINUS_TEN: u8 = 2u8;
    pub const MINUS_NINE: u8 = 3u8;
    pub const MINUS_EIGHT: u8 = 4u8;
    pub const MINUS_SEVEN: u8 = 5u8;
    pub const MINUS_SIX: u8 = 6u8;
    pub const MINUS_FIVE: u8 = 7u8;
    pub const MINUS_FOUR: u8 = 8u8;
    pub const MINUS_THREE: u8 = 9u8;
    pub const MINUS_TWO: u8 = 10u8;
    pub const MINUS_ONE: u8 = 11u8;
    pub const ZERO: u8 = 12u8;
    pub const ONE: u8 = 13u8;
    pub const TWO: u8 = 14u8;
    pub const THREE: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RRC_Config_Ind(pub u8);
impl RRC_Config_Ind {
    pub const FULL_CONFIG: u8 = 0u8;
    pub const DELTA_CONFIG: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRC_Context(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct RRCConnReestabIndicator(pub u8);
impl RRCConnReestabIndicator {
    pub const RECONFIGURATION_FAILURE: u8 = 0u8;
    pub const HANDOVER_FAILURE: u8 = 1u8;
    pub const OTHER_FAILURE: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RRCConnSetupIndicator(pub u8);
impl RRCConnSetupIndicator {
    pub const RRC_CONN_SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RRCTransfer {
    pub protocol_i_es: RRCTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct RSRPMRList(pub Vec<RSRPMRList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "9")]
pub struct RSRPMeasurementResult(pub Vec<RSRPMeasurementResult_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct RaReportIndicationList(pub Vec<RaReportIndicationList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RaReportIndicationList_Item {
    pub me_nb_ue_x2ap_id: UE_X2AP_ID,
    #[asn(optional_idx = 0)]
    pub me_nb_ue_x2ap_id_extension: Option<UE_X2AP_ID_Extension>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RaReportIndicationList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RachIndication {
    pub protocol_i_es: RachIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RadioResourceStatus {
    pub dl_gbr_prb_usage: DL_GBR_PRB_usage,
    pub ul_gbr_prb_usage: UL_GBR_PRB_usage,
    pub dl_non_gbr_prb_usage: DL_non_GBR_PRB_usage,
    pub ul_non_gbr_prb_usage: UL_non_GBR_PRB_usage,
    pub dl_total_prb_usage: DL_Total_PRB_usage,
    pub ul_total_prb_usage: UL_Total_PRB_usage,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RadioResourceStatusIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7", extensible = true)]
pub struct RadioframeAllocationOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct RadioframeAllocationPeriod(pub u8);
impl RadioframeAllocationPeriod {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N16: u8 = 4u8;
    pub const N32: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct Range(pub u8);
impl Range {
    pub const M50: u8 = 0u8;
    pub const M80: u8 = 1u8;
    pub const M180: u8 = 2u8;
    pub const M200: u8 = 3u8;
    pub const M350: u8 = 4u8;
    pub const M400: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const M700: u8 = 7u8;
    pub const M1000: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ReceiveStatusOfULPDCPSDUsExtended(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "131072"
)]
pub struct ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "4096",
    sz_ub = "4096"
)]
pub struct ReceiveStatusofULPDCPSDUs(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Reestablishment_Indication(pub u8);
impl Reestablishment_Indication {
    pub const REESTABLISHED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Registration_Request(pub u8);
impl Registration_Request {
    pub const START: u8 = 0u8;
    pub const STOP: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Registration_Request_ENDC(pub u8);
impl Registration_Request_ENDC {
    pub const START: u8 = 0u8;
    pub const STOP: u8 = 1u8;
    pub const ADD: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RelativeNarrowbandTxPower {
    pub rntp_per_prb: RelativeNarrowbandTxPowerRNTP_PerPRB,
    pub rntp_threshold: RNTP_Threshold,
    pub number_of_cell_specific_antenna_ports:
        RelativeNarrowbandTxPowerNumberOfCellSpecificAntennaPorts,
    pub p_b: RelativeNarrowbandTxPowerP_B,
    pub pdcch_interference_impact: RelativeNarrowbandTxPowerPDCCH_InterferenceImpact,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RelativeNarrowbandTxPowerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReleaseFastMCGRecoveryViaSRB3(pub u8);
impl ReleaseFastMCGRecoveryViaSRB3 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ReplacingCellsList(pub Vec<ReplacingCellsList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ReplacingCellsList_Item {
    pub ecgi: ECGI,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportAmountMDT(pub u8);
impl ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const RINFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReportArea(pub u8);
impl ReportArea {
    pub const ECGI: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct ReportCharacteristics(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct ReportCharacteristics_ENDC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "12")]
pub struct ReportIntervalMDT(pub u8);
impl ReportIntervalMDT {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ReportingPeriodicity(pub u8);
impl ReportingPeriodicity {
    pub const ONE_THOUSAND_MS: u8 = 0u8;
    pub const TWO_THOUSAND_MS: u8 = 1u8;
    pub const FIVE_THOUSAND_MS: u8 = 2u8;
    pub const TEN_THOUSAND_MS: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct ReportingPeriodicity_ENDC(pub u8);
impl ReportingPeriodicity_ENDC {
    pub const MS500: u8 = 0u8;
    pub const MS1000: u8 = 1u8;
    pub const MS2000: u8 = 2u8;
    pub const MS5000: u8 = 3u8;
    pub const MS10000: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct ReportingPeriodicityCSIR(pub u8);
impl ReportingPeriodicityCSIR {
    pub const MS5: u8 = 0u8;
    pub const MS10: u8 = 1u8;
    pub const MS20: u8 = 2u8;
    pub const MS40: u8 = 3u8;
    pub const MS80: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ReportingPeriodicityRSRPMR(pub u8);
impl ReportingPeriodicityRSRPMR {
    pub const ONE_HUNDRED_20_MS: u8 = 0u8;
    pub const TWO_HUNDRED_40_MS: u8 = 1u8;
    pub const FOUR_HUNDRED_80_MS: u8 = 2u8;
    pub const SIX_HUNDRED_40_MS: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RequestedFastMCGRecoveryViaSRB3(pub u8);
impl RequestedFastMCGRecoveryViaSRB3 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RequestedFastMCGRecoveryViaSRB3Release(pub u8);
impl RequestedFastMCGRecoveryViaSRB3Release {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ReservedSubframePattern {
    pub subframe_type: SubframeType,
    pub reserved_subframe_pattern: ReservedSubframePatternReservedSubframePattern,
    pub mbsfn_control_region_length: ReservedSubframePatternMBSFNControlRegionLength,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ReservedSubframePatternIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResetRequest {
    pub protocol_i_es: ResetRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResetResponse {
    pub protocol_i_es: ResetResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResourceStatusFailure {
    pub protocol_i_es: ResourceStatusFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResourceStatusRequest {
    pub protocol_i_es: ResourceStatusRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResourceStatusResponse {
    pub protocol_i_es: ResourceStatusResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResourceStatusUpdate {
    pub protocol_i_es: ResourceStatusUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ResourceType(pub u8);
impl ResourceType {
    pub const DOWNLINKNON_CRS: u8 = 0u8;
    pub const C_RS: u8 = 1u8;
    pub const UPLINK: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum RespondingNodeType_EndcConfigUpdate {
    #[asn(key = 0, extended = false)]
    Respond_eNB(RespondingNodeType_EndcConfigUpdate_respond_eNB),
    #[asn(key = 1, extended = false)]
    Respond_en_gNB(RespondingNodeType_EndcConfigUpdate_respond_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum RespondingNodeType_EndcX2Removal {
    #[asn(key = 0, extended = false)]
    Respond_eNB(RespondingNodeType_EndcX2Removal_respond_eNB),
    #[asn(key = 1, extended = false)]
    Respond_en_gNB(RespondingNodeType_EndcX2Removal_respond_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum RespondingNodeType_EndcX2Setup {
    #[asn(key = 0, extended = false)]
    Respond_eNB(RespondingNodeType_EndcX2Setup_respond_eNB),
    #[asn(key = 1, extended = false)]
    Respond_en_gNB(RespondingNodeType_EndcX2Setup_respond_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum RespondingNodeType_EutranrCellResourceCoordination {
    #[asn(key = 0, extended = false)]
    Respond_eNB(RespondingNodeType_EutranrCellResourceCoordination_respond_eNB),
    #[asn(key = 1, extended = false)]
    Respond_en_gNB(RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ResponseInformationSeNBReconfComp {
    #[asn(key = 0, extended = false)]
    Success(ResponseInformationSeNBReconfComp_SuccessItem),
    #[asn(key = 1, extended = false)]
    Reject_by_MeNB(ResponseInformationSeNBReconfComp_RejectByMeNBItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ResponseInformationSeNBReconfComp_RejectByMeNBItem {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub me_n_bto_se_nb_container: Option<MeNBtoSeNBContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ResponseInformationSeNBReconfComp_RejectByMeNBItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ResponseInformationSeNBReconfComp_SuccessItem {
    #[asn(optional_idx = 0)]
    pub me_n_bto_se_nb_container: Option<MeNBtoSeNBContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ResponseInformationSeNBReconfComp_SuccessItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ResponseInformationSgNBReconfComp {
    #[asn(key = 0, extended = false)]
    Success_SgNBReconfComp(ResponseInformationSgNBReconfComp_SuccessItem),
    #[asn(key = 1, extended = false)]
    Reject_by_MeNB_SgNBReconfComp(ResponseInformationSgNBReconfComp_RejectByMeNBItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ResponseInformationSgNBReconfComp_RejectByMeNBItem {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ResponseInformationSgNBReconfComp_RejectByMeNBItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ResponseInformationSgNBReconfComp_SuccessItem {
    #[asn(optional_idx = 0)]
    pub me_n_bto_sg_nb_container: Option<MeNBtoSgNBContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ResponseInformationSgNBReconfComp_SuccessItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ResumeID {
    #[asn(key = 0, extended = false)]
    Non_truncated(ResumeID_non_truncated),
    #[asn(key = 1, extended = false)]
    Truncated(ResumeID_truncated),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEContextFailure {
    pub protocol_i_es: RetrieveUEContextFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEContextRequest {
    pub protocol_i_es: RetrieveUEContextRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEContextResponse {
    pub protocol_i_es: RetrieveUEContextResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct S1TNLLoadIndicator {
    pub dls1tnl_load_indicator: LoadIndicator,
    pub uls1tnl_load_indicator: LoadIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<S1TNLLoadIndicatorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SCG_UE_HistoryInformation(pub Vec<LastVisitedPSCell_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SCGActivationRequest(pub u8);
impl SCGActivationRequest {
    pub const ACTIVATE_SCG: u8 = 0u8;
    pub const DEACTIVATE_SCG: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SCGActivationStatus(pub u8);
impl SCGActivationStatus {
    pub const SCG_ACTIVATED: u8 = 0u8;
    pub const SCG_DEACTIVATED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct SCGChangeIndication(pub u8);
impl SCGChangeIndication {
    pub const P_DCP_COUNT_WRAP_AROUND: u8 = 0u8;
    pub const P_S_CELL_CHANGE: u8 = 1u8;
    pub const OTHER: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SCGConfigurationQuery(pub u8);
impl SCGConfigurationQuery {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SCGreconfigNotification(pub u8);
impl SCGreconfigNotification {
    pub const EXECUTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SFN_Offset {
    pub sfn_time_offset: SFN_OffsetSFN_Time_Offset,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SFN_OffsetIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct SGNB_Addition_Trigger_Ind(pub u8);
impl SGNB_Addition_Trigger_Ind {
    pub const SN_CHANGE: u8 = 0u8;
    pub const INTER_E_NB_HO: u8 = 1u8;
    pub const INTRA_E_NB_HO: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SIPTOBearerDeactivationIndication(pub u8);
impl SIPTOBearerDeactivationIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SNStatusTransfer {
    pub protocol_i_es: SNStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SNtriggered(pub u8);
impl SNtriggered {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SRBType(pub u8);
impl SRBType {
    pub const SRB1: u8 = 0u8;
    pub const SRB2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SRVCCOperationPossible(pub u8);
impl SRVCCOperationPossible {
    pub const POSSIBLE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SSB_PositionsInBurst {
    #[asn(key = 0, extended = false)]
    ShortBitmap(SSB_PositionsInBurst_shortBitmap),
    #[asn(key = 1, extended = false)]
    MediumBitmap(SSB_PositionsInBurst_mediumBitmap),
    #[asn(key = 2, extended = false)]
    LongBitmap(SSB_PositionsInBurst_longBitmap),
    #[asn(key = 3, extended = false)]
    Choice_extension(SSB_PositionsInBurst_choice_extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SSBAreaCapacityValue_Item {
    pub ssb_index: SSBIndex,
    pub ssb_area_capacity_value: SSBAreaCapacityValue_ItemSsbAreaCapacityValue,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SSBAreaCapacityValue_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SSBAreaCapacityValue_List(pub Vec<SSBAreaCapacityValue_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SSBAreaRadioResourceStatus_Item {
    pub ssb_index: SSBIndex,
    pub ssb_area_dlgbrprb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaDLGBRPRBUsage,
    pub ssb_area_ulgbrprb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaULGBRPRBUsage,
    pub ssb_area_dl_non_gbrprb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaDLNonGBRPRBUsage,
    pub ssb_area_ul_non_gbrprb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaULNonGBRPRBUsage,
    pub ssb_area_dl_total_prb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaDLTotalPRBUsage,
    pub ssb_area_ul_total_prb_usage: SSBAreaRadioResourceStatus_ItemSsbAreaULTotalPRBUsage,
    #[asn(optional_idx = 0)]
    pub ssb_area_dl_scheduling_pdcchcce_usage:
        Option<SSBAreaRadioResourceStatus_ItemSsbAreaDLSchedulingPDCCHCCEUsage>,
    #[asn(optional_idx = 1)]
    pub ssb_area_ul_scheduling_pdcchcce_usage:
        Option<SSBAreaRadioResourceStatus_ItemSsbAreaULSchedulingPDCCHCCEUsage>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<SSBAreaRadioResourceStatus_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SSBAreaRadioResourceStatus_List(pub Vec<SSBAreaRadioResourceStatus_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SSBIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SSBToReport_Item {
    pub ssb_index: SSBIndex,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SSBToReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SSBToReport_List(pub Vec<SSBToReport_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SULInformation {
    pub sul_arfcn: SULInformationSUL_ARFCN,
    pub sul_tx_bw: NR_TxBW,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SULInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ScheduledCommunicationTime {
    #[asn(optional_idx = 0)]
    pub dayof_week: Option<ScheduledCommunicationTimeDayofWeek>,
    #[asn(optional_idx = 1)]
    pub timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart>,
    #[asn(optional_idx = 2)]
    pub timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBAdditionRequest {
    pub protocol_i_es: SeNBAdditionRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBAdditionRequestAcknowledge {
    pub protocol_i_es: SeNBAdditionRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBAdditionRequestReject {
    pub protocol_i_es: SeNBAdditionRequestRejectProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBCounterCheckRequest {
    pub protocol_i_es: SeNBCounterCheckRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationConfirm {
    pub protocol_i_es: SeNBModificationConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationRefuse {
    pub protocol_i_es: SeNBModificationRefuseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationRequest {
    pub protocol_i_es: SeNBModificationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationRequestAcknowledge {
    pub protocol_i_es: SeNBModificationRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationRequestReject {
    pub protocol_i_es: SeNBModificationRequestRejectProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBModificationRequired {
    pub protocol_i_es: SeNBModificationRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBReconfigurationComplete {
    pub protocol_i_es: SeNBReconfigurationCompleteProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBReleaseConfirm {
    pub protocol_i_es: SeNBReleaseConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBReleaseRequest {
    pub protocol_i_es: SeNBReleaseRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SeNBReleaseRequired {
    pub protocol_i_es: SeNBReleaseRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SeNBSecurityKey(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SeNBtoMeNBContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecondaryRATDataUsageReport {
    pub protocol_i_es: SecondaryRATDataUsageReportProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecondaryRATUsageReport_Item {
    pub e_rab_id: E_RAB_ID,
    pub secondary_rat_type: SecondaryRATUsageReport_ItemSecondaryRATType,
    pub e_rab_usage_report_list: E_RABUsageReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecondaryRATUsageReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SecondaryRATUsageReportList(pub Vec<SecondaryRATUsageReportList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityIndication {
    pub integrity_protection_indication: IntegrityProtectionIndication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityResult {
    pub integrity_protection_result: IntegrityProtectionResult,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityResultIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorMeasConfig(pub u8);
impl SensorMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SensorMeasConfigNameItem {
    pub sensor_name_config: SensorNameConfig,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SensorMeasConfigNameItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SensorMeasConfigNameList(pub Vec<SensorMeasConfigNameItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SensorMeasurementConfiguration {
    pub sensor_meas_config: SensorMeasConfig,
    #[asn(optional_idx = 0)]
    pub sensor_meas_config_name_list: Option<SensorMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SensorMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SensorNameConfig {
    #[asn(key = 0, extended = false)]
    UncompensatedBarometricConfig(SensorNameConfig_uncompensatedBarometricConfig),
    #[asn(key = 1, extended = false)]
    Choice_extension(SensorNameConfig_choice_extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedCell_Information {
    pub pci: PCI,
    pub cell_id: ECGI,
    pub tac: TAC,
    pub broadcast_plm_ns: BroadcastPLMNs_Item,
    pub eutra_mode_info: EUTRA_Mode_Info,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ServedCellSpecificInfoReq_NR(pub Vec<ServedCellSpecificInfoReq_NR_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedCellSpecificInfoReq_NR_Item {
    pub nrcgi: NRCGI,
    #[asn(optional_idx = 0)]
    pub additional_mtc_list_request_indicator:
        Option<ServedCellSpecificInfoReq_NR_ItemAdditionalMTCListRequestIndicator>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedCellSpecificInfoReq_NR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedCells(pub Vec<ServedCells_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedCellsToActivate(pub Vec<ServedCellsToActivate_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedCellsToActivate_Item {
    pub ecgi: ECGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedCellsToActivate_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedCellsToModify(pub Vec<ServedCellsToModify_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedCellsToModify_Item {
    pub old_ecgi: ECGI,
    pub served_cell_info: ServedCell_Information,
    #[asn(optional_idx = 0)]
    pub neighbour_info: Option<Neighbour_Information>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedCellsToModify_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedEUTRAcellsENDCX2ManagementList(
    pub Vec<ServedEUTRAcellsENDCX2ManagementList_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedEUTRAcellsToDeleteListENDCConfUpd(pub Vec<ECGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedEUTRAcellsToModifyListENDCConfUpd(
    pub Vec<ServedEUTRAcellsToModifyListENDCConfUpd_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ServedNRCell_Information {
    pub nrp_ci: NRPCI,
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub five_gs_tac: Option<FiveGS_TAC>,
    #[asn(optional_idx = 1)]
    pub configured_tac: Option<TAC>,
    pub broadcast_plm_ns: BroadcastPLMNs_Item,
    pub nr_mode_info: ServedNRCell_InformationNrModeInfo,
    pub measurement_timing_configuration: ServedNRCell_InformationMeasurementTimingConfiguration,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ServedNRCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ServedNRCellsToActivate(pub Vec<ServedNRCellsToActivate_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedNRCellsToActivate_Item {
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedNRCellsToActivate_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ServedNRCellsToModify_Item {
    pub old_nrcgi: NRCGI,
    pub served_nr_cell_information: ServedNRCell_Information,
    #[asn(optional_idx = 0)]
    pub nr_neighbour_information: Option<NRNeighbour_Information>,
    #[asn(optional_idx = 1)]
    pub nr_deactivation_indication: Option<DeactivationIndication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ServedNRCellsToModify_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ServedNRcellsENDCX2ManagementList(pub Vec<ServedNRcellsENDCX2ManagementList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ServedNRcellsToDeleteENDCConfUpdList(pub Vec<NRCGI>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ServedNRcellsToModifyENDCConfUpdList(pub Vec<ServedNRCellsToModify_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ServiceType(pub u8);
impl ServiceType {
    pub const Q_MC_FOR_STREAMING_SERVICE: u8 = 0u8;
    pub const Q_MC_FOR_MTSI_SERVICE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct SgNB_UE_X2AP_ID(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBActivityNotification {
    pub protocol_i_es: SgNBActivityNotificationProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBAdditionRequest {
    pub protocol_i_es: SgNBAdditionRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBAdditionRequestAcknowledge {
    pub protocol_i_es: SgNBAdditionRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBAdditionRequestReject {
    pub protocol_i_es: SgNBAdditionRequestRejectProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBChangeConfirm {
    pub protocol_i_es: SgNBChangeConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBChangeRefuse {
    pub protocol_i_es: SgNBChangeRefuseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBChangeRequired {
    pub protocol_i_es: SgNBChangeRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SgNBCoordinationAssistanceInformation(pub u8);
impl SgNBCoordinationAssistanceInformation {
    pub const COORDINATION_NOT_REQUIRED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBCounterCheckRequest {
    pub protocol_i_es: SgNBCounterCheckRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationConfirm {
    pub protocol_i_es: SgNBModificationConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationRefuse {
    pub protocol_i_es: SgNBModificationRefuseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationRequest {
    pub protocol_i_es: SgNBModificationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationRequestAcknowledge {
    pub protocol_i_es: SgNBModificationRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationRequestReject {
    pub protocol_i_es: SgNBModificationRequestRejectProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBModificationRequired {
    pub protocol_i_es: SgNBModificationRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReconfigurationComplete {
    pub protocol_i_es: SgNBReconfigurationCompleteProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReleaseConfirm {
    pub protocol_i_es: SgNBReleaseConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReleaseRequest {
    pub protocol_i_es: SgNBReleaseRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReleaseRequestAcknowledge {
    pub protocol_i_es: SgNBReleaseRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReleaseRequestReject {
    pub protocol_i_es: SgNBReleaseRequestRejectProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SgNBReleaseRequired {
    pub protocol_i_es: SgNBReleaseRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SgNBResourceCoordinationInformation {
    pub nr_cgi: NRCGI,
    pub ul_coordination_information: SgNBResourceCoordinationInformationULCoordinationInformation,
    #[asn(optional_idx = 0)]
    pub dl_coordination_information:
        Option<SgNBResourceCoordinationInformationDLCoordinationInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SgNBResourceCoordinationInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SgNBSecurityKey(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SgNBtoMeNBContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum SharedResourceType {
    #[asn(key = 0, extended = false)]
    ULOnlySharing(ULOnlySharing),
    #[asn(key = 1, extended = false)]
    ULandDLSharing(ULandDLSharing),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct ShortMAC_I(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct SourceDLForwardingIPAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SourceOfUEActivityBehaviourInformation(pub u8);
impl SourceOfUEActivityBehaviourInformation {
    pub const SUBSCRIPTION_INFORMATION: u8 = 0u8;
    pub const STATISTICS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SpecialSubframe_Info {
    pub special_subframe_patterns: SpecialSubframePatterns,
    pub cyclic_prefix_dl: CyclicPrefixDL,
    pub cyclic_prefix_ul: CyclicPrefixUL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SpecialSubframe_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct SpecialSubframePatterns(pub u8);
impl SpecialSubframePatterns {
    pub const SSP0: u8 = 0u8;
    pub const SSP1: u8 = 1u8;
    pub const SSP2: u8 = 2u8;
    pub const SSP3: u8 = 3u8;
    pub const SSP4: u8 = 4u8;
    pub const SSP5: u8 = 5u8;
    pub const SSP6: u8 = 6u8;
    pub const SSP7: u8 = 7u8;
    pub const SSP8: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct SpectrumSharingGroupID(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SplitSRB {
    #[asn(optional_idx = 0)]
    pub rrc_container: Option<RRCContainer>,
    pub srb_type: SRBType,
    #[asn(optional_idx = 1)]
    pub delivery_status: Option<DeliveryStatus>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<SplitSRBIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct SplitSRBs(pub u8);
impl SplitSRBs {
    pub const SRB1: u8 = 0u8;
    pub const SRB2: u8 = 1u8;
    pub const SRB1AND2: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SubbandCQI {
    pub subband_cqi_codeword0: SubbandCQICodeword0,
    #[asn(optional_idx = 0)]
    pub subband_cqi_codeword1: Option<SubbandCQICodeword1>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SubbandCQIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum SubbandCQICodeword0 {
    #[asn(key = 0, extended = false)]
    Four_bitCQI(SubbandCQICodeword0_four_bitCQI),
    #[asn(key = 1, extended = false)]
    Two_bitSubbandDifferentialCQI(SubbandCQICodeword0_two_bitSubbandDifferentialCQI),
    #[asn(key = 2, extended = false)]
    Two_bitDifferentialCQI(SubbandCQICodeword0_two_bitDifferentialCQI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum SubbandCQICodeword1 {
    #[asn(key = 0, extended = false)]
    Four_bitCQI(SubbandCQICodeword1_four_bitCQI),
    #[asn(key = 1, extended = false)]
    Three_bitSpatialDifferentialCQI(SubbandCQICodeword1_three_bitSpatialDifferentialCQI),
    #[asn(key = 2, extended = false)]
    Two_bitSubbandDifferentialCQI(SubbandCQICodeword1_two_bitSubbandDifferentialCQI),
    #[asn(key = 3, extended = false)]
    Two_bitDifferentialCQI(SubbandCQICodeword1_two_bitDifferentialCQI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SubbandCQIItem {
    pub subband_cqi: SubbandCQI,
    pub subband_index: SubbandCQIItemSubbandIndex,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SubbandCQIItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "14")]
pub struct SubbandCQIList(pub Vec<SubbandCQIItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct SubbandSize(pub u8);
impl SubbandSize {
    pub const SIZE2: u8 = 0u8;
    pub const SIZE3: u8 = 1u8;
    pub const SIZE4: u8 = 2u8;
    pub const SIZE6: u8 = 3u8;
    pub const SIZE8: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum SubframeAllocation {
    #[asn(key = 0, extended = false)]
    Oneframe(Oneframe),
    #[asn(key = 1, extended = false)]
    Fourframes(Fourframes),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct SubframeAssignment(pub u8);
impl SubframeAssignment {
    pub const SA0: u8 = 0u8;
    pub const SA1: u8 = 1u8;
    pub const SA2: u8 = 2u8;
    pub const SA3: u8 = 3u8;
    pub const SA4: u8 = 4u8;
    pub const SA5: u8 = 5u8;
    pub const SA6: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SubframeType(pub u8);
impl SubframeType {
    pub const MBSFN: u8 = 0u8;
    pub const NONMBSFN: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct SubscriberProfileIDforRFP(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct Subscription_Based_UE_DifferentiationInfo {
    #[asn(optional_idx = 0)]
    pub periodic_communication_indicator:
        Option<Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator>,
    #[asn(optional_idx = 1)]
    pub periodic_time: Option<Subscription_Based_UE_DifferentiationInfoPeriodicTime>,
    #[asn(optional_idx = 2)]
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    #[asn(optional_idx = 3)]
    pub stationary_indication:
        Option<Subscription_Based_UE_DifferentiationInfoStationaryIndication>,
    #[asn(optional_idx = 4)]
    pub traffic_profile: Option<Subscription_Based_UE_DifferentiationInfoTrafficProfile>,
    #[asn(optional_idx = 5)]
    pub battery_indication: Option<Subscription_Based_UE_DifferentiationInfoBatteryIndication>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<Subscription_Based_UE_DifferentiationInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: SuccessfulOutcomeValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SupportedSULFreqBandItem {
    pub freq_band_indicator_nr: SupportedSULFreqBandItemFreqBandIndicatorNr,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SupportedSULFreqBandItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedMDT {
    pub ta_listfor_mdt: TAListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedMDTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedQMC {
    pub ta_listfor_qmc: TAListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedQMCIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct TAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI_Item {
    pub tac: TAC,
    pub plmn_identity: PLMN_Identity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAI_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedMDT {
    pub tai_listfor_mdt: TAIListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedMDTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedQMC {
    pub tai_listfor_qmc: TAIListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedQMCIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforMDT(pub Vec<TAI_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforQMC(pub Vec<TAI_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforMDT(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforQMC(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TDD_Info {
    pub earfcn: EARFCN,
    pub transmission_bandwidth: Transmission_Bandwidth,
    pub subframe_assignment: SubframeAssignment,
    pub special_subframe_info: SpecialSubframe_Info,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TDD_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TDD_InfoNeighbourServedNRCell_Information {
    pub nr_freq_info: NRFreqInfo,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TDD_InfoNeighbourServedNRCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TDD_InfoServedNRCell_Information {
    pub nr_freq_info: NRFreqInfo,
    pub nr_tx_bw: NR_TxBW,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TDD_InfoServedNRCell_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TDDULDLConfigurationCommonNR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct TNLA_Failed_To_Setup_Item {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLA_Failed_To_Setup_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLA_Failed_To_Setup_List(pub Vec<TNLA_Failed_To_Setup_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TNLA_Setup_Item {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLA_Setup_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLA_Setup_List(pub Vec<TNLA_Setup_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct TNLA_To_Add_Item {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    pub tnl_association_usage: TNLAssociationUsage,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLA_To_Add_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLA_To_Add_List(pub Vec<TNLA_To_Add_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct TNLA_To_Remove_Item {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLA_To_Remove_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLA_To_Remove_List(pub Vec<TNLA_To_Remove_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct TNLA_To_Update_Item {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_usage: Option<TNLAssociationUsage>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TNLA_To_Update_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLA_To_Update_List(pub Vec<TNLA_To_Update_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct TNLAssociationUsage(pub u8);
impl TNLAssociationUsage {
    pub const UE: u8 = 0u8;
    pub const NON_UE: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TNLCapacityIndicator {
    pub dl_tnl_maximum_offered_capacity: TNLCapacityIndicatorDlTNLMaximumOfferedCapacity,
    pub dl_tnl_available_capacity: TNLCapacityIndicatorDlTNLAvailableCapacity,
    pub ul_tnl_maximum_offered_capacity: TNLCapacityIndicatorUlTNLMaximumOfferedCapacity,
    pub ul_tnl_available_capacity: TNLCapacityIndicatorUlTNLAvailableCapacity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLCapacityIndicatorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct TNLConfigurationInfo {
    #[asn(optional_idx = 0)]
    pub transport_up_layer_addresses_info_to_add_list:
        Option<Transport_UP_Layer_Addresses_Info_To_Add_List>,
    #[asn(optional_idx = 1)]
    pub transport_up_layer_addresses_info_to_remove_list:
        Option<Transport_UP_Layer_Addresses_Info_To_Remove_List>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<TNLConfigurationInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetCellInNGRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetCellInUTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargeteNBtoSource_eNBTransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "97")]
pub struct Threshold_RSRP(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "34")]
pub struct Threshold_RSRQ(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct Time_UE_StayedInCell(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "40950")]
pub struct Time_UE_StayedInCell_EnhancedGranularity(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TimeToWait(pub u8);
impl TimeToWait {
    pub const V1S: u8 = 0u8;
    pub const V2S: u8 = 1u8;
    pub const V5S: u8 = 2u8;
    pub const V10S: u8 = 3u8;
    pub const V20S: u8 = 4u8;
    pub const V60S: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TraceActivation {
    pub eutran_trace_id: EUTRANTraceID,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TraceCollectionEntityIPAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TraceActivationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TraceCollectionEntityIPAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TraceDepth(pub u8);
impl TraceDepth {
    pub const MINIMUM: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const MAXIMUM: u8 = 2u8;
    pub const MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 3u8;
    pub const MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 4u8;
    pub const MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceStart {
    pub protocol_i_es: TraceStartProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct Transmission_Bandwidth(pub u8);
impl Transmission_Bandwidth {
    pub const BW6: u8 = 0u8;
    pub const BW15: u8 = 1u8;
    pub const BW25: u8 = 2u8;
    pub const BW50: u8 = 3u8;
    pub const BW75: u8 = 4u8;
    pub const BW100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Transport_UP_Layer_Addresses_Info_To_Add_Item {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub gtp_transport_layer_addresses_to_add: Option<GTPTLAs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Transport_UP_Layer_Addresses_Info_To_Add_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct Transport_UP_Layer_Addresses_Info_To_Add_List(
    pub Vec<Transport_UP_Layer_Addresses_Info_To_Add_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Transport_UP_Layer_Addresses_Info_To_Remove_Item {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub gtp_transport_layer_addresses_to_remove: Option<GTPTLAs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Transport_UP_Layer_Addresses_Info_To_Remove_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct Transport_UP_Layer_Addresses_Info_To_Remove_List(
    pub Vec<Transport_UP_Layer_Addresses_Info_To_Remove_Item>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TransportLayerAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TransportLayerAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub portnumber: Port_Number,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct TriggeringMessage(pub u8);
impl TriggeringMessage {
    pub const INITIATING_MESSAGE: u8 = 0u8;
    pub const SUCCESSFUL_OUTCOME: u8 = 1u8;
    pub const UNSUCCESSFUL_OUTCOME: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TunnelInformation {
    pub transport_layer_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub udp_port_number: Option<Port_Number>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TunnelInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct TypeOfError(pub u8);
impl TypeOfError {
    pub const NOT_UNDERSTOOD: u8 = 0u8;
    pub const MISSING: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct UE_ContextInformation {
    pub mme_ue_s1ap_id: UE_S1AP_ID,
    pub ue_security_capabilities: UESecurityCapabilities,
    pub as_security_information: AS_SecurityInformation,
    pub u_eaggregate_maximum_bit_rate: UEAggregateMaximumBitRate,
    #[asn(optional_idx = 0)]
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRFP>,
    pub e_ra_bs_to_be_setup_list: E_RABs_ToBeSetup_List,
    pub rrc_context: RRC_Context,
    #[asn(optional_idx = 1)]
    pub handover_restriction_list: Option<HandoverRestrictionList>,
    #[asn(optional_idx = 2)]
    pub location_reporting_information: Option<LocationReportingInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<UE_ContextInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct UE_ContextInformation_SgNBModReq {
    #[asn(optional_idx = 0)]
    pub nrue_security_capabilities: Option<NRUESecurityCapabilities>,
    #[asn(optional_idx = 1)]
    pub sg_nb_security_key: Option<SgNBSecurityKey>,
    #[asn(optional_idx = 2)]
    pub sg_nbue_aggregate_maximum_bit_rate: Option<UEAggregateMaximumBitRate>,
    #[asn(optional_idx = 3)]
    pub e_ra_bs_to_be_added: Option<E_RABs_ToBeAdded_SgNBModReq_List>,
    #[asn(optional_idx = 4)]
    pub e_ra_bs_to_be_modified: Option<E_RABs_ToBeModified_SgNBModReq_List>,
    #[asn(optional_idx = 5)]
    pub e_ra_bs_to_be_released: Option<E_RABs_ToBeReleased_SgNBModReq_List>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<UE_ContextInformation_SgNBModReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct UE_ContextInformationRetrieve {
    pub mme_ue_s1ap_id: UE_S1AP_ID,
    pub ue_security_capabilities: UESecurityCapabilities,
    pub as_security_information: AS_SecurityInformation,
    pub u_eaggregate_maximum_bit_rate: UEAggregateMaximumBitRate,
    #[asn(optional_idx = 0)]
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRFP>,
    pub e_ra_bs_to_be_setup_list_retrieve: E_RABs_ToBeSetup_ListRetrieve,
    pub rrc_context: RRC_Context,
    #[asn(optional_idx = 1)]
    pub handover_restriction_list: Option<HandoverRestrictionList>,
    #[asn(optional_idx = 2)]
    pub location_reporting_information: Option<LocationReportingInformation>,
    #[asn(optional_idx = 3)]
    pub manag_based_md_tallowed: Option<ManagementBasedMDTallowed>,
    #[asn(optional_idx = 4)]
    pub manag_based_mdtplmn_list: Option<MDTPLMNList>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<UE_ContextInformationRetrieveIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct UE_ContextInformationSeNBModReq {
    #[asn(optional_idx = 0)]
    pub ue_security_capabilities: Option<UESecurityCapabilities>,
    #[asn(optional_idx = 1)]
    pub se_nb_security_key: Option<SeNBSecurityKey>,
    #[asn(optional_idx = 2)]
    pub se_nbue_aggregate_maximum_bit_rate: Option<UEAggregateMaximumBitRate>,
    #[asn(optional_idx = 3)]
    pub e_ra_bs_to_be_added: Option<E_RABs_ToBeAdded_List_ModReq>,
    #[asn(optional_idx = 4)]
    pub e_ra_bs_to_be_modified: Option<E_RABs_ToBeModified_List_ModReq>,
    #[asn(optional_idx = 5)]
    pub e_ra_bs_to_be_released: Option<E_RABs_ToBeReleased_List_ModReq>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<UE_ContextInformationSeNBModReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UE_ContextKeptIndicator(pub u8);
impl UE_ContextKeptIndicator {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_ContextReferenceAtSeNB {
    pub source_global_se_nb_id: GlobalENB_ID,
    pub se_nb_ue_x2ap_id: UE_X2AP_ID,
    pub se_nb_ue_x2ap_id_extension: UE_X2AP_ID_Extension,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_ContextReferenceAtSeNBIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_ContextReferenceAtSgNB {
    pub source_global_sg_nb_id: GlobalGNB_ID,
    pub sg_nb_ue_x2ap_id: SgNB_UE_X2AP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_ContextReferenceAtSgNBIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_ContextReferenceAtWT {
    pub wtid: WTID,
    pub wt_ue_xw_ap_id: WT_UE_XwAP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_ContextReferenceAtWTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UE_HistoryInformation(pub Vec<LastVisitedCell_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_HistoryInformationFromTheUE(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container_for_extended_bands(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct UE_S1AP_ID(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct UE_X2AP_ID(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095", extensible = true)]
pub struct UE_X2AP_ID_Extension(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAggregateMaximumBitRate {
    pub u_eaggregate_maximum_bit_rate_downlink: BitRate,
    pub u_eaggregate_maximum_bit_rate_uplink: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAggregateMaximumBitRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAppLayerMeasConfig {
    pub container_for_app_layer_meas_config: UEAppLayerMeasConfigContainerForAppLayerMeasConfig,
    pub area_scope_of_qmc: AreaScopeOfQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAppLayerMeasConfigIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextRelease {
    pub protocol_i_es: UEContextReleaseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct UEID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapability(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingRequest {
    pub protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingResponse {
    pub protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESecurityCapabilities {
    pub encryption_algorithms: EncryptionAlgorithms,
    pub integrity_protection_algorithms: IntegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESecurityCapabilitiesIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESidelinkAggregateMaximumBitRate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESidelinkAggregateMaximumBitRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "8192"
)]
pub struct UEsToBeResetList(pub Vec<UEsToBeResetList_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UEsToBeResetList_Item {
    pub me_nb_id: UE_X2AP_ID,
    #[asn(optional_idx = 0)]
    pub me_nb_id_ext: Option<UE_X2AP_ID_Extension>,
    #[asn(optional_idx = 1)]
    pub sg_nb_id: Option<SgNB_UE_X2AP_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UEsToBeResetList_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_GBR_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_GBR_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "110")]
pub struct UL_HighInterferenceIndication(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UL_HighInterferenceIndicationInfo(pub Vec<UL_HighInterferenceIndicationInfo_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_HighInterferenceIndicationInfo_Item {
    pub target_cell_id: ECGI,
    pub ul_interferenceindication: UL_HighInterferenceIndication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_HighInterferenceIndicationInfo_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "110"
)]
pub struct UL_InterferenceOverloadIndication(pub Vec<UL_InterferenceOverloadIndication_Item>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UL_InterferenceOverloadIndication_Item(pub u8);
impl UL_InterferenceOverloadIndication_Item {
    pub const HIGH_INTERFERENCE: u8 = 0u8;
    pub const MEDIUM_INTERFERENCE: u8 = 1u8;
    pub const LOW_INTERFERENCE: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_Total_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_Total_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UL_UE_Configuration(pub u8);
impl UL_UE_Configuration {
    pub const NO_DATA: u8 = 0u8;
    pub const SHARED: u8 = 1u8;
    pub const ONLY: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_non_GBR_PRB_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_non_GBR_PRB_usage_for_MIMO(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct UL_scheduling_PDCCH_CCE_usage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ULConfiguration {
    pub ul_pdcp: UL_UE_Configuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ULConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ULOnlySharing {
    pub ul_resource_bitmap_ul_only_sharing: DataTrafficResources,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ULOnlySharingIE_Extensions>,
}

pub type ULResourceBitmapULandDLSharing = DataTrafficResources;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ULResourcesULandDLSharing {
    #[asn(key = 0, extended = false)]
    Unchanged(ULResourcesULandDLSharing_unchanged),
    #[asn(key = 1, extended = false)]
    Changed(ULResourceBitmapULandDLSharing),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ULandDLSharing {
    pub ul_resources_u_land_dl_sharing: ULResourcesULandDLSharing,
    pub dl_resources_u_land_dl_sharing: DLResourcesULandDLSharing,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ULandDLSharingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "VisibleString")]
pub struct URI_Address(pub String);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UnlicensedSpectrumRestriction(pub u8);
impl UnlicensedSpectrumRestriction {
    pub const UNLICENSED_RESTRICTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnsuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: UnsuccessfulOutcomeValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum UsableABSInformation {
    #[asn(key = 0, extended = false)]
    Fdd(UsableABSInformationFDD),
    #[asn(key = 1, extended = false)]
    Tdd(UsableABSInformationTDD),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UsableABSInformationFDD {
    pub usable_abs_pattern_info: UsableABSInformationFDDUsable_abs_pattern_info,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UsableABSInformationFDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UsableABSInformationTDD {
    pub usaable_abs_pattern_info: UsableABSInformationTDDUsaable_abs_pattern_info,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UsableABSInformationTDDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct UserPlaneTrafficActivityReport(pub u8);
impl UserPlaneTrafficActivityReport {
    pub const INACTIVE: u8 = 0u8;
    pub const RE_ACTIVATED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct V2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<V2XServicesAuthorizedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VehicleUE(pub u8);
impl VehicleUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasConfig(pub u8);
impl WLANMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLANMeasConfigNameList(pub Vec<WLANName>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLANMeasurementConfiguration {
    pub wlan_meas_config: WLANMeasConfig,
    #[asn(optional_idx = 0)]
    pub wlan_meas_config_name_list: Option<WLANMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi>,
    #[asn(optional_idx = 2)]
    pub wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLANName(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct WT_UE_XwAP_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum WTID {
    #[asn(key = 0, extended = false)]
    WTID_Type1(WTID_Type1),
    #[asn(key = 1, extended = false)]
    WTID_Type2(WTID_Long_Type2),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "48", sz_ub = "48")]
pub struct WTID_Long_Type2(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WTID_Type1 {
    pub plmn_identity: PLMN_Identity,
    pub short_wtid: WTID_Type1ShortWTID,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct WidebandCQI {
    pub wideband_cqi_codeword0: WidebandCQIWidebandCQICodeword0,
    #[asn(optional_idx = 0)]
    pub wideband_cqi_codeword1: Option<WidebandCQICodeword1>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<WidebandCQIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum WidebandCQICodeword1 {
    #[asn(key = 0, extended = false)]
    Four_bitCQI(WidebandCQICodeword1_four_bitCQI),
    #[asn(key = 1, extended = false)]
    Three_bitSpatialDifferentialCQI(WidebandCQICodeword1_three_bitSpatialDifferentialCQI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct X2AP_Message(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum X2AP_PDU {
    #[asn(key = 0, extended = false)]
    InitiatingMessage(InitiatingMessage),
    #[asn(key = 1, extended = false)]
    SuccessfulOutcome(SuccessfulOutcome),
    #[asn(key = 2, extended = false)]
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2APMessageTransfer {
    pub protocol_i_es: X2APMessageTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8", extensible = true)]
pub struct X2BenefitValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2Release {
    pub protocol_i_es: X2ReleaseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2RemovalFailure {
    pub protocol_i_es: X2RemovalFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2RemovalRequest {
    pub protocol_i_es: X2RemovalRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2RemovalResponse {
    pub protocol_i_es: X2RemovalResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2SetupFailure {
    pub protocol_i_es: X2SetupFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2SetupRequest {
    pub protocol_i_es: X2SetupRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct X2SetupResponse {
    pub protocol_i_es: X2SetupResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ABS_StatusIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ABS_StatusIE_Extensions(pub Vec<ABS_StatusIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct ABSInformation_abs_inactive;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct ABSInformationFDDAbs_pattern_info(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ABSInformationFDDNumberOfCellSpecificAntennaPorts(pub u8);
impl ABSInformationFDDNumberOfCellSpecificAntennaPorts {
    pub const ONE: u8 = 0u8;
    pub const TWO: u8 = 1u8;
    pub const FOUR: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct ABSInformationFDDMeasurement_subset(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ABSInformationFDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ABSInformationFDDIE_Extensions(pub Vec<ABSInformationFDDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "70")]
pub struct ABSInformationTDDAbs_pattern_info(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ABSInformationTDDNumberOfCellSpecificAntennaPorts(pub u8);
impl ABSInformationTDDNumberOfCellSpecificAntennaPorts {
    pub const ONE: u8 = 0u8;
    pub const TWO: u8 = 1u8;
    pub const FOUR: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "70")]
pub struct ABSInformationTDDMeasurement_subset(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ABSInformationTDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ABSInformationTDDIE_Extensions(pub Vec<ABSInformationTDDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AS_SecurityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AS_SecurityInformationIE_Extensions(pub Vec<AS_SecurityInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AccessAndMobilityIndicationProtocolIEs_EntryValue {
    #[asn(key = 414)]
    Id_NRRAReport(NRRAReport),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AccessAndMobilityIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AccessAndMobilityIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AccessAndMobilityIndicationProtocolIEs(
    pub Vec<AccessAndMobilityIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ActivatedCellList_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ActivatedCellList_ItemIE_Extensions(pub Vec<ActivatedCellList_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ActivatedNRCellList_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ActivatedNRCellList_ItemIE_Extensions(
    pub Vec<ActivatedNRCellList_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16")]
pub struct Additional_Measurement_Timing_Configuration_ItemAdditionalMeasurementTimingConfiguration(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Additional_Measurement_Timing_Configuration_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Additional_Measurement_Timing_Configuration_ItemIE_Extensions(
    pub Vec<Additional_Measurement_Timing_Configuration_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalListofForwardingGTPTunnelEndpoint_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AdditionalListofForwardingGTPTunnelEndpoint_ItemIE_Extensions(
    pub Vec<AdditionalListofForwardingGTPTunnelEndpoint_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalSpecialSubframe_InfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AdditionalSpecialSubframe_InfoIE_Extensions(
    pub Vec<AdditionalSpecialSubframe_InfoIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalSpecialSubframeExtension_InfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AdditionalSpecialSubframeExtension_InfoIE_Extensions(
    pub Vec<AdditionalSpecialSubframeExtension_InfoIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllocationAndRetentionPriorityIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllocationAndRetentionPriorityIE_Extensions(
    pub Vec<AllocationAndRetentionPriorityIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct AreaScopeOfMDT_pLMNWide;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BPLMN_ID_Info_EUTRA_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BPLMN_ID_Info_EUTRA_ItemIE_Extension(
    pub Vec<BPLMN_ID_Info_EUTRA_ItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BPLMN_ID_Info_NR_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BPLMN_ID_Info_NR_ItemIE_Extension(pub Vec<BPLMN_ID_Info_NR_ItemIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BandInfoIE_Extensions(pub Vec<BandInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasurementConfigurationBt_rssi(pub u8);
impl BluetoothMeasurementConfigurationBt_rssi {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasurementConfigurationIE_Extensions(
    pub Vec<BluetoothMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CHOTimeBasedInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CHOTimeBasedInformationIE_Extensions(
    pub Vec<CHOTimeBasedInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CHOinformation_ACKIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CHOinformation_ACKIE_Extensions(pub Vec<CHOinformation_ACKIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CHOinformation_AddReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CHOinformation_AddReqIE_Extensions(pub Vec<CHOinformation_AddReqIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CHOinformation_ModReqConditionalReconfig(pub u8);
impl CHOinformation_ModReqConditionalReconfig {
    pub const INTRA_MN_CHO: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CHOinformation_ModReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CHOinformation_ModReqIE_Extensions(pub Vec<CHOinformation_ModReqIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CHOinformation_REQIE_Extensions_EntryExtensionValue {
    #[asn(key = 446)]
    Id_CHOTimeBasedInformation(CHOTimeBasedInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CHOinformation_REQIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: CHOinformation_REQIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CHOinformation_REQIE_Extensions(pub Vec<CHOinformation_REQIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CNTypeRestrictionsItemCn_type(pub u8);
impl CNTypeRestrictionsItemCn_type {
    pub const FIVE_GC_FORBIDDEN: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNTypeRestrictionsItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNTypeRestrictionsItemIE_Extensions(pub Vec<CNTypeRestrictionsItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueExtendedIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueExtendedIE_Extensions(pub Vec<COUNTValueExtendedIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvalueIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvalueIE_Extensions(pub Vec<COUNTvalueIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions(
    pub Vec<COUNTvaluePDCP_SNlength18IE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPACcandidatePSCells_itemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPACcandidatePSCells_itemIE_Extensions(
    pub Vec<CPACcandidatePSCells_itemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPACinformation_REQDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPACinformation_REQDIE_Extensions(pub Vec<CPACinformation_REQDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CPAinformation_MODMax_no_of_pscells(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPAinformation_MODIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPAinformation_MODIE_Extensions(pub Vec<CPAinformation_MODIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPAinformation_MOD_ACKIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPAinformation_MOD_ACKIE_Extensions(pub Vec<CPAinformation_MOD_ACKIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CPAinformation_REQMax_no_of_pscells(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPAinformation_REQIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPAinformation_REQIE_Extensions(pub Vec<CPAinformation_REQIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPAinformation_REQ_ACKIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPAinformation_REQ_ACKIE_Extensions(pub Vec<CPAinformation_REQ_ACKIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CPC_cancelProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 239)]
    Id_Target_SgNB_ID(GlobalGNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPC_cancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CPC_cancelProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CPC_cancelProtocolIEs(pub Vec<CPC_cancelProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPC_target_SgNB_conf_itemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPC_target_SgNB_conf_itemIE_Extensions(
    pub Vec<CPC_target_SgNB_conf_itemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPC_target_SgNB_mod_itemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPC_target_SgNB_mod_itemIE_Extensions(
    pub Vec<CPC_target_SgNB_mod_itemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CPC_target_SgNB_reqd_itemMax_no_of_pscells(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPC_target_SgNB_reqd_itemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPC_target_SgNB_reqd_itemIE_Extensions(
    pub Vec<CPC_target_SgNB_reqd_itemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPCinformation_CONFIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPCinformation_CONFIE_Extensions(pub Vec<CPCinformation_CONFIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPCinformation_NOTIFYIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPCinformation_NOTIFYIE_Extensions(pub Vec<CPCinformation_NOTIFYIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPCinformation_REQDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPCinformation_REQDIE_Extensions(pub Vec<CPCinformation_REQDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPCupdate_MODIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CPCupdate_MODIE_Extensions(pub Vec<CPCupdate_MODIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "95")]
pub struct CSI_RS_MTC_Configuration_ItemCsi_RS_Index(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CSI_RS_MTC_Configuration_ItemCsi_RS_Status(pub u8);
impl CSI_RS_MTC_Configuration_ItemCsi_RS_Status {
    pub const ACTIVATED: u8 = 0u8;
    pub const DEACTIVATED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_MTC_Configuration_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSI_RS_MTC_Configuration_ItemIE_Extensions(
    pub Vec<CSI_RS_MTC_Configuration_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "95")]
pub struct CSI_RS_MTC_Neighbour_ItemCsi_RS_Index(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_MTC_Neighbour_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSI_RS_MTC_Neighbour_ItemIE_Extensions(
    pub Vec<CSI_RS_MTC_Neighbour_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_Neighbour_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSI_RS_Neighbour_ItemIE_Extensions(pub Vec<CSI_RS_Neighbour_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSIReportList_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSIReportList_EntryIE_Extensions(pub Vec<CSIReportList_EntryIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSIReportList_Entry {
    pub ueid: UEID,
    pub csi_report_per_csi_process: CSIReportPerCSIProcess,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CSIReportList_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "7", extensible = true)]
pub struct CSIReportPerCSIProcess_EntryCSIProcessConfigurationIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSIReportPerCSIProcess_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSIReportPerCSIProcess_EntryIE_Extensions(
    pub Vec<CSIReportPerCSIProcess_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSIReportPerCSIProcess_Entry {
    pub csi_process_configuration_index: CSIReportPerCSIProcess_EntryCSIProcessConfigurationIndex,
    pub csi_report_per_csi_process_item: CSIReportPerCSIProcessItem,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CSIReportPerCSIProcess_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8", extensible = true)]
pub struct CSIReportPerCSIProcessItem_EntryRI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSIReportPerCSIProcessItem_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSIReportPerCSIProcessItem_EntryIE_Extensions(
    pub Vec<CSIReportPerCSIProcessItem_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CSIReportPerCSIProcessItem_Entry {
    pub ri: CSIReportPerCSIProcessItem_EntryRI,
    pub wideband_cqi: WidebandCQI,
    pub subband_size: SubbandSize,
    #[asn(optional_idx = 0)]
    pub subband_cqi_list: Option<SubbandCQIList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CSIReportPerCSIProcessItem_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellActivationFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellActivationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellActivationFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellActivationFailureProtocolIEs(pub Vec<CellActivationFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellActivationRequestProtocolIEs_EntryValue {
    #[asn(key = 57)]
    Id_ServedCellsToActivate(ServedCellsToActivate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellActivationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellActivationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellActivationRequestProtocolIEs(pub Vec<CellActivationRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellActivationResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_ActivatedCellList(ActivatedCellList),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellActivationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellActivationResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellActivationResponseProtocolIEs(pub Vec<CellActivationResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CellAssistanceInformation_full_list(pub u8);
impl CellAssistanceInformation_full_list {
    pub const ALL_SERVED_N_RCELLS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDTIE_Extensions(pub Vec<CellBasedMDTIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedQMCIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedQMCIE_Extensions(pub Vec<CellBasedQMCIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellInformation_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 61)]
    Id_ABSInformation(ABSInformation),
    #[asn(key = 108)]
    Id_CoMPInformation(CoMPInformation),
    #[asn(key = 106)]
    Id_DynamicDLTransmissionInformation(DynamicDLTransmissionInformation),
    #[asn(key = 100)]
    Id_ExtendedULInterferenceOverloadInfo(ExtendedULInterferenceOverloadInfo),
    #[asn(key = 99)]
    Id_IntendedULDLConfiguration(SubframeAssignment),
    #[asn(key = 62)]
    Id_InvokeIndication(InvokeIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInformation_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: CellInformation_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellInformation_ItemIE_Extensions(pub Vec<CellInformation_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellInformation_List_EntryValue {
    #[asn(key = 7)]
    Id_CellInformation_Item(CellInformation_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInformation_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellInformation_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_E_UTRA_ENDC_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellMeasurementResult_E_UTRA_ENDC_ItemIE_Extensions(
    pub Vec<CellMeasurementResult_E_UTRA_ENDC_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellMeasurementResult_E_UTRA_ENDC_List_EntryValue {
    #[asn(key = 402)]
    Id_CellMeasurementResult_E_UTRA_ENDC_Item(CellMeasurementResult_E_UTRA_ENDC_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_E_UTRA_ENDC_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellMeasurementResult_E_UTRA_ENDC_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellMeasurementResult_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 63)]
    Id_ABS_Status(ABS_Status),
    #[asn(key = 146)]
    Id_CSIReportList(CSIReportList),
    #[asn(key = 170)]
    Id_CellReportingIndicator(CellReportingIndicator),
    #[asn(key = 42)]
    Id_CompositeAvailableCapacityGroup(CompositeAvailableCapacityGroup),
    #[asn(key = 417)]
    Id_MeasurementResultforNRCellsPossiblyAggregated(MeasurementResultforNRCellsPossiblyAggregated),
    #[asn(key = 110)]
    Id_RSRPMRList(RSRPMRList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: CellMeasurementResult_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellMeasurementResult_ItemIE_Extensions(
    pub Vec<CellMeasurementResult_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellMeasurementResult_List_EntryValue {
    #[asn(key = 33)]
    Id_CellMeasurementResult_Item(CellMeasurementResult_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellMeasurementResult_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16777215", extensible = true)]
pub struct CellMeasurementResult_NR_ENDC_ItemNumberofActiveUEs(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_NR_ENDC_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellMeasurementResult_NR_ENDC_ItemIE_Extensions(
    pub Vec<CellMeasurementResult_NR_ENDC_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellMeasurementResult_NR_ENDC_List_EntryValue {
    #[asn(key = 394)]
    Id_CellMeasurementResult_NR_ENDC_Item(CellMeasurementResult_NR_ENDC_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellMeasurementResult_NR_ENDC_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellMeasurementResult_NR_ENDC_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellReplacingInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellReplacingInfoIE_Extensions(pub Vec<CellReplacingInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_E_UTRA_ENDC_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellToReport_E_UTRA_ENDC_ItemIE_Extensions(
    pub Vec<CellToReport_E_UTRA_ENDC_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellToReport_E_UTRA_ENDC_List_EntryValue {
    #[asn(key = 404)]
    Id_CellToReport_E_UTRA_ENDC_Item(CellToReport_E_UTRA_ENDC_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_E_UTRA_ENDC_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellToReport_E_UTRA_ENDC_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellToReport_ItemIE_Extensions(pub Vec<CellToReport_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellToReport_List_EntryValue {
    #[asn(key = 31)]
    Id_CellToReport_Item(CellToReport_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellToReport_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_NR_ENDC_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellToReport_NR_ENDC_ItemIE_Extensions(
    pub Vec<CellToReport_NR_ENDC_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellToReport_NR_ENDC_List_EntryValue {
    #[asn(key = 392)]
    Id_CellToReport_NR_ENDC_Item(CellToReport_NR_ENDC_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellToReport_NR_ENDC_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellToReport_NR_ENDC_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellTrafficTraceProtocolIEs_EntryValue {
    #[asn(key = 333)]
    Id_EUTRANTraceID(EUTRANTraceID),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 376)]
    Id_PrivacyIndicator(PrivacyIndicator),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 377)]
    Id_TraceCollectionEntityIPAddress(TraceCollectionEntityIPAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTrafficTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellTrafficTraceProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellTrafficTraceProtocolIEs(pub Vec<CellTrafficTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTypeIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellTypeIE_Extensions(pub Vec<CellTypeIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellandCapacityAssistInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellandCapacityAssistInfoIE_Extensions(
    pub Vec<CellandCapacityAssistInfoIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "4400")]
pub struct CoMPHypothesisSetItemCoMPHypothesis(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoMPHypothesisSetItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoMPHypothesisSetItemIE_Extensions(pub Vec<CoMPHypothesisSetItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoMPInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoMPInformationIE_Extensions(pub Vec<CoMPInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoMPInformationItem_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoMPInformationItem_EntryIE_Extensions(
    pub Vec<CoMPInformationItem_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CoMPInformationItem_Entry {
    pub co_mp_hypothesis_set: CoMPHypothesisSet,
    pub benefit_metric: BenefitMetric,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CoMPInformationItem_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023", extensible = true)]
pub struct CoMPInformationStartTime_EntryStartSFN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct CoMPInformationStartTime_EntryStartSubframeNumber(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoMPInformationStartTime_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoMPInformationStartTime_EntryIE_Extensions(
    pub Vec<CoMPInformationStartTime_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CoMPInformationStartTime_Entry {
    pub start_sfn: CoMPInformationStartTime_EntryStartSFN,
    pub start_subframe_number: CoMPInformationStartTime_EntryStartSubframeNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CoMPInformationStartTime_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompleteFailureCauseInformation_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompleteFailureCauseInformation_ItemIE_Extensions(
    pub Vec<CompleteFailureCauseInformation_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CompleteFailureCauseInformation_List_EntryValue {
    #[asn(key = 69)]
    Id_CompleteFailureCauseInformation_Item(CompleteFailureCauseInformation_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompleteFailureCauseInformation_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CompleteFailureCauseInformation_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompositeAvailableCapacityIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompositeAvailableCapacityIE_Extensions(
    pub Vec<CompositeAvailableCapacityIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompositeAvailableCapacityGroupIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompositeAvailableCapacityGroupIE_Extensions(
    pub Vec<CompositeAvailableCapacityGroupIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ConditionalHandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 365)]
    Id_CandidateCellsToBeCancelledList(CandidateCellsToBeCancelledList),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConditionalHandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ConditionalHandoverCancelProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ConditionalHandoverCancelProtocolIEs(
    pub Vec<ConditionalHandoverCancelProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct CoverageModification_ItemCoverageState(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnosticsIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnosticsIE_Extensions(pub Vec<CriticalityDiagnosticsIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnostics_IE_List_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnostics_IE_List_EntryIE_Extensions(
    pub Vec<CriticalityDiagnostics_IE_List_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CriticalityDiagnostics_IE_List_Entry {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIE_ID,
    pub type_of_error: TypeOfError,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CriticalityDiagnostics_IE_List_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DAPSRequestInfoDAPSIndicator(pub u8);
impl DAPSRequestInfoDAPSIndicator {
    pub const DAPS_HO_REQUIRED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSRequestInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSRequestInfoIE_Extensions(pub Vec<DAPSRequestInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DAPSResponseInfoDAPSResponseIndicator(pub u8);
impl DAPSResponseInfoDAPSResponseIndicator {
    pub const DAPS_HO_ACCEPTED: u8 = 0u8;
    pub const DAPS_HO_NOT_ACCEPTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoIE_Extensions(pub Vec<DAPSResponseInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLDiscardingIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DLDiscardingIE_Extension(pub Vec<DLDiscardingIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct DLResourcesULandDLSharing_unchanged;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DataForwardingAddressIndicationProtocolIEs_EntryValue {
    #[asn(key = 407)]
    Id_CHO_DC_EarlyDataForwarding(CHO_DC_EarlyDataForwarding),
    #[asn(key = 368)]
    Id_CHO_DC_Indicator(CHO_DC_Indicator),
    #[asn(key = 431)]
    Id_CPCinformation_NOTIFY(CPCinformation_NOTIFY),
    #[asn(key = 307)]
    Id_E_RABs_DataForwardingAddress_List(E_RABs_DataForwardingAddress_List),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataForwardingAddressIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DataForwardingAddressIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DataForwardingAddressIndicationProtocolIEs(
    pub Vec<DataForwardingAddressIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct DataTrafficResourceIndicationActivationSFN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataTrafficResourceIndicationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DataTrafficResourceIndicationIE_Extensions(
    pub Vec<DataTrafficResourceIndicationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DeactivateTraceProtocolIEs_EntryValue {
    #[asn(key = 333)]
    Id_EUTRANTraceID(EUTRANTraceID),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeactivateTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DeactivateTraceProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DeactivateTraceProtocolIEs(pub Vec<DeactivateTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct DeliveryStatusHighestSuccessDeliveredPDCPSN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeliveryStatusIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DeliveryStatusIE_Extensions(pub Vec<DeliveryStatusIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct DynamicDLTransmissionInformation_naics_inactive;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct DynamicNAICSInformationTransmissionModes(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct DynamicNAICSInformationPB_information(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "3")]
pub struct DynamicNAICSInformationPA_list(pub Vec<PA_Values>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DynamicNAICSInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DynamicNAICSInformationIE_Extensions(
    pub Vec<DynamicNAICSInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RAB_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RAB_ItemIE_Extensions(pub Vec<E_RAB_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RAB_Level_QoS_ParametersIE_Extensions_EntryExtensionValue {
    #[asn(key = 273)]
    Id_DownlinkPacketLossRate(Packet_LossRate),
    #[asn(key = 274)]
    Id_UplinkPacketLossRate(Packet_LossRate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RAB_Level_QoS_ParametersIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RAB_Level_QoS_ParametersIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RAB_Level_QoS_ParametersIE_Extensions(
    pub Vec<E_RAB_Level_QoS_ParametersIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RAB_List_EntryValue {
    #[asn(key = 2)]
    Id_E_RAB_Item(E_RAB_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RAB_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RAB_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReport_ItemStartTimeStamp(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReport_ItemEndTimeStamp(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReport_ItemUsageCountUL(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReport_ItemUsageCountDL(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABUsageReport_ItemIE_Extensions(pub Vec<E_RABUsageReport_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABUsageReportList_EntryValue {
    #[asn(key = 263)]
    Id_E_RABUsageReport_Item(E_RABUsageReport_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABUsageReportList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 366)]
    Id_DAPSResponseInfo(DAPSResponseInfo),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_Admitted_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ItemIE_Extensions(pub Vec<E_RABs_Admitted_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_List_EntryValue {
    #[asn(key = 0)]
    Id_E_RABs_Admitted_Item(E_RABs_Admitted_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_Item_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_Item_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_List_EntryValue {
    #[asn(key = 121)]
    Id_E_RABs_Admitted_ToBeAdded_Item(E_RABs_Admitted_ToBeAdded_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeAdded_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_ModAckList_EntryValue {
    #[asn(key = 131)]
    Id_E_RABs_Admitted_ToBeAdded_ModAckItem(E_RABs_Admitted_ToBeAdded_ModAckItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_ModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeAdded_ModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 314)]
    Id_lCID(LCID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 436)]
    Id_SecurityResult(SecurityResult),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_EntryValue {
    #[asn(key = 213)]
    Id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item(E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 314)]
    Id_lCID(LCID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 436)]
    Id_SecurityResult(SecurityResult),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeAdded_SgNBModAckList_EntryValue {
    #[asn(key = 222)]
    Id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item(E_RABs_Admitted_ToBeAdded_SgNBModAck_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeAdded_SgNBModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeAdded_SgNBModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeModified_ModAckList_EntryValue {
    #[asn(key = 132)]
    Id_E_RABs_Admitted_ToBeModified_ModAckItem(E_RABs_Admitted_ToBeModified_ModAckItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_ModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeModified_ModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToBeModified_SgNBModAck_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 300)]
    Id_RLC_Status(RLC_Status),
    #[asn(key = 312)]
    Id_secondarysgNBDLGTPTEIDatPDCP(GTPtunnelEndpoint),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeModified_SgNBModAckList_EntryValue {
    #[asn(key = 223)]
    Id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item(E_RABs_Admitted_ToBeModified_SgNBModAck_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeModified_SgNBModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeModified_SgNBModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeReleased_ModAckList_EntryValue {
    #[asn(key = 133)]
    Id_E_RABs_Admitted_ToBeReleased_ModAckItem(E_RABs_Admitted_ToReleased_ModAckItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_ModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeReleased_ModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeReleased_SgNBModAckList_EntryValue {
    #[asn(key = 224)]
    Id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item(E_RABs_Admitted_ToReleased_SgNBModAck_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBModAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeReleased_SgNBModAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIE_Extensions(
    pub Vec<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_EntryValue {
    #[asn(key = 319)]
    Id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item(
        E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_Admitted_ToReleased_SgNBModAck_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_Admitted_ToReleased_SgNBModAck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_Admitted_ToReleased_SgNBModAck_ItemIE_Extensions(
    pub Vec<E_RABs_Admitted_ToReleased_SgNBModAck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_AdmittedToBeModified_SgNBModConf_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_ItemIE_Extensions(
    pub Vec<E_RABs_AdmittedToBeModified_SgNBModConf_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue
{
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry { # [asn (key_field = true)] pub id : ProtocolIE_ID , pub criticality : Criticality , pub extension_value : E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue , }

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_AdmittedToBeModified_SgNBModConfList_EntryValue {
    #[asn(key = 295)]
    Id_E_RABs_AdmittedToBeModified_SgNBModConf_Item(E_RABs_AdmittedToBeModified_SgNBModConf_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_AdmittedToBeModified_SgNBModConfList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_AdmittedToBeModified_SgNBModConfList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_DataForwardingAddress_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_DataForwardingAddress_ItemIE_Extensions(
    pub Vec<E_RABs_DataForwardingAddress_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_DataForwardingAddress_List_EntryValue {
    #[asn(key = 308)]
    Id_E_RABs_DataForwardingAddress_Item(E_RABs_DataForwardingAddress_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_DataForwardingAddress_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_DataForwardingAddress_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_SubjectToCounterCheck_List_EntryValue {
    #[asn(key = 142)]
    Id_E_RABs_SubjectToCounterCheckItem(E_RABs_SubjectToCounterCheckItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToCounterCheck_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_SubjectToCounterCheck_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct E_RABs_SubjectToCounterCheckItemUL_Count(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct E_RABs_SubjectToCounterCheckItemDL_Count(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToCounterCheckItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_SubjectToCounterCheckItemIE_Extensions(
    pub Vec<E_RABs_SubjectToCounterCheckItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct E_RABs_SubjectToSgNBCounterCheck_ItemUL_Count(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct E_RABs_SubjectToSgNBCounterCheck_ItemDL_Count(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToSgNBCounterCheck_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_SubjectToSgNBCounterCheck_ItemIE_Extensions(
    pub Vec<E_RABs_SubjectToSgNBCounterCheck_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_SubjectToSgNBCounterCheck_List_EntryValue {
    #[asn(key = 236)]
    Id_E_RABs_SubjectToSgNBCounterCheck_Item(E_RABs_SubjectToSgNBCounterCheck_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToSgNBCounterCheck_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_SubjectToSgNBCounterCheck_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 93)]
    Id_DLCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 152)]
    Id_DLCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
    #[asn(key = 91)]
    Id_ReceiveStatusOfULPDCPSDUsExtended(ReceiveStatusOfULPDCPSDUsExtended),
    #[asn(key = 150)]
    Id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18),
    #[asn(key = 92)]
    Id_ULCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 151)]
    Id_ULCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_SubjectToStatusTransfer_ItemIE_Extensions(
    pub Vec<E_RABs_SubjectToStatusTransfer_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_SubjectToStatusTransfer_List_EntryValue {
    #[asn(key = 19)]
    Id_E_RABs_SubjectToStatusTransfer_Item(E_RABs_SubjectToStatusTransfer_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_SubjectToStatusTransfer_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_SubjectToStatusTransfer_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 171)]
    Id_BearerType(BearerType),
    #[asn(key = 166)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 167)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_Item_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_Item_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_List_EntryValue {
    #[asn(key = 118)]
    Id_E_RABs_ToBeAdded_Item(E_RABs_ToBeAdded_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeAdded_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_List_ModReq_EntryValue {
    #[asn(key = 125)]
    Id_E_RABs_ToBeAdded_ModReqItem(E_RABs_ToBeAdded_ModReqItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_List_ModReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeAdded_List_ModReq_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 171)]
    Id_BearerType(BearerType),
    #[asn(key = 166)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 167)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_ModReqItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions_EntryExtensionValue {
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_ModReqItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeAdded_SgNBAddReq_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBAddReq_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 315)]
    Id_duplicationActivation(DuplicationActivation),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 171)]
    Id_BearerType(BearerType),
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 317)]
    Id_RLCMode_transferred(RLCMode),
    #[asn(key = 435)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
    #[asn(key = 413)]
    Id_SourceNodeDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBAddReqList_EntryValue {
    #[asn(key = 209)]
    Id_E_RABs_ToBeAdded_SgNBAddReq_Item(E_RABs_ToBeAdded_SgNBAddReq_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBAddReqList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeAdded_SgNBAddReqList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeAdded_SgNBModReq_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBModReq_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBModReq_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBModReq_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 315)]
    Id_duplicationActivation(DuplicationActivation),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 171)]
    Id_BearerType(BearerType),
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 317)]
    Id_RLCMode_transferred(RLCMode),
    #[asn(key = 435)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeAdded_SgNBModReq_List_EntryValue {
    #[asn(key = 216)]
    Id_E_RABs_ToBeAdded_SgNBModReq_Item(E_RABs_ToBeAdded_SgNBModReq_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeAdded_SgNBModReq_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeAdded_SgNBModReq_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_List_ModReq_EntryValue {
    #[asn(key = 126)]
    Id_E_RABs_ToBeModified_ModReqItem(E_RABs_ToBeModified_ModReqItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_List_ModReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeModified_List_ModReq_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_ModReqItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_ModReqItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeModified_ModReqItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_ModReqItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_ModReqItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeModified_ModReqItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeModified_SgNBModReq_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReq_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReq_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReq_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 313)]
    Id_secondarymeNBULGTPTEIDatPDCP(GTPtunnelEndpoint),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 300)]
    Id_RLC_Status(RLC_Status),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReq_List_EntryValue {
    #[asn(key = 217)]
    Id_E_RABs_ToBeModified_SgNBModReq_Item(E_RABs_ToBeModified_SgNBModReq_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReq_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeModified_SgNBModReq_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeModified_SgNBModReqd_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReqd_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReqd_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReqd_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 300)]
    Id_RLC_Status(RLC_Status),
    #[asn(key = 314)]
    Id_lCID(LCID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 311)]
    Id_dLPDCPSnLength(PDCPSnLength),
    #[asn(key = 325)]
    Id_new_drb_ID_req(NewDRBIDrequest),
    #[asn(key = 302)]
    Id_uLpDCPSnLength(PDCPSnLength),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeModified_SgNBModReqdList_EntryValue {
    #[asn(key = 228)]
    Id_E_RABs_ToBeModified_SgNBModReqd_Item(E_RABs_ToBeModified_SgNBModReqd_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeModified_SgNBModReqdList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeModified_SgNBModReqdList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_List_ModReq_EntryValue {
    #[asn(key = 127)]
    Id_E_RABs_ToBeReleased_ModReqItem(E_RABs_ToBeReleased_ModReqItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_List_ModReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_List_ModReq_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_List_RelConf_EntryValue {
    #[asn(key = 140)]
    Id_E_RABs_ToBeReleased_RelConfItem(E_RABs_ToBeReleased_RelConfItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_List_RelConf_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_List_RelConf_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_List_RelReq_EntryValue {
    #[asn(key = 138)]
    Id_E_RABs_ToBeReleased_RelReqItem(E_RABs_ToBeReleased_RelReqItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_List_RelReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_List_RelReq_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_ModReqItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_ModReqItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_ModReqItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_ModReqItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_ModReqItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_ModReqItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_ModReqd_EntryValue {
    #[asn(key = 135)]
    Id_E_RABs_ToBeReleased_ModReqdItem(E_RABs_ToBeReleased_ModReqdItem),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_ModReqd_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_ModReqd_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_ModReqdItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_ModReqdItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_ModReqdItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_RelConfItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_RelConfItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_RelConfItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_RelConfItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_RelConfItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_RelConfItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_RelReqItem_SCG_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_RelReqItem_SCG_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_RelReqItem_SCG_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_RelReqItem_Split_BearerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_RelReqItem_Split_BearerIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_RelReqItem_Split_BearerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_SgNBChaConf_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBChaConf_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue {
    #[asn(key = 441)]
    Id_AdditionalListofForwardingGTPTunnelEndpoint(AdditionalListofForwardingGTPTunnelEndpoint),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value:
        E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBChaConfList_EntryValue {
    #[asn(key = 230)]
    Id_E_RABs_ToBeReleased_SgNBChaConf_Item(E_RABs_ToBeReleased_SgNBChaConf_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBChaConfList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBChaConfList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_SgNBModReq_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReq_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBModReq_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBModReq_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBModReq_List_EntryValue {
    #[asn(key = 218)]
    Id_E_RABs_ToBeReleased_SgNBModReq_Item(E_RABs_ToBeReleased_SgNBModReq_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReq_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBModReq_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 317)]
    Id_RLCMode_transferred(RLCMode),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBModReqd_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBModReqdList_EntryValue {
    #[asn(key = 227)]
    Id_E_RABs_ToBeReleased_SgNBModReqd_Item(E_RABs_ToBeReleased_SgNBModReqd_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBModReqdList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBModReqdList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_SgNBRelConf_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelConf_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBRelConfList_EntryValue {
    #[asn(key = 234)]
    Id_E_RABs_ToBeReleased_SgNBRelConf_Item(E_RABs_ToBeReleased_SgNBRelConf_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelConfList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBRelConfList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum E_RABs_ToBeReleased_SgNBRelReq_ItemResource_configuration {
    #[asn(key = 0, extended = false)]
    SgNBPDCPpresent(E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresent),
    #[asn(key = 1, extended = false)]
    SgNBPDCPnotpresent(E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresent),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelReq_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBRelReqList_EntryValue {
    #[asn(key = 232)]
    Id_E_RABs_ToBeReleased_SgNBRelReq_Item(E_RABs_ToBeReleased_SgNBRelReq_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReqList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBRelReqList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReqd_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeReleased_SgNBRelReqd_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeReleased_SgNBRelReqd_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeReleased_SgNBRelReqdList_EntryValue {
    #[asn(key = 321)]
    Id_E_RABs_ToBeReleased_SgNBRelReqd_Item(E_RABs_ToBeReleased_SgNBRelReqd_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeReleased_SgNBRelReqdList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeReleased_SgNBRelReqdList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeSetup_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 171)]
    Id_BearerType(BearerType),
    #[asn(key = 363)]
    Id_DAPSRequestInfo(DAPSRequestInfo),
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 435)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeSetup_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeSetup_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeSetup_ItemIE_Extensions(pub Vec<E_RABs_ToBeSetup_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeSetup_List_EntryValue {
    #[asn(key = 4)]
    Id_E_RABs_ToBeSetup_Item(E_RABs_ToBeSetup_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeSetup_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeSetup_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeSetup_ListRetrieve_EntryValue {
    #[asn(key = 174)]
    Id_E_RABs_ToBeSetupRetrieve_Item(E_RABs_ToBeSetupRetrieve_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeSetup_ListRetrieve_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABs_ToBeSetup_ListRetrieve_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABs_ToBeSetupRetrieve_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 369)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 435)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 412)]
    Id_SourceDLForwardingIPAddress(TransportLayerAddress),
    #[asn(key = 306)]
    Id_dL_Forwarding(DL_Forwarding),
    #[asn(key = 185)]
    Id_uL_GTPtunnelEndpoint(GTPtunnelEndpoint),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABs_ToBeSetupRetrieve_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: E_RABs_ToBeSetupRetrieve_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABs_ToBeSetupRetrieve_ItemIE_Extensions(
    pub Vec<E_RABs_ToBeSetupRetrieve_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABsSubjectToDLDiscarding_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABsSubjectToDLDiscarding_ItemIE_Extension(
    pub Vec<E_RABsSubjectToDLDiscarding_ItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABsSubjectToEarlyStatusTransfer_ItemIE_Extension(
    pub Vec<E_RABsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ECGIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ECGIIE_Extensions(pub Vec<ECGIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EN_DC_ResourceConfigurationPDCPatSgNB(pub u8);
impl EN_DC_ResourceConfigurationPDCPatSgNB {
    pub const PRESENT: u8 = 0u8;
    pub const NOT_PRESENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EN_DC_ResourceConfigurationMCGresources(pub u8);
impl EN_DC_ResourceConfigurationMCGresources {
    pub const PRESENT: u8 = 0u8;
    pub const NOT_PRESENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EN_DC_ResourceConfigurationSCGresources(pub u8);
impl EN_DC_ResourceConfigurationSCGresources {
    pub const PRESENT: u8 = 0u8;
    pub const NOT_PRESENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DC_ResourceConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DC_ResourceConfigurationIE_Extensions(
    pub Vec<EN_DC_ResourceConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ENB_ID_macro_eNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct ENB_ID_home_eNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct ENB_ID_short_Macro_eNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct ENB_ID_long_Macro_eNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 143)]
    Id_CoverageModificationList(CoverageModificationList),
    #[asn(key = 34)]
    Id_GUGroupIDToAddList(GUGroupIDList),
    #[asn(key = 35)]
    Id_GUGroupIDToDeleteList(GUGroupIDList),
    #[asn(key = 25)]
    Id_ServedCellsToAdd(ServedCells),
    #[asn(key = 27)]
    Id_ServedCellsToDelete(Old_ECGIs),
    #[asn(key = 26)]
    Id_ServedCellsToModify(ServedCellsToModify),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateProtocolIEs(pub Vec<ENBConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 22)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateFailureProtocolIEs(
    pub Vec<ENBConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCCellActivationFailureProtocolIEs_EntryValue {
    #[asn(key = 256)]
    Id_ActivationID(ActivationID),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCCellActivationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCCellActivationFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCCellActivationFailureProtocolIEs(
    pub Vec<ENDCCellActivationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCCellActivationRequestProtocolIEs_EntryValue {
    #[asn(key = 256)]
    Id_ActivationID(ActivationID),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 267)]
    Id_ServedNRCellsToActivate(ServedNRCellsToActivate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCCellActivationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCCellActivationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCCellActivationRequestProtocolIEs(
    pub Vec<ENDCCellActivationRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCCellActivationResponseProtocolIEs_EntryValue {
    #[asn(key = 268)]
    Id_ActivatedNRCellList(ActivatedNRCellList),
    #[asn(key = 256)]
    Id_ActivationID(ActivationID),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCCellActivationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCCellActivationResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCCellActivationResponseProtocolIEs(
    pub Vec<ENDCCellActivationResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 326)]
    Id_endcSONConfigurationTransfer(EndcSONConfigurationTransfer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCConfigurationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCConfigurationTransferProtocolIEs(
    pub Vec<ENDCConfigurationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 245)]
    Id_InitiatingNodeType_EndcConfigUpdate(InitiatingNodeType_EndcConfigUpdate),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 353)]
    Id_TNLA_To_Add_List(TNLA_To_Add_List),
    #[asn(key = 355)]
    Id_TNLA_To_Remove_List(TNLA_To_Remove_List),
    #[asn(key = 354)]
    Id_TNLA_To_Update_List(TNLA_To_Update_List),
    #[asn(key = 352)]
    Id_TNLConfigurationInfo(TNLConfigurationInfo),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCConfigurationUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCConfigurationUpdateProtocolIEs(pub Vec<ENDCConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 247)]
    Id_RespondingNodeType_EndcConfigUpdate(RespondingNodeType_EndcConfigUpdate),
    #[asn(key = 357)]
    Id_TNLA_Failed_To_Setup_List(TNLA_Failed_To_Setup_List),
    #[asn(key = 356)]
    Id_TNLA_Setup_List(TNLA_Setup_List),
    #[asn(key = 352)]
    Id_TNLConfigurationInfo(TNLConfigurationInfo),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<ENDCConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 22)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCConfigurationUpdateFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCConfigurationUpdateFailureProtocolIEs(
    pub Vec<ENDCConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCPartialResetConfirmProtocolIEs_EntryValue {
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 271)]
    Id_UEs_Admitted_ToBeReset(UEsToBeResetList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCPartialResetConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCPartialResetConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCPartialResetConfirmProtocolIEs(pub Vec<ENDCPartialResetConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCPartialResetRequiredProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 270)]
    Id_UEs_ToBeReset(UEsToBeResetList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCPartialResetRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCPartialResetRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCPartialResetRequiredProtocolIEs(pub Vec<ENDCPartialResetRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCResourceStatusFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 383)]
    Id_E_UTRAN_Node1_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 384)]
    Id_E_UTRAN_Node2_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCResourceStatusFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCResourceStatusFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCResourceStatusFailureProtocolIEs(
    pub Vec<ENDCResourceStatusFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCResourceStatusRequestProtocolIEs_EntryValue {
    #[asn(key = 403)]
    Id_CellToReport_E_UTRA_ENDC(CellToReport_E_UTRA_ENDC_List),
    #[asn(key = 391)]
    Id_CellToReport_NR_ENDC(CellToReport_NR_ENDC_List),
    #[asn(key = 383)]
    Id_E_UTRAN_Node1_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 384)]
    Id_E_UTRAN_Node2_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 28)]
    Id_Registration_Request(Registration_Request_ENDC),
    #[asn(key = 38)]
    Id_ReportCharacteristics(ReportCharacteristics_ENDC),
    #[asn(key = 30)]
    Id_ReportingPeriodicity(ReportingPeriodicity_ENDC),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCResourceStatusRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCResourceStatusRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCResourceStatusRequestProtocolIEs(
    pub Vec<ENDCResourceStatusRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCResourceStatusResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 383)]
    Id_E_UTRAN_Node1_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 384)]
    Id_E_UTRAN_Node2_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCResourceStatusResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCResourceStatusResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCResourceStatusResponseProtocolIEs(
    pub Vec<ENDCResourceStatusResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCResourceStatusUpdateProtocolIEs_EntryValue {
    #[asn(key = 401)]
    Id_CellMeasurementResult_E_UTRA_ENDC(CellMeasurementResult_E_UTRA_ENDC_List),
    #[asn(key = 393)]
    Id_CellMeasurementResult_NR_ENDC(CellMeasurementResult_NR_ENDC_List),
    #[asn(key = 383)]
    Id_E_UTRAN_Node1_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 384)]
    Id_E_UTRAN_Node2_Measurement_ID(Measurement_ID_ENDC),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCResourceStatusUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCResourceStatusUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCResourceStatusUpdateProtocolIEs(pub Vec<ENDCResourceStatusUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2RemovalFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2RemovalFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2RemovalFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2RemovalFailureProtocolIEs(pub Vec<ENDCX2RemovalFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2RemovalRequestProtocolIEs_EntryValue {
    #[asn(key = 298)]
    Id_InitiatingNodeType_EndcX2Removal(InitiatingNodeType_EndcX2Removal),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2RemovalRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2RemovalRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2RemovalRequestProtocolIEs(pub Vec<ENDCX2RemovalRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2RemovalResponseProtocolIEs_EntryValue {
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 299)]
    Id_RespondingNodeType_EndcX2Removal(RespondingNodeType_EndcX2Removal),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2RemovalResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2RemovalResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2RemovalResponseProtocolIEs(pub Vec<ENDCX2RemovalResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2SetupFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 350)]
    Id_MessageOversizeNotification(MessageOversizeNotification),
    #[asn(key = 22)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2SetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2SetupFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2SetupFailureProtocolIEs(pub Vec<ENDCX2SetupFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2SetupRequestProtocolIEs_EntryValue {
    #[asn(key = 244)]
    Id_InitiatingNodeType_EndcX2Setup(InitiatingNodeType_EndcX2Setup),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 352)]
    Id_TNLConfigurationInfo(TNLConfigurationInfo),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2SetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2SetupRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2SetupRequestProtocolIEs(pub Vec<ENDCX2SetupRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ENDCX2SetupResponseProtocolIEs_EntryValue {
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 246)]
    Id_RespondingNodeType_EndcX2Setup(RespondingNodeType_EndcX2Setup),
    #[asn(key = 352)]
    Id_TNLConfigurationInfo(TNLConfigurationInfo),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENDCX2SetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENDCX2SetupResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENDCX2SetupResponseProtocolIEs(pub Vec<ENDCX2SetupResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ERABActivityNotifyItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ERABActivityNotifyItemIE_Extensions(pub Vec<ERABActivityNotifyItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum EUTRANRCellResourceCoordinationRequestProtocolIEs_EntryValue {
    #[asn(key = 285)]
    Id_InitiatingNodeType_EutranrCellResourceCoordination(
        InitiatingNodeType_EutranrCellResourceCoordination,
    ),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRANRCellResourceCoordinationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: EUTRANRCellResourceCoordinationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct EUTRANRCellResourceCoordinationRequestProtocolIEs(
    pub Vec<EUTRANRCellResourceCoordinationRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum EUTRANRCellResourceCoordinationResponseProtocolIEs_EntryValue {
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 286)]
    Id_RespondingNodeType_EutranrCellResourceCoordination(
        RespondingNodeType_EutranrCellResourceCoordination,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRANRCellResourceCoordinationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: EUTRANRCellResourceCoordinationResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct EUTRANRCellResourceCoordinationResponseProtocolIEs(
    pub Vec<EUTRANRCellResourceCoordinationResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum EarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 367)]
    Id_ProcedureStage(ProcedureStageChoice),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: EarlyStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct EarlyStatusTransferProtocolIEs(pub Vec<EarlyStatusTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "12", sz_ub = "8800")]
pub struct EnhancedRNTPEnhancedRNTPBitmap(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EnhancedRNTPIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EnhancedRNTPIE_Extensions(pub Vec<EnhancedRNTPIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023", extensible = true)]
pub struct EnhancedRNTPStartTimeStartSFN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct EnhancedRNTPStartTimeStartSubframeNumber(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EnhancedRNTPStartTimeIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EnhancedRNTPStartTimeIE_Extensions(pub Vec<EnhancedRNTPStartTimeIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ErrorIndicationProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 264)]
    Id_Old_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ErrorIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ErrorIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ErrorIndicationProtocolIEs(pub Vec<ErrorIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEActivityBehaviourIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEActivityBehaviourIE_Extensions(
    pub Vec<ExpectedUEActivityBehaviourIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEBehaviourIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEBehaviourIE_Extensions(pub Vec<ExpectedUEBehaviourIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct ExtendedULInterferenceOverloadInfoAssociatedSubframes(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExtendedULInterferenceOverloadInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExtendedULInterferenceOverloadInfoIE_Extensions(
    pub Vec<ExtendedULInterferenceOverloadInfoIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum F1CTrafficTransferProtocolIEs_EntryValue {
    #[asn(key = 397)]
    Id_F1CTrafficContainer(F1CTrafficContainer),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct F1CTrafficTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: F1CTrafficTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct F1CTrafficTransferProtocolIEs(pub Vec<F1CTrafficTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum FDD_InfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 96)]
    Id_DL_EARFCNExtension(EARFCNExtension),
    #[asn(key = 282)]
    Id_NRS_NSSS_PowerOffset(NRS_NSSS_PowerOffset),
    #[asn(key = 283)]
    Id_NSSS_NumOccasionDifferentPrecoder(NSSS_NumOccasionDifferentPrecoder),
    #[asn(key = 177)]
    Id_OffsetOfNbiotChannelNumberToDL_EARFCN(OffsetOfNbiotChannelNumberToEARFCN),
    #[asn(key = 178)]
    Id_OffsetOfNbiotChannelNumberToUL_EARFCN(OffsetOfNbiotChannelNumberToEARFCN),
    #[asn(key = 95)]
    Id_UL_EARFCNExtension(EARFCNExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FDD_InfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: FDD_InfoIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FDD_InfoIE_Extensions(pub Vec<FDD_InfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum FDD_InfoNeighbourServedNRCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 387)]
    Id_ULCarrierList(NRCarrierList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FDD_InfoNeighbourServedNRCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: FDD_InfoNeighbourServedNRCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FDD_InfoNeighbourServedNRCell_InformationIE_Extensions(
    pub Vec<FDD_InfoNeighbourServedNRCell_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum FDD_InfoServedNRCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 381)]
    Id_DLCarrierList(NRCarrierList),
    #[asn(key = 387)]
    Id_ULCarrierList(NRCarrierList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FDD_InfoServedNRCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: FDD_InfoServedNRCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FDD_InfoServedNRCell_InformationIE_Extensions(
    pub Vec<FDD_InfoServedNRCell_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FastMCGRecoveryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FastMCGRecoveryIE_Extensions(pub Vec<FastMCGRecoveryIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FirstDLCountIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FirstDLCountIE_Extension(pub Vec<FirstDLCountIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenLAs_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenLAs_ItemIE_Extensions(pub Vec<ForbiddenLAs_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenTAs_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenTAs_ItemIE_Extensions(pub Vec<ForbiddenTAs_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024", extensible = true)]
pub struct FreqBandNrItemFreqBandIndicatorNr(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "32")]
pub struct FreqBandNrItemSupportedSULBandList(pub Vec<SupportedSULFreqBandItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqBandNrItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FreqBandNrItemIE_Extensions(pub Vec<FreqBandNrItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum GBR_QosInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 198)]
    Id_extended_e_RAB_GuaranteedBitrateDL(ExtendedBitRate),
    #[asn(key = 199)]
    Id_extended_e_RAB_GuaranteedBitrateUL(ExtendedBitRate),
    #[asn(key = 196)]
    Id_extended_e_RAB_MaximumBitrateDL(ExtendedBitRate),
    #[asn(key = 197)]
    Id_extended_e_RAB_MaximumBitrateUL(ExtendedBitRate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GBR_QosInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GBR_QosInformationIE_Extensions(pub Vec<GBR_QosInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "32")]
pub struct GNB_ID_gNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum GNBStatusIndicationProtocolIEs_EntryValue {
    #[asn(key = 310)]
    Id_GNBOverloadInformation(GNBOverloadInformation),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GNBStatusIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: GNBStatusIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct GNBStatusIndicationProtocolIEs(pub Vec<GNBStatusIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GTPTLA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GTPTLA_ItemIE_Extensions(pub Vec<GTPTLA_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum GTPtunnelEndpointIE_Extensions_EntryExtensionValue {
    #[asn(key = 396)]
    Id_QoS_Mapping_Information(QoS_Mapping_Information),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GTPtunnelEndpointIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: GTPtunnelEndpointIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GTPtunnelEndpointIE_Extensions(pub Vec<GTPtunnelEndpointIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GU_Group_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GU_Group_IDIE_Extensions(pub Vec<GU_Group_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GUMMEIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GUMMEIIE_Extensions(pub Vec<GUMMEIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_RAN_NODE_ID_choice_extension {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalENB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalENB_IDIE_Extensions(pub Vec<GlobalENB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalGNB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalGNB_IDIE_Extensions(pub Vec<GlobalGNB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HWLoadIndicatorIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HWLoadIndicatorIE_Extensions(pub Vec<HWLoadIndicatorIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 365)]
    Id_CandidateCellsToBeCancelledList(CandidateCellsToBeCancelledList),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelProtocolIEs(pub Vec<HandoverCancelProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverPreparationFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 364)]
    Id_RequestedTargetCellID(ECGI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverPreparationFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverPreparationFailureProtocolIEs(
    pub Vec<HandoverPreparationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverReportProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 53)]
    Id_FailureCellECGI(ECGI),
    #[asn(key = 54)]
    Id_HandoverReportType(HandoverReportType),
    #[asn(key = 82)]
    Id_MobilityInformation(MobilityInformation),
    #[asn(key = 49)]
    Id_Re_establishmentCellECGI(ECGI),
    #[asn(key = 83)]
    Id_SourceCellCRNTI(CRNTI),
    #[asn(key = 52)]
    Id_SourceCellECGI(ECGI),
    #[asn(key = 382)]
    Id_TargetCellInNGRAN(TargetCellInNGRAN),
    #[asn(key = 81)]
    Id_TargetCellInUTRAN(TargetCellInUTRAN),
    #[asn(key = 60)]
    Id_UE_RLF_Report_Container(UE_RLF_Report_Container),
    #[asn(key = 107)]
    Id_UE_RLF_Report_Container_for_extended_bands(UE_RLF_Report_Container_for_extended_bands),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverReportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverReportProtocolIEs(pub Vec<HandoverReportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestProtocolIEs_EntryValue {
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 361)]
    Id_CHOinformation_REQ(CHOinformation_REQ),
    #[asn(key = 71)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 104)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 23)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 395)]
    Id_IABNodeIndication(IABNodeIndication),
    #[asn(key = 98)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 82)]
    Id_MobilityInformation(MobilityInformation),
    #[asn(key = 248)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 370)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 372)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 103)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 36)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 309)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 11)]
    Id_TargetCell_ID(ECGI),
    #[asn(key = 13)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 14)]
    Id_UE_ContextInformation(UE_ContextInformation),
    #[asn(key = 153)]
    Id_UE_ContextReferenceAtSeNB(UE_ContextReferenceAtSeNB),
    #[asn(key = 254)]
    Id_UE_ContextReferenceAtSgNB(UE_ContextReferenceAtSgNB),
    #[asn(key = 182)]
    Id_UE_ContextReferenceAtWT(UE_ContextReferenceAtWT),
    #[asn(key = 15)]
    Id_UE_HistoryInformation(UE_HistoryInformation),
    #[asn(key = 105)]
    Id_UE_HistoryInformationFromTheUE(UE_HistoryInformationFromTheUE),
    #[asn(key = 176)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestProtocolIEs(pub Vec<HandoverRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 362)]
    Id_CHOinformation_ACK(CHOinformation_ACK),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 1)]
    Id_E_RABs_Admitted_List(E_RABs_Admitted_List),
    #[asn(key = 3)]
    Id_E_RABs_NotAdmitted_List(E_RAB_List),
    #[asn(key = 339)]
    Id_ERABs_transferred_to_MeNB(E_RAB_List),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 12)]
    Id_TargeteNBtoSource_eNBTransparentContainer(TargeteNBtoSource_eNBTransparentContainer),
    #[asn(key = 154)]
    Id_UE_ContextKeptIndicator(UE_ContextKeptIndicator),
    #[asn(key = 183)]
    Id_WT_UE_ContextKeptIndicator(UE_ContextKeptIndicator),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeProtocolIEs(
    pub Vec<HandoverRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRestrictionListIE_Extensions_EntryExtensionValue {
    #[asn(key = 301)]
    Id_CNTypeRestrictions(CNTypeRestrictions),
    #[asn(key = 332)]
    Id_LastNG_RANPLMNIdentity(PLMN_Identity),
    #[asn(key = 305)]
    Id_NRrestrictionin5GS(NRrestrictionin5GS),
    #[asn(key = 202)]
    Id_NRrestrictioninEPSasSecondaryRAT(NRrestrictioninEPSasSecondaryRAT),
    #[asn(key = 437)]
    Id_RAT_Restrictions(RAT_Restrictions),
    #[asn(key = 358)]
    Id_UnlicensedSpectrumRestriction(UnlicensedSpectrumRestriction),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRestrictionListIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: HandoverRestrictionListIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRestrictionListIE_Extensions(
    pub Vec<HandoverRestrictionListIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverSuccessProtocolIEs_EntryValue {
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 11)]
    Id_TargetCell_ID(ECGI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverSuccessProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverSuccessProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverSuccessProtocolIEs(pub Vec<HandoverSuccessProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingMessageValue {
    #[asn(key = 59)]
    Id_CPC_cancel(CPC_cancel),
    #[asn(key = 42)]
    Id_SgNBActivityNotification(SgNBActivityNotification),
    #[asn(key = 56)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingRequest),
    #[asn(key = 57)]
    Id_accessAndMobilityIndication(AccessAndMobilityIndication),
    #[asn(key = 15)]
    Id_cellActivation(CellActivationRequest),
    #[asn(key = 52)]
    Id_cellTrafficTrace(CellTrafficTrace),
    #[asn(key = 50)]
    Id_conditionalHandoverCancel(ConditionalHandoverCancel),
    #[asn(key = 44)]
    Id_dataForwardingAddressIndication(DataForwardingAddressIndication),
    #[asn(key = 46)]
    Id_deactivateTrace(DeactivateTrace),
    #[asn(key = 8)]
    Id_eNBConfigurationUpdate(ENBConfigurationUpdate),
    #[asn(key = 41)]
    Id_eUTRANRCellResourceCoordination(EUTRANRCellResourceCoordinationRequest),
    #[asn(key = 51)]
    Id_earlyStatusTransfer(EarlyStatusTransfer),
    #[asn(key = 39)]
    Id_endcCellActivation(ENDCCellActivationRequest),
    #[asn(key = 48)]
    Id_endcConfigurationTransfer(ENDCConfigurationTransfer),
    #[asn(key = 37)]
    Id_endcConfigurationUpdate(ENDCConfigurationUpdate),
    #[asn(key = 40)]
    Id_endcPartialReset(ENDCPartialResetRequired),
    #[asn(key = 43)]
    Id_endcX2Removal(ENDCX2RemovalRequest),
    #[asn(key = 36)]
    Id_endcX2Setup(ENDCX2SetupRequest),
    #[asn(key = 53)]
    Id_endcresourceStatusReporting(ENDCResourceStatusUpdate),
    #[asn(key = 54)]
    Id_endcresourceStatusReportingInitiation(ENDCResourceStatusRequest),
    #[asn(key = 3)]
    Id_errorIndication(ErrorIndication),
    #[asn(key = 55)]
    Id_f1CTrafficTransfer(F1CTrafficTransfer),
    #[asn(key = 45)]
    Id_gNBStatusIndication(GNBStatusIndication),
    #[asn(key = 1)]
    Id_handoverCancel(HandoverCancel),
    #[asn(key = 0)]
    Id_handoverPreparation(HandoverRequest),
    #[asn(key = 14)]
    Id_handoverReport(HandoverReport),
    #[asn(key = 49)]
    Id_handoverSuccess(HandoverSuccess),
    #[asn(key = 2)]
    Id_loadIndication(LoadInformation),
    #[asn(key = 21)]
    Id_meNBinitiatedSeNBModificationPreparation(SeNBModificationRequest),
    #[asn(key = 23)]
    Id_meNBinitiatedSeNBRelease(SeNBReleaseRequest),
    #[asn(key = 29)]
    Id_meNBinitiatedSgNBModificationPreparation(SgNBModificationRequest),
    #[asn(key = 31)]
    Id_meNBinitiatedSgNBRelease(SgNBReleaseRequest),
    #[asn(key = 12)]
    Id_mobilitySettingsChange(MobilityChangeRequest),
    #[asn(key = 11)]
    Id_privateMessage(PrivateMessage),
    #[asn(key = 13)]
    Id_rLFIndication(RLFIndication),
    #[asn(key = 35)]
    Id_rRCTransfer(RRCTransfer),
    #[asn(key = 60)]
    Id_rachIndication(RachIndication),
    #[asn(key = 7)]
    Id_reset(ResetRequest),
    #[asn(key = 10)]
    Id_resourceStatusReporting(ResourceStatusUpdate),
    #[asn(key = 9)]
    Id_resourceStatusReportingInitiation(ResourceStatusRequest),
    #[asn(key = 26)]
    Id_retrieveUEContext(RetrieveUEContextRequest),
    #[asn(key = 19)]
    Id_seNBAdditionPreparation(SeNBAdditionRequest),
    #[asn(key = 25)]
    Id_seNBCounterCheck(SeNBCounterCheckRequest),
    #[asn(key = 20)]
    Id_seNBReconfigurationCompletion(SeNBReconfigurationComplete),
    #[asn(key = 22)]
    Id_seNBinitiatedSeNBModification(SeNBModificationRequired),
    #[asn(key = 24)]
    Id_seNBinitiatedSeNBRelease(SeNBReleaseRequired),
    #[asn(key = 38)]
    Id_secondaryRATDataUsageReport(SecondaryRATDataUsageReport),
    #[asn(key = 27)]
    Id_sgNBAdditionPreparation(SgNBAdditionRequest),
    #[asn(key = 34)]
    Id_sgNBChange(SgNBChangeRequired),
    #[asn(key = 33)]
    Id_sgNBCounterCheck(SgNBCounterCheckRequest),
    #[asn(key = 28)]
    Id_sgNBReconfigurationCompletion(SgNBReconfigurationComplete),
    #[asn(key = 30)]
    Id_sgNBinitiatedSgNBModification(SgNBModificationRequired),
    #[asn(key = 32)]
    Id_sgNBinitiatedSgNBRelease(SgNBReleaseRequired),
    #[asn(key = 4)]
    Id_snStatusTransfer(SNStatusTransfer),
    #[asn(key = 47)]
    Id_traceStart(TraceStart),
    #[asn(key = 5)]
    Id_uEContextRelease(UEContextRelease),
    #[asn(key = 17)]
    Id_x2APMessageTransfer(X2APMessageTransfer),
    #[asn(key = 16)]
    Id_x2Release(X2Release),
    #[asn(key = 18)]
    Id_x2Removal(X2RemovalRequest),
    #[asn(key = 6)]
    Id_x2Setup(X2SetupRequest),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcConfigUpdate_init_eNB_EntryValue {
    #[asn(key = 251)]
    Id_CellAssistanceInformation(CellAssistanceInformation),
    #[asn(key = 250)]
    Id_ServedEUTRAcellsENDCX2ManagementList(ServedEUTRAcellsENDCX2ManagementList),
    #[asn(key = 260)]
    Id_ServedEUTRAcellsToDeleteListENDCConfUpd(ServedEUTRAcellsToDeleteListENDCConfUpd),
    #[asn(key = 259)]
    Id_ServedEUTRAcellsToModifyListENDCConfUpd(ServedEUTRAcellsToModifyListENDCConfUpd),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcConfigUpdate_init_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcConfigUpdate_init_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcConfigUpdate_init_eNB(
    pub Vec<InitiatingNodeType_EndcConfigUpdate_init_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcConfigUpdate_init_en_gNB_EntryValue {
    #[asn(key = 253)]
    Id_ServedNRcellsENDCX2ManagementList(ServedNRcellsENDCX2ManagementList),
    #[asn(key = 262)]
    Id_ServedNRcellsToDeleteListENDCConfUpd(ServedNRcellsToDeleteENDCConfUpdList),
    #[asn(key = 261)]
    Id_ServedNRcellsToModifyListENDCConfUpd(ServedNRcellsToModifyENDCConfUpdList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcConfigUpdate_init_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcConfigUpdate_init_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcConfigUpdate_init_en_gNB(
    pub Vec<InitiatingNodeType_EndcConfigUpdate_init_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcX2Removal_init_eNB_EntryValue {
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcX2Removal_init_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcX2Removal_init_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcX2Removal_init_eNB(
    pub Vec<InitiatingNodeType_EndcX2Removal_init_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcX2Removal_init_en_gNB_EntryValue {
    #[asn(key = 252)]
    Id_Globalen_gNB_ID(GlobalGNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcX2Removal_init_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcX2Removal_init_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcX2Removal_init_en_gNB(
    pub Vec<InitiatingNodeType_EndcX2Removal_init_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcX2Setup_init_eNB_EntryValue {
    #[asn(key = 351)]
    Id_CellandCapacityAssistInfo(CellandCapacityAssistInfo),
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 250)]
    Id_ServedEUTRAcellsENDCX2ManagementList(ServedEUTRAcellsENDCX2ManagementList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcX2Setup_init_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcX2Setup_init_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcX2Setup_init_eNB(
    pub Vec<InitiatingNodeType_EndcX2Setup_init_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EndcX2Setup_init_en_gNB_EntryValue {
    #[asn(key = 252)]
    Id_Globalen_gNB_ID(GlobalGNB_ID),
    #[asn(key = 348)]
    Id_PartialListIndicator(PartialListIndicator),
    #[asn(key = 253)]
    Id_ServedNRcellsENDCX2ManagementList(ServedNRcellsENDCX2ManagementList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EndcX2Setup_init_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EndcX2Setup_init_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EndcX2Setup_init_en_gNB(
    pub Vec<InitiatingNodeType_EndcX2Setup_init_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB_EntryValue {
    #[asn(key = 287)]
    Id_DataTrafficResourceIndication(DataTrafficResourceIndication),
    #[asn(key = 289)]
    Id_ListofEUTRACellsinEUTRACoordinationReq(ListofEUTRACellsinEUTRACoordinationReq),
    #[asn(key = 288)]
    Id_SpectrumSharingGroupID(SpectrumSharingGroupID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB(
    pub Vec<InitiatingNodeType_EutranrCellResourceCoordination_initiate_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB_EntryValue {
    #[asn(key = 287)]
    Id_DataTrafficResourceIndication(DataTrafficResourceIndication),
    #[asn(key = 291)]
    Id_ListofEUTRACellsinNRCoordinationReq(ListofEUTRACellsinNRCoordinationReq),
    #[asn(key = 292)]
    Id_ListofNRCellsinNRCoordinationReq(ListofNRCellsinNRCoordinationReq),
    #[asn(key = 288)]
    Id_SpectrumSharingGroupID(SpectrumSharingGroupID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB(
    pub Vec<InitiatingNodeType_EutranrCellResourceCoordination_initiate_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 80)]
    Id_HO_cause(Cause),
    #[asn(key = 418)]
    Id_PSCell_UE_HistoryInformation(PSCell_UE_HistoryInformation),
    #[asn(key = 77)]
    Id_Time_UE_StayedInCell_EnhancedGranularity(Time_UE_StayedInCell_EnhancedGranularity),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions(
    pub Vec<LastVisitedEUTRANCellInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct LastVisitedGERANCellInformation_undefined;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Limited_list_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Limited_list_EntryIE_Extensions(pub Vec<Limited_list_EntryIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Limited_list_Entry {
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Limited_list_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LoadInformationProtocolIEs_EntryValue {
    #[asn(key = 6)]
    Id_CellInformation(CellInformation_List),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoadInformationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LoadInformationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LoadInformationProtocolIEs(pub Vec<LoadInformationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationInformationSgNBIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LocationInformationSgNBIE_Extensions(
    pub Vec<LocationInformationSgNBIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 409)]
    Id_AdditionLocationInformation(AdditionLocationInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: LocationReportingInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LocationReportingInformationIE_Extensions(
    pub Vec<LocationReportingInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1PeriodicReportingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1PeriodicReportingIE_Extensions(pub Vec<M1PeriodicReportingIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdEventA2IE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ThresholdEventA2IE_Extensions(pub Vec<M1ThresholdEventA2IE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M3ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M3ConfigurationIE_Extensions(pub Vec<M3ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum M4ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 442)]
    Id_M4ReportAmount(M4ReportAmountMDT),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M4ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: M4ConfigurationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M4ConfigurationIE_Extensions(pub Vec<M4ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum M5ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 443)]
    Id_M5ReportAmount(M5ReportAmountMDT),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M5ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: M5ConfigurationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M5ConfigurationIE_Extensions(pub Vec<M5ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum M6ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 444)]
    Id_M6ReportAmount(M6ReportAmountMDT),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M6ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: M6ConfigurationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M6ConfigurationIE_Extensions(pub Vec<M6ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum M7ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 445)]
    Id_M7ReportAmount(M7ReportAmountMDT),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M7ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: M7ConfigurationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M7ConfigurationIE_Extensions(pub Vec<M7ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_Subframe_InfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MBSFN_Subframe_InfoIE_Extensions(pub Vec<MBSFN_Subframe_InfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MDT_ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 303)]
    Id_BluetoothMeasurementConfiguration(BluetoothMeasurementConfiguration),
    #[asn(key = 85)]
    Id_M3Configuration(M3Configuration),
    #[asn(key = 86)]
    Id_M4Configuration(M4Configuration),
    #[asn(key = 87)]
    Id_M5Configuration(M5Configuration),
    #[asn(key = 161)]
    Id_M6Configuration(M6Configuration),
    #[asn(key = 162)]
    Id_M7Configuration(M7Configuration),
    #[asn(key = 88)]
    Id_MDT_Location_Info(MDT_Location_Info),
    #[asn(key = 440)]
    Id_SensorMeasurementConfiguration(SensorMeasurementConfiguration),
    #[asn(key = 90)]
    Id_SignallingBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 304)]
    Id_WLANMeasurementConfiguration(WLANMeasurementConfiguration),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: MDT_ConfigurationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_ConfigurationIE_Extensions(pub Vec<MDT_ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MIMOPRBusageInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MIMOPRBusageInformationIE_Extensions(
    pub Vec<MIMOPRBusageInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "4400")]
pub struct MeNBResourceCoordinationInformationULCoordinationInformation(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "4400")]
pub struct MeNBResourceCoordinationInformationDLCoordinationInformation(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MeNBResourceCoordinationInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 323)]
    Id_MeNBCoordinationAssistanceInformation(MeNBCoordinationAssistanceInformation),
    #[asn(key = 322)]
    Id_NRCGI(NRCGI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeNBResourceCoordinationInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: MeNBResourceCoordinationInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MeNBResourceCoordinationInformationIE_Extensions(
    pub Vec<MeNBResourceCoordinationInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementFailureCause_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MeasurementFailureCause_ItemIE_Extensions(
    pub Vec<MeasurementFailureCause_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MeasurementFailureCause_List_EntryValue {
    #[asn(key = 67)]
    Id_MeasurementFailureCause_Item(MeasurementFailureCause_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementFailureCause_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MeasurementFailureCause_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementInitiationResult_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MeasurementInitiationResult_ItemIE_Extensions(
    pub Vec<MeasurementInitiationResult_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MeasurementInitiationResult_List_EntryValue {
    #[asn(key = 66)]
    Id_MeasurementInitiationResult_Item(MeasurementInitiationResult_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementInitiationResult_List_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MeasurementInitiationResult_List_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementResultforNRCellsPossiblyAggregated_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MeasurementResultforNRCellsPossiblyAggregated_ItemIE_Extension(
    pub Vec<MeasurementResultforNRCellsPossiblyAggregated_ItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MessageOversizeNotificationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MessageOversizeNotificationIE_Extensions(
    pub Vec<MessageOversizeNotificationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MobilityChangeAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 43)]
    Id_ENB1_Cell_ID(ECGI),
    #[asn(key = 44)]
    Id_ENB2_Cell_ID(ECGI),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityChangeAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MobilityChangeAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MobilityChangeAcknowledgeProtocolIEs(
    pub Vec<MobilityChangeAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MobilityChangeFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 43)]
    Id_ENB1_Cell_ID(ECGI),
    #[asn(key = 44)]
    Id_ENB2_Cell_ID(ECGI),
    #[asn(key = 47)]
    Id_ENB2_Mobility_Parameters_Modification_Range(MobilityParametersModificationRange),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityChangeFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MobilityChangeFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MobilityChangeFailureProtocolIEs(pub Vec<MobilityChangeFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MobilityChangeRequestProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 43)]
    Id_ENB1_Cell_ID(ECGI),
    #[asn(key = 46)]
    Id_ENB1_Mobility_Parameters(MobilityParametersInformation),
    #[asn(key = 44)]
    Id_ENB2_Cell_ID(ECGI),
    #[asn(key = 45)]
    Id_ENB2_Proposed_Mobility_Parameters(MobilityParametersInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityChangeRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MobilityChangeRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MobilityChangeRequestProtocolIEs(pub Vec<MobilityChangeRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "-20", ub = "20")]
pub struct MobilityParametersInformationHandoverTriggerChange(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "-20", ub = "20")]
pub struct MobilityParametersModificationRangeHandoverTriggerChangeLowerLimit(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "-20", ub = "20")]
pub struct MobilityParametersModificationRangeHandoverTriggerChangeUpperLimit(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum NPRACHConfigurationFdd_or_tdd {
    #[asn(key = 0, extended = false)]
    Fdd(NPRACHConfiguration_FDD),
    #[asn(key = 1, extended = false)]
    Tdd(NPRACHConfiguration_TDD),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPRACHConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NPRACHConfigurationIE_Extensions(pub Vec<NPRACHConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDAnchorCarrier_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDAnchorCarrier_EDT_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDAnchorCarrier_Format2_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDAnchorCarrier_Format2_EDT_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDNon_anchorCarrier_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_FDDNon_anchorCarrier_Format2_NPRACHConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPRACHConfiguration_FDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NPRACHConfiguration_FDDIE_Extensions(
    pub Vec<NPRACHConfiguration_FDDIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_TDDAnchorCarrier_NPRACHConfigTDD(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NPRACHConfiguration_TDDNon_anchorCarrier_NPRACHConfigTDD(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPRACHConfiguration_TDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NPRACHConfiguration_TDDIE_Extensions(
    pub Vec<NPRACHConfiguration_TDDIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NR_TxBWIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_TxBWIE_Extensions(pub Vec<NR_TxBWIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRCGIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRCGIIE_Extensions(pub Vec<NRCGIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct NRCapacityValueCapacityValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRCapacityValueIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRCapacityValueIE_Extensions(pub Vec<NRCapacityValueIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2199", extensible = true)]
pub struct NRCarrierItemOffsetToCarrier(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "275", extensible = true)]
pub struct NRCarrierItemCarrierBandwidth(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRCarrierItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRCarrierItemIE_Extension(pub Vec<NRCarrierItemIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRCompositeAvailableCapacityIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRCompositeAvailableCapacityIE_Extensions(
    pub Vec<NRCompositeAvailableCapacityIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRCompositeAvailableCapacityGroupIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRCompositeAvailableCapacityGroupIE_Extensions(
    pub Vec<NRCompositeAvailableCapacityGroupIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct NRFreqInfoNRARFCN(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct NRFreqInfoFreqBandListNr(pub Vec<FreqBandNrItem>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NRFreqInfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 388)]
    Id_FrequencyShift7p5khz(FrequencyShift7p5khz),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRFreqInfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: NRFreqInfoIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRFreqInfoIE_Extensions(pub Vec<NRFreqInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRNeighbour_Information_EntryMeasurementTimingConfiguration(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum NRNeighbour_Information_EntryNRNeighbourModeInfo {
    #[asn(key = 0, extended = false)]
    Fdd(FDD_InfoNeighbourServedNRCell_Information),
    #[asn(key = 1, extended = false)]
    Tdd(TDD_InfoNeighbourServedNRCell_Information),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NRNeighbour_Information_EntryIE_Extensions_EntryExtensionValue {
    #[asn(key = 433)]
    Id_Additional_Measurement_Timing_Configuration_List(
        Additional_Measurement_Timing_Configuration_List,
    ),
    #[asn(key = 380)]
    Id_CSI_RSTransmissionIndication(CSI_RSTransmissionIndication),
    #[asn(key = 390)]
    Id_NRCellPRACHConfig(NRCellPRACHConfig),
    #[asn(key = 389)]
    Id_SSB_PositionsInBurst(SSB_PositionsInBurst),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRNeighbour_Information_EntryIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: NRNeighbour_Information_EntryIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRNeighbour_Information_EntryIE_Extensions(
    pub Vec<NRNeighbour_Information_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRNeighbour_Information_Entry {
    pub nrp_ci: NRPCI,
    pub nr_cell_id: NRCGI,
    #[asn(optional_idx = 0)]
    pub five_gs_tac: Option<FiveGS_TAC>,
    #[asn(optional_idx = 1)]
    pub configured_tac: Option<TAC>,
    pub measurement_timing_configuration:
        NRNeighbour_Information_EntryMeasurementTimingConfiguration,
    pub nr_neighbour_mode_info: NRNeighbour_Information_EntryNRNeighbourModeInfo,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRNeighbour_Information_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NRRAReportList_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 448)]
    Id_PSCellListContainer(PSCellListContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRRAReportList_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: NRRAReportList_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRRAReportList_ItemIE_Extensions(pub Vec<NRRAReportList_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NRRadioResourceStatusIE_Extensions_EntryExtensionValue {
    #[asn(key = 439)]
    Id_MIMOPRBusageInformation(MIMOPRBusageInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRRadioResourceStatusIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: NRRadioResourceStatusIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRRadioResourceStatusIE_Extensions(pub Vec<NRRadioResourceStatusIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESecurityCapabilitiesIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESecurityCapabilitiesIE_Extensions(
    pub Vec<NRUESecurityCapabilitiesIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESidelinkAggregateMaximumBitRateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESidelinkAggregateMaximumBitRateIE_Extensions(
    pub Vec<NRUESidelinkAggregateMaximumBitRateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUeReportIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUeReportIE_Extensions(pub Vec<NRUeReportIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRV2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRV2XServicesAuthorizedIE_Extensions(
    pub Vec<NRV2XServicesAuthorizedIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum Neighbour_Information_EntryIE_Extensions_EntryExtensionValue {
    #[asn(key = 76)]
    Id_NeighbourTAC(TAC),
    #[asn(key = 94)]
    Id_eARFCNExtension(EARFCNExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Neighbour_Information_EntryIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: Neighbour_Information_EntryIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Neighbour_Information_EntryIE_Extensions(
    pub Vec<Neighbour_Information_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Neighbour_Information_Entry {
    pub ecgi: ECGI,
    pub pci: PCI,
    pub earfcn: EARFCN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Neighbour_Information_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Non_AnchorCarrierFrequencylist_EntryNon_anchorCarrioerFrquency(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Non_AnchorCarrierFrequencylist_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Non_AnchorCarrierFrequencylist_EntryIE_Extensions(
    pub Vec<Non_AnchorCarrierFrequencylist_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Non_AnchorCarrierFrequencylist_Entry {
    pub non_anchor_carrioer_frquency:
        Non_AnchorCarrierFrequencylist_EntryNon_anchorCarrioerFrquency,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Non_AnchorCarrierFrequencylist_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5FlowBitRatesIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5FlowBitRatesIE_Extensions(pub Vec<PC5FlowBitRatesIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSFlowItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSFlowItemIE_Extensions(pub Vec<PC5QoSFlowItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSParametersIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSParametersIE_Extensions(pub Vec<PC5QoSParametersIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMNAreaBasedQMCIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PLMNAreaBasedQMCIE_Extensions(pub Vec<PLMNAreaBasedQMCIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "837")]
pub struct PRACH_ConfigurationRootSequenceIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PRACH_ConfigurationZeroCorrelationIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PRACH_ConfigurationHighSpeedFlag(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_ConfigurationPrach_FreqOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct PRACH_ConfigurationPrach_ConfigIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PRACH_ConfigurationIE_Extensions(pub Vec<PRACH_ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct PrivateIE_ID_local(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OBJECT-IDENTIFIER")]
pub struct PrivateIE_ID_global(Vec<u32>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PrivateMessagePrivateIEs_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PrivateMessagePrivateIEs(pub Vec<PrivateMessagePrivateIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ProSeAuthorizedIE_Extensions_EntryExtensionValue {
    #[asn(key = 149)]
    Id_ProSeUEtoNetworkRelaying(ProSeUEtoNetworkRelaying),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProSeAuthorizedIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ProSeAuthorizedIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProSeAuthorizedIE_Extensions(pub Vec<ProSeAuthorizedIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProcedureStageChoice_choice_extension {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct ProtectedEUTRAResourceIndicationActivationSFN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct ProtectedEUTRAResourceIndicationMBSFNControlRegionLength(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct ProtectedEUTRAResourceIndicationPDCCHRegionLength(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProtectedEUTRAResourceIndicationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProtectedEUTRAResourceIndicationIE_Extensions(
    pub Vec<ProtectedEUTRAResourceIndicationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "320", extensible = true)]
pub struct ProtectedFootprintTimePatternProtectedFootprintTimePeriodicity(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "20", extensible = true)]
pub struct ProtectedFootprintTimePatternProtectedFootprintStartTime(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProtectedFootprintTimePatternIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProtectedFootprintTimePatternIE_Extensions(
    pub Vec<ProtectedFootprintTimePatternIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "84", sz_ub = "84")]
pub struct ProtectedResourceList_ItemIntraPRBProtectedResourceFootprint(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "110")]
pub struct ProtectedResourceList_ItemProtectedFootprintFrequencyPattern(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProtectedResourceList_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProtectedResourceList_ItemIE_Extensions(
    pub Vec<ProtectedResourceList_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct QoS_Mapping_InformationDscp(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct QoS_Mapping_InformationFlow_label(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QoS_Mapping_InformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QoS_Mapping_InformationIE_Extensions(
    pub Vec<QoS_Mapping_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct RAT_RestrictionsItemRAT_RestrictionInformation(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RAT_RestrictionsItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RAT_RestrictionsItemIE_Extensions(pub Vec<RAT_RestrictionsItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_StatusIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RLC_StatusIE_Extensions(pub Vec<RLC_StatusIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RLFIndicationProtocolIEs_EntryValue {
    #[asn(key = 50)]
    Id_FailureCellCRNTI(CRNTI),
    #[asn(key = 48)]
    Id_FailureCellPCI(PCI),
    #[asn(key = 374)]
    Id_NBIoT_RLF_Report_Container(NBIoT_RLF_Report_Container),
    #[asn(key = 78)]
    Id_RRCConnReestabIndicator(RRCConnReestabIndicator),
    #[asn(key = 75)]
    Id_RRCConnSetupIndicator(RRCConnSetupIndicator),
    #[asn(key = 49)]
    Id_Re_establishmentCellECGI(ECGI),
    #[asn(key = 51)]
    Id_ShortMAC_I(ShortMAC_I),
    #[asn(key = 60)]
    Id_UE_RLF_Report_Container(UE_RLF_Report_Container),
    #[asn(key = 107)]
    Id_UE_RLF_Report_Container_for_extended_bands(UE_RLF_Report_Container_for_extended_bands),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLFIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RLFIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RLFIndicationProtocolIEs(pub Vec<RLFIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNL_HeaderIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RNL_HeaderIE_Extensions(pub Vec<RNL_HeaderIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RRCTransferProtocolIEs_EntryValue {
    #[asn(key = 347)]
    Id_FastMCGRecovery_MN_to_SN(FastMCGRecovery),
    #[asn(key = 342)]
    Id_FastMCGRecovery_SN_to_MN(FastMCGRecovery),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 243)]
    Id_NRUeReport(NRUeReport),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 242)]
    Id_SplitSRB(SplitSRB),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RRCTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RRCTransferProtocolIEs(pub Vec<RRCTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RSRPMRList_EntryIE_Extensions_EntryExtensionValue {
    #[asn(key = 147)]
    Id_UEID(UEID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RSRPMRList_EntryIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: RSRPMRList_EntryIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RSRPMRList_EntryIE_Extensions(pub Vec<RSRPMRList_EntryIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RSRPMRList_Entry {
    pub rsrp_measurement_result: RSRPMeasurementResult,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RSRPMRList_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "97", extensible = true)]
pub struct RSRPMeasurementResult_EntryRSRPMeasured(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RSRPMeasurementResult_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RSRPMeasurementResult_EntryIE_Extensions(
    pub Vec<RSRPMeasurementResult_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RSRPMeasurementResult_Entry {
    pub rsrp_cell_id: ECGI,
    pub rsrp_measured: RSRPMeasurementResult_EntryRSRPMeasured,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RSRPMeasurementResult_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RaReportIndicationList_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RaReportIndicationList_ItemIE_Extensions(
    pub Vec<RaReportIndicationList_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RachIndicationProtocolIEs_EntryValue {
    #[asn(key = 447)]
    Id_RaReportIndicationList(RaReportIndicationList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RachIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RachIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RachIndicationProtocolIEs(pub Vec<RachIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RadioResourceStatusIE_Extensions_EntryExtensionValue {
    #[asn(key = 193)]
    Id_DL_scheduling_PDCCH_CCE_usage(DL_scheduling_PDCCH_CCE_usage),
    #[asn(key = 194)]
    Id_UL_scheduling_PDCCH_CCE_usage(UL_scheduling_PDCCH_CCE_usage),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceStatusIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: RadioResourceStatusIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RadioResourceStatusIE_Extensions(pub Vec<RadioResourceStatusIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "110")]
pub struct RelativeNarrowbandTxPowerRNTP_PerPRB(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct RelativeNarrowbandTxPowerNumberOfCellSpecificAntennaPorts(pub u8);
impl RelativeNarrowbandTxPowerNumberOfCellSpecificAntennaPorts {
    pub const ONE: u8 = 0u8;
    pub const TWO: u8 = 1u8;
    pub const FOUR: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct RelativeNarrowbandTxPowerP_B(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4", extensible = true)]
pub struct RelativeNarrowbandTxPowerPDCCH_InterferenceImpact(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RelativeNarrowbandTxPowerIE_Extensions_EntryExtensionValue {
    #[asn(key = 148)]
    Id_enhancedRNTP(EnhancedRNTP),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RelativeNarrowbandTxPowerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: RelativeNarrowbandTxPowerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RelativeNarrowbandTxPowerIE_Extensions(
    pub Vec<RelativeNarrowbandTxPowerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "160")]
pub struct ReservedSubframePatternReservedSubframePattern(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct ReservedSubframePatternMBSFNControlRegionLength(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReservedSubframePatternIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ReservedSubframePatternIE_Extensions(
    pub Vec<ReservedSubframePatternIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResetRequestProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetRequestProtocolIEs(pub Vec<ResetRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResetResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetResponseProtocolIEs(pub Vec<ResetResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResourceStatusFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 68)]
    Id_CompleteFailureCauseInformation_List(CompleteFailureCauseInformation_List),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 39)]
    Id_ENB1_Measurement_ID(Measurement_ID),
    #[asn(key = 40)]
    Id_ENB2_Measurement_ID(Measurement_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResourceStatusFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResourceStatusFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResourceStatusFailureProtocolIEs(pub Vec<ResourceStatusFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResourceStatusRequestProtocolIEs_EntryValue {
    #[asn(key = 29)]
    Id_CellToReport(CellToReport_List),
    #[asn(key = 39)]
    Id_ENB1_Measurement_ID(Measurement_ID),
    #[asn(key = 40)]
    Id_ENB2_Measurement_ID(Measurement_ID),
    #[asn(key = 64)]
    Id_PartialSuccessIndicator(PartialSuccessIndicator),
    #[asn(key = 28)]
    Id_Registration_Request(Registration_Request),
    #[asn(key = 38)]
    Id_ReportCharacteristics(ReportCharacteristics),
    #[asn(key = 30)]
    Id_ReportingPeriodicity(ReportingPeriodicity),
    #[asn(key = 145)]
    Id_ReportingPeriodicityCSIR(ReportingPeriodicityCSIR),
    #[asn(key = 109)]
    Id_ReportingPeriodicityRSRPMR(ReportingPeriodicityRSRPMR),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResourceStatusRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResourceStatusRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResourceStatusRequestProtocolIEs(pub Vec<ResourceStatusRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResourceStatusResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 39)]
    Id_ENB1_Measurement_ID(Measurement_ID),
    #[asn(key = 40)]
    Id_ENB2_Measurement_ID(Measurement_ID),
    #[asn(key = 65)]
    Id_MeasurementInitiationResult_List(MeasurementInitiationResult_List),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResourceStatusResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResourceStatusResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResourceStatusResponseProtocolIEs(pub Vec<ResourceStatusResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ResourceStatusUpdateProtocolIEs_EntryValue {
    #[asn(key = 32)]
    Id_CellMeasurementResult(CellMeasurementResult_List),
    #[asn(key = 39)]
    Id_ENB1_Measurement_ID(Measurement_ID),
    #[asn(key = 40)]
    Id_ENB2_Measurement_ID(Measurement_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResourceStatusUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResourceStatusUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResourceStatusUpdateProtocolIEs(pub Vec<ResourceStatusUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcConfigUpdate_respond_eNB_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcConfigUpdate_respond_eNB(
    pub Vec<RespondingNodeType_EndcConfigUpdate_respond_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EndcConfigUpdate_respond_en_gNB_EntryValue {
    #[asn(key = 253)]
    Id_ServedNRcellsENDCX2ManagementList(ServedNRcellsENDCX2ManagementList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcConfigUpdate_respond_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EndcConfigUpdate_respond_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcConfigUpdate_respond_en_gNB(
    pub Vec<RespondingNodeType_EndcConfigUpdate_respond_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EndcX2Removal_respond_eNB_EntryValue {
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcX2Removal_respond_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EndcX2Removal_respond_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcX2Removal_respond_eNB(
    pub Vec<RespondingNodeType_EndcX2Removal_respond_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EndcX2Removal_respond_en_gNB_EntryValue {
    #[asn(key = 252)]
    Id_Globalen_gNB_ID(GlobalGNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcX2Removal_respond_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EndcX2Removal_respond_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcX2Removal_respond_en_gNB(
    pub Vec<RespondingNodeType_EndcX2Removal_respond_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EndcX2Setup_respond_eNB_EntryValue {
    #[asn(key = 351)]
    Id_CellandCapacityAssistInfo(CellandCapacityAssistInfo),
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
    #[asn(key = 335)]
    Id_InterfaceInstanceIndication(InterfaceInstanceIndication),
    #[asn(key = 250)]
    Id_ServedEUTRAcellsENDCX2ManagementList(ServedEUTRAcellsENDCX2ManagementList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcX2Setup_respond_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EndcX2Setup_respond_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcX2Setup_respond_eNB(
    pub Vec<RespondingNodeType_EndcX2Setup_respond_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EndcX2Setup_respond_en_gNB_EntryValue {
    #[asn(key = 252)]
    Id_Globalen_gNB_ID(GlobalGNB_ID),
    #[asn(key = 348)]
    Id_PartialListIndicator(PartialListIndicator),
    #[asn(key = 253)]
    Id_ServedNRcellsENDCX2ManagementList(ServedNRcellsENDCX2ManagementList),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EndcX2Setup_respond_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EndcX2Setup_respond_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EndcX2Setup_respond_en_gNB(
    pub Vec<RespondingNodeType_EndcX2Setup_respond_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EutranrCellResourceCoordination_respond_eNB_EntryValue {
    #[asn(key = 287)]
    Id_DataTrafficResourceIndication(DataTrafficResourceIndication),
    #[asn(key = 290)]
    Id_ListofEUTRACellsinEUTRACoordinationResp(ListofEUTRACellsinEUTRACoordinationResp),
    #[asn(key = 288)]
    Id_SpectrumSharingGroupID(SpectrumSharingGroupID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EutranrCellResourceCoordination_respond_eNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EutranrCellResourceCoordination_respond_eNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EutranrCellResourceCoordination_respond_eNB(
    pub Vec<RespondingNodeType_EutranrCellResourceCoordination_respond_eNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB_EntryValue {
    #[asn(key = 287)]
    Id_DataTrafficResourceIndication(DataTrafficResourceIndication),
    #[asn(key = 293)]
    Id_ListofNRCellsinNRCoordinationResp(ListofNRCellsinNRCoordinationResp),
    #[asn(key = 288)]
    Id_SpectrumSharingGroupID(SpectrumSharingGroupID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB(
    pub Vec<RespondingNodeType_EutranrCellResourceCoordination_respond_en_gNB_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResponseInformationSeNBReconfComp_RejectByMeNBItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ResponseInformationSeNBReconfComp_RejectByMeNBItemIE_Extensions(
    pub Vec<ResponseInformationSeNBReconfComp_RejectByMeNBItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResponseInformationSeNBReconfComp_SuccessItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ResponseInformationSeNBReconfComp_SuccessItemIE_Extensions(
    pub Vec<ResponseInformationSeNBReconfComp_SuccessItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResponseInformationSgNBReconfComp_RejectByMeNBItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ResponseInformationSgNBReconfComp_RejectByMeNBItemIE_Extensions(
    pub Vec<ResponseInformationSgNBReconfComp_RejectByMeNBItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResponseInformationSgNBReconfComp_SuccessItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ResponseInformationSgNBReconfComp_SuccessItemIE_Extensions(
    pub Vec<ResponseInformationSgNBReconfComp_SuccessItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct ResumeID_non_truncated(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct ResumeID_truncated(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEContextFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEContextFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEContextFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEContextFailureProtocolIEs(pub Vec<RetrieveUEContextFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEContextRequestProtocolIEs_EntryValue {
    #[asn(key = 50)]
    Id_FailureCellCRNTI(CRNTI),
    #[asn(key = 48)]
    Id_FailureCellPCI(PCI),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 175)]
    Id_NewEUTRANCellIdentifier(EUTRANCellIdentifier),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 51)]
    Id_ShortMAC_I(ShortMAC_I),
    #[asn(key = 172)]
    Id_resumeID(ResumeID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEContextRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEContextRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEContextRequestProtocolIEs(pub Vec<RetrieveUEContextRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEContextResponseProtocolIEs_EntryValue {
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 104)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 23)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 98)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 370)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 372)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 103)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 36)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 309)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 13)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 173)]
    Id_UE_ContextInformationRetrieve(UE_ContextInformationRetrieve),
    #[asn(key = 176)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEContextResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEContextResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEContextResponseProtocolIEs(
    pub Vec<RetrieveUEContextResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1TNLLoadIndicatorIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct S1TNLLoadIndicatorIE_Extensions(pub Vec<S1TNLLoadIndicatorIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct SFN_OffsetSFN_Time_Offset(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SFN_OffsetIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SFN_OffsetIE_Extensions(pub Vec<SFN_OffsetIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SNStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 18)]
    Id_E_RABs_SubjectToStatusTransfer_List(E_RABs_SubjectToStatusTransfer_List),
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SNStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SNStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SNStatusTransferProtocolIEs(pub Vec<SNStatusTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct SSB_PositionsInBurst_shortBitmap(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct SSB_PositionsInBurst_mediumBitmap(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct SSB_PositionsInBurst_longBitmap(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSB_PositionsInBurst_choice_extension {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaCapacityValue_ItemSsbAreaCapacityValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSBAreaCapacityValue_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SSBAreaCapacityValue_ItemIE_Extensions(
    pub Vec<SSBAreaCapacityValue_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaDLGBRPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaULGBRPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaDLNonGBRPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaULNonGBRPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaDLTotalPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaULTotalPRBUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaDLSchedulingPDCCHCCEUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SSBAreaRadioResourceStatus_ItemSsbAreaULSchedulingPDCCHCCEUsage(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSBAreaRadioResourceStatus_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SSBAreaRadioResourceStatus_ItemIE_Extensions(
    pub Vec<SSBAreaRadioResourceStatus_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSBToReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SSBToReport_ItemIE_Extensions(pub Vec<SSBToReport_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct SULInformationSUL_ARFCN(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SULInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 386)]
    Id_CarrierList(NRCarrierList),
    #[asn(key = 388)]
    Id_FrequencyShift7p5khz(FrequencyShift7p5khz),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SULInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: SULInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SULInformationIE_Extensions(pub Vec<SULInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ScheduledCommunicationTimeDayofWeek(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayStart(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayEnd(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ScheduledCommunicationTimeIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ScheduledCommunicationTimeIE_Extensions(
    pub Vec<ScheduledCommunicationTimeIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBAdditionRequestProtocolIEs_EntryValue {
    #[asn(key = 71)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 117)]
    Id_E_RABs_ToBeAdded_List(E_RABs_ToBeAdded_List),
    #[asn(key = 104)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 119)]
    Id_MeNBtoSeNBContainer(MeNBtoSeNBContainer),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 114)]
    Id_SeNBSecurityKey(SeNBSecurityKey),
    #[asn(key = 115)]
    Id_SeNBUEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 116)]
    Id_ServingPLMN(PLMN_Identity),
    #[asn(key = 113)]
    Id_UE_SecurityCapabilities(UESecurityCapabilities),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBAdditionRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBAdditionRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBAdditionRequestProtocolIEs(pub Vec<SeNBAdditionRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBAdditionRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 120)]
    Id_E_RABs_Admitted_ToBeAdded_List(E_RABs_Admitted_ToBeAdded_List),
    #[asn(key = 3)]
    Id_E_RABs_NotAdmitted_List(E_RAB_List),
    #[asn(key = 165)]
    Id_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 168)]
    Id_SIPTO_L_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 122)]
    Id_SeNBtoMeNBContainer(SeNBtoMeNBContainer),
    #[asn(key = 163)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBAdditionRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBAdditionRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBAdditionRequestAcknowledgeProtocolIEs(
    pub Vec<SeNBAdditionRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBAdditionRequestRejectProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBAdditionRequestRejectProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBAdditionRequestRejectProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBAdditionRequestRejectProtocolIEs(
    pub Vec<SeNBAdditionRequestRejectProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBCounterCheckRequestProtocolIEs_EntryValue {
    #[asn(key = 141)]
    Id_E_RABs_SubjectToCounterCheck_List(E_RABs_SubjectToCounterCheck_List),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBCounterCheckRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBCounterCheckRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBCounterCheckRequestProtocolIEs(pub Vec<SeNBCounterCheckRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 119)]
    Id_MeNBtoSeNBContainer(MeNBtoSeNBContainer),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationConfirmProtocolIEs(pub Vec<SeNBModificationConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationRefuseProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 119)]
    Id_MeNBtoSeNBContainer(MeNBtoSeNBContainer),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationRefuseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationRefuseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationRefuseProtocolIEs(pub Vec<SeNBModificationRefuseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 71)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 119)]
    Id_MeNBtoSeNBContainer(MeNBtoSeNBContainer),
    #[asn(key = 136)]
    Id_SCGChangeIndication(SCGChangeIndication),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 116)]
    Id_ServingPLMN(PLMN_Identity),
    #[asn(key = 124)]
    Id_UE_ContextInformationSeNBModReq(UE_ContextInformationSeNBModReq),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationRequestProtocolIEs(pub Vec<SeNBModificationRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 128)]
    Id_E_RABs_Admitted_ToBeAdded_ModAckList(E_RABs_Admitted_ToBeAdded_ModAckList),
    #[asn(key = 129)]
    Id_E_RABs_Admitted_ToBeModified_ModAckList(E_RABs_Admitted_ToBeModified_ModAckList),
    #[asn(key = 130)]
    Id_E_RABs_Admitted_ToBeReleased_ModAckList(E_RABs_Admitted_ToBeReleased_ModAckList),
    #[asn(key = 3)]
    Id_E_RABs_NotAdmitted_List(E_RAB_List),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 122)]
    Id_SeNBtoMeNBContainer(SeNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationRequestAcknowledgeProtocolIEs(
    pub Vec<SeNBModificationRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationRequestRejectProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationRequestRejectProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationRequestRejectProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationRequestRejectProtocolIEs(
    pub Vec<SeNBModificationRequestRejectProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBModificationRequiredProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 134)]
    Id_E_RABs_ToBeReleased_ModReqd(E_RABs_ToBeReleased_ModReqd),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 136)]
    Id_SCGChangeIndication(SCGChangeIndication),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 122)]
    Id_SeNBtoMeNBContainer(SeNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBModificationRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBModificationRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBModificationRequiredProtocolIEs(pub Vec<SeNBModificationRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBReconfigurationCompleteProtocolIEs_EntryValue {
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 123)]
    Id_ResponseInformationSeNBReconfComp(ResponseInformationSeNBReconfComp),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBReconfigurationCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBReconfigurationCompleteProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBReconfigurationCompleteProtocolIEs(
    pub Vec<SeNBReconfigurationCompleteProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBReleaseConfirmProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 139)]
    Id_E_RABs_ToBeReleased_List_RelConf(E_RABs_ToBeReleased_List_RelConf),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBReleaseConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBReleaseConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBReleaseConfirmProtocolIEs(pub Vec<SeNBReleaseConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 137)]
    Id_E_RABs_ToBeReleased_List_RelReq(E_RABs_ToBeReleased_List_RelReq),
    #[asn(key = 181)]
    Id_MakeBeforeBreakIndicator(MakeBeforeBreakIndicator),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 154)]
    Id_UE_ContextKeptIndicator(UE_ContextKeptIndicator),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBReleaseRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBReleaseRequestProtocolIEs(pub Vec<SeNBReleaseRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SeNBReleaseRequiredProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 112)]
    Id_SeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 158)]
    Id_SeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SeNBReleaseRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SeNBReleaseRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SeNBReleaseRequiredProtocolIEs(pub Vec<SeNBReleaseRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 265)]
    Id_SecondaryRATUsageReportList(SecondaryRATUsageReportList),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportProtocolIEs(
    pub Vec<SecondaryRATDataUsageReportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SecondaryRATUsageReport_ItemSecondaryRATType(pub u8);
impl SecondaryRATUsageReport_ItemSecondaryRATType {
    pub const NR: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATUsageReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATUsageReport_ItemIE_Extensions(
    pub Vec<SecondaryRATUsageReport_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATUsageReportList_EntryValue {
    #[asn(key = 266)]
    Id_SecondaryRATUsageReport_Item(SecondaryRATUsageReport_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATUsageReportList_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityIndicationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityIndicationIE_Extensions(pub Vec<SecurityIndicationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityResultIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityResultIE_Extensions(pub Vec<SecurityResultIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasConfigNameItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasConfigNameItemIE_Extensions(
    pub Vec<SensorMeasConfigNameItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasurementConfigurationIE_Extensions(
    pub Vec<SensorMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorNameConfig_uncompensatedBarometricConfig(pub u8);
impl SensorNameConfig_uncompensatedBarometricConfig {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorNameConfig_choice_extension {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 336)]
    Id_BPLMN_ID_Info_EUTRA(BPLMN_ID_Info_EUTRA),
    #[asn(key = 180)]
    Id_BandwidthReducedSI(BandwidthReducedSI),
    #[asn(key = 70)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 160)]
    Id_FreqBandIndicatorPriority(FreqBandIndicatorPriority),
    #[asn(key = 79)]
    Id_MBMS_Service_Area_List(MBMS_Service_Area_Identity_List),
    #[asn(key = 56)]
    Id_MBSFN_Subframe_Info(MBSFN_Subframe_Infolist),
    #[asn(key = 84)]
    Id_MultibandInfoList(MultibandInfoList),
    #[asn(key = 373)]
    Id_NPRACHConfiguration(NPRACHConfiguration),
    #[asn(key = 41)]
    Id_Number_of_Antennaports(Number_of_Antennaports),
    #[asn(key = 55)]
    Id_PRACH_Configuration(PRACH_Configuration),
    #[asn(key = 284)]
    Id_ProtectedEUTRAResourceIndication(ProtectedEUTRAResourceIndication),
    #[asn(key = 406)]
    Id_SFN_Offset(SFN_Offset),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ServedCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedCell_InformationIE_Extensions(pub Vec<ServedCell_InformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ServedCellSpecificInfoReq_NR_ItemAdditionalMTCListRequestIndicator(pub u8);
impl ServedCellSpecificInfoReq_NR_ItemAdditionalMTCListRequestIndicator {
    pub const ADDITIONAL_MTC_LIST_REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedCellSpecificInfoReq_NR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedCellSpecificInfoReq_NR_ItemIE_Extensions(
    pub Vec<ServedCellSpecificInfoReq_NR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedCells_EntryIE_Extensions_EntryExtensionValue {
    #[asn(key = 327)]
    Id_NRNeighbourInfoToAdd(NRNeighbour_Information),
    #[asn(key = 434)]
    Id_ServedCellSpecificInfoReq_NR(ServedCellSpecificInfoReq_NR),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedCells_EntryIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ServedCells_EntryIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedCells_EntryIE_Extensions(pub Vec<ServedCells_EntryIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedCells_Entry {
    pub served_cell_info: ServedCell_Information,
    #[asn(optional_idx = 0)]
    pub neighbour_info: Option<Neighbour_Information>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedCells_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedCellsToActivate_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedCellsToActivate_ItemIE_Extensions(
    pub Vec<ServedCellsToActivate_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedCellsToModify_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 59)]
    Id_DeactivationIndication(DeactivationIndication),
    #[asn(key = 328)]
    Id_NRNeighbourInfoToModify(NRNeighbour_Information),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedCellsToModify_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ServedCellsToModify_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedCellsToModify_ItemIE_Extensions(
    pub Vec<ServedCellsToModify_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedEUTRAcellsENDCX2ManagementList_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedEUTRAcellsENDCX2ManagementList_EntryIE_Extensions(
    pub Vec<ServedEUTRAcellsENDCX2ManagementList_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedEUTRAcellsENDCX2ManagementList_Entry {
    pub served_eutra_cell_info: ServedCell_Information,
    #[asn(optional_idx = 0)]
    pub nr_neighbour_info: Option<NRNeighbour_Information>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedEUTRAcellsENDCX2ManagementList_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedEUTRAcellsToModifyListENDCConfUpd_EntryIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedEUTRAcellsToModifyListENDCConfUpd_EntryIE_Extensions(
    pub Vec<ServedEUTRAcellsToModifyListENDCConfUpd_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedEUTRAcellsToModifyListENDCConfUpd_Entry {
    pub old_ecgi: ECGI,
    pub served_eutra_cell_info: ServedCell_Information,
    #[asn(optional_idx = 0)]
    pub nr_neighbour_info: Option<NRNeighbour_Information>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedEUTRAcellsToModifyListENDCConfUpd_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ServedNRCell_InformationNrModeInfo {
    #[asn(key = 0, extended = false)]
    Fdd(FDD_InfoServedNRCell_Information),
    #[asn(key = 1, extended = false)]
    Tdd(TDD_InfoServedNRCell_Information),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ServedNRCell_InformationMeasurementTimingConfiguration(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedNRCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 433)]
    Id_Additional_Measurement_Timing_Configuration_List(
        Additional_Measurement_Timing_Configuration_List,
    ),
    #[asn(key = 337)]
    Id_BPLMN_ID_Info_NR(BPLMN_ID_Info_NR),
    #[asn(key = 380)]
    Id_CSI_RSTransmissionIndication(CSI_RSTransmissionIndication),
    #[asn(key = 390)]
    Id_NRCellPRACHConfig(NRCellPRACHConfig),
    #[asn(key = 406)]
    Id_SFN_Offset(SFN_Offset),
    #[asn(key = 389)]
    Id_SSB_PositionsInBurst(SSB_PositionsInBurst),
    #[asn(key = 334)]
    Id_additionalPLMNs_Item(AdditionalPLMNs_Item),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedNRCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ServedNRCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedNRCell_InformationIE_Extensions(
    pub Vec<ServedNRCell_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedNRCellsToActivate_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedNRCellsToActivate_ItemIE_Extensions(
    pub Vec<ServedNRCellsToActivate_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedNRCellsToModify_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedNRCellsToModify_ItemIE_Extensions(
    pub Vec<ServedNRCellsToModify_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedNRcellsENDCX2ManagementList_EntryIE_Extensions_EntryExtensionValue {
    #[asn(key = 434)]
    Id_ServedCellSpecificInfoReq_NR(ServedCellSpecificInfoReq_NR),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedNRcellsENDCX2ManagementList_EntryIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: ServedNRcellsENDCX2ManagementList_EntryIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedNRcellsENDCX2ManagementList_EntryIE_Extensions(
    pub Vec<ServedNRcellsENDCX2ManagementList_EntryIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedNRcellsENDCX2ManagementList_Entry {
    pub served_nr_cell_info: ServedNRCell_Information,
    #[asn(optional_idx = 0)]
    pub nr_neighbour_info: Option<NRNeighbour_Information>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedNRcellsENDCX2ManagementList_EntryIE_Extensions>,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBActivityNotificationProtocolIEs_EntryValue {
    #[asn(key = 297)]
    Id_ERABActivityNotifyItemList(ERABActivityNotifyItemList),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 296)]
    Id_UEContextLevelUserPlaneActivity(UserPlaneTrafficActivityReport),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBActivityNotificationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBActivityNotificationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBActivityNotificationProtocolIEs(pub Vec<SgNBActivityNotificationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBAdditionRequestProtocolIEs_EntryValue {
    #[asn(key = 340)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 420)]
    Id_CHOinformation_AddReq(CHOinformation_AddReq),
    #[asn(key = 424)]
    Id_CPAinformation_REQ(CPAinformation_REQ),
    #[asn(key = 329)]
    Id_DesiredActNotificationLevel(DesiredActNotificationLevel),
    #[asn(key = 205)]
    Id_E_RABs_ToBeAdded_SgNBAddReqList(E_RABs_ToBeAdded_SgNBAddReqList),
    #[asn(key = 104)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 240)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 449)]
    Id_IABAuthorized(IABAuthorized),
    #[asn(key = 395)]
    Id_IABNodeIndication(IABNodeIndication),
    #[asn(key = 330)]
    Id_LocationInformationSgNBReporting(LocationInformationSgNBReporting),
    #[asn(key = 89)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 74)]
    Id_ManagementBasedMDTallowed(ManagementBasedMDTallowed),
    #[asn(key = 98)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 279)]
    Id_MeNBCell_ID(ECGI),
    #[asn(key = 257)]
    Id_MeNBResourceCoordinationInformation(MeNBResourceCoordinationInformation),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 248)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 419)]
    Id_PSCellChangeHistory(PSCellChangeHistory),
    #[asn(key = 343)]
    Id_RequestedFastMCGRecoveryViaSRB3(RequestedFastMCGRecoveryViaSRB3),
    #[asn(key = 208)]
    Id_RequestedSplitSRBs(SplitSRBs),
    #[asn(key = 423)]
    Id_SCGActivationRequest(SCGActivationRequest),
    #[asn(key = 278)]
    Id_SGNB_Addition_Trigger_Ind(SGNB_Addition_Trigger_Ind),
    #[asn(key = 269)]
    Id_SelectedPLMN(PLMN_Identity),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 203)]
    Id_SgNBSecurityKey(SgNBSecurityKey),
    #[asn(key = 204)]
    Id_SgNBUEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 275)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 13)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 15)]
    Id_UE_HistoryInformation(UE_HistoryInformation),
    #[asn(key = 105)]
    Id_UE_HistoryInformationFromTheUE(UE_HistoryInformationFromTheUE),
    #[asn(key = 359)]
    Id_UEContextReferenceatSourceNGRAN(RAN_UE_NGAP_ID),
    #[asn(key = 378)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 411)]
    Id_sourceNG_RAN_node_id(Global_RAN_NODE_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBAdditionRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBAdditionRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBAdditionRequestProtocolIEs(pub Vec<SgNBAdditionRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBAdditionRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_AdmittedSplitSRBs(SplitSRBs),
    #[asn(key = 344)]
    Id_AvailableFastMCGRecoveryViaSRB3(AvailableFastMCGRecoveryViaSRB3),
    #[asn(key = 425)]
    Id_CPAinformation_REQ_ACK(CPAinformation_REQ_ACK),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 410)]
    Id_DirectForwardingPathAvailability(DirectForwardingPathAvailability),
    #[asn(key = 210)]
    Id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList(E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList),
    #[asn(key = 3)]
    Id_E_RABs_NotAdmitted_List(E_RAB_List),
    #[asn(key = 331)]
    Id_LocationInformationSgNB(LocationInformationSgNB),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 272)]
    Id_RRCConfigIndication(RRC_Config_Ind),
    #[asn(key = 422)]
    Id_SCGActivationStatus(SCGActivationStatus),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 258)]
    Id_SgNBResourceCoordinationInformation(SgNBResourceCoordinationInformation),
    #[asn(key = 211)]
    Id_SgNBtoMeNBContainer(SgNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBAdditionRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBAdditionRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBAdditionRequestAcknowledgeProtocolIEs(
    pub Vec<SgNBAdditionRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBAdditionRequestRejectProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBAdditionRequestRejectProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBAdditionRequestRejectProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBAdditionRequestRejectProtocolIEs(
    pub Vec<SgNBAdditionRequestRejectProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBChangeConfirmProtocolIEs_EntryValue {
    #[asn(key = 430)]
    Id_CPCinformation_CONF(CPCinformation_CONF),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 229)]
    Id_E_RABs_ToBeReleased_SgNBChaConfList(E_RABs_ToBeReleased_SgNBChaConfList),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBChangeConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBChangeConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBChangeConfirmProtocolIEs(pub Vec<SgNBChangeConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBChangeRefuseProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBChangeRefuseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBChangeRefuseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBChangeRefuseProtocolIEs(pub Vec<SgNBChangeRefuseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBChangeRequiredProtocolIEs_EntryValue {
    #[asn(key = 429)]
    Id_CPCinformation_REQD(CPCinformation_REQD),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 415)]
    Id_SCG_UE_HistoryInformation(SCG_UE_HistoryInformation),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 211)]
    Id_SgNBtoMeNBContainer(SgNBtoMeNBContainer),
    #[asn(key = 239)]
    Id_Target_SgNB_ID(GlobalGNB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBChangeRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBChangeRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBChangeRequiredProtocolIEs(pub Vec<SgNBChangeRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBCounterCheckRequestProtocolIEs_EntryValue {
    #[asn(key = 235)]
    Id_E_RABs_SubjectToSgNBCounterCheck_List(E_RABs_SubjectToSgNBCounterCheck_List),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBCounterCheckRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBCounterCheckRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBCounterCheckRequestProtocolIEs(pub Vec<SgNBCounterCheckRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 294)]
    Id_E_RABs_AdmittedToBeModified_SgNBModConfList(E_RABs_AdmittedToBeModified_SgNBModConfList),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 257)]
    Id_MeNBResourceCoordinationInformation(MeNBResourceCoordinationInformation),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationConfirmProtocolIEs(pub Vec<SgNBModificationConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationRefuseProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationRefuseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationRefuseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationRefuseProtocolIEs(pub Vec<SgNBModificationRefuseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 421)]
    Id_CHOinformation_ModReq(CHOinformation_ModReq),
    #[asn(key = 426)]
    Id_CPAinformation_MOD(CPAinformation_MOD),
    #[asn(key = 432)]
    Id_CPCupdate_MOD(CPCupdate_MOD),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 329)]
    Id_DesiredActNotificationLevel(DesiredActNotificationLevel),
    #[asn(key = 240)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 449)]
    Id_IABAuthorized(IABAuthorized),
    #[asn(key = 395)]
    Id_IABNodeIndication(IABNodeIndication),
    #[asn(key = 330)]
    Id_LocationInformationSgNBReporting(LocationInformationSgNBReporting),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 279)]
    Id_MeNBCell_ID(ECGI),
    #[asn(key = 257)]
    Id_MeNBResourceCoordinationInformation(MeNBResourceCoordinationInformation),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 416)]
    Id_PSCellHistoryInformationRetrieve(PSCellHistoryInformationRetrieve),
    #[asn(key = 343)]
    Id_RequestedFastMCGRecoveryViaSRB3(RequestedFastMCGRecoveryViaSRB3),
    #[asn(key = 345)]
    Id_RequestedFastMCGRecoveryViaSRB3Release(RequestedFastMCGRecoveryViaSRB3Release),
    #[asn(key = 208)]
    Id_RequestedSplitSRBs(SplitSRBs),
    #[asn(key = 280)]
    Id_RequestedSplitSRBsrelease(SplitSRBs),
    #[asn(key = 423)]
    Id_SCGActivationRequest(SCGActivationRequest),
    #[asn(key = 241)]
    Id_SCGConfigurationQuery(SCGConfigurationQuery),
    #[asn(key = 379)]
    Id_SNtriggered(SNtriggered),
    #[asn(key = 269)]
    Id_SelectedPLMN(PLMN_Identity),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 215)]
    Id_UE_ContextInformation_SgNBModReq(UE_ContextInformation_SgNBModReq),
    #[asn(key = 105)]
    Id_UE_HistoryInformationFromTheUE(UE_HistoryInformationFromTheUE),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationRequestProtocolIEs(pub Vec<SgNBModificationRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_AdmittedSplitSRBs(SplitSRBs),
    #[asn(key = 281)]
    Id_AdmittedSplitSRBsrelease(SplitSRBs),
    #[asn(key = 344)]
    Id_AvailableFastMCGRecoveryViaSRB3(AvailableFastMCGRecoveryViaSRB3),
    #[asn(key = 427)]
    Id_CPAinformation_MOD_ACK(CPAinformation_MOD_ACK),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 219)]
    Id_E_RABs_Admitted_ToBeAdded_SgNBModAckList(E_RABs_Admitted_ToBeAdded_SgNBModAckList),
    #[asn(key = 220)]
    Id_E_RABs_Admitted_ToBeModified_SgNBModAckList(E_RABs_Admitted_ToBeModified_SgNBModAckList),
    #[asn(key = 221)]
    Id_E_RABs_Admitted_ToBeReleased_SgNBModAckList(E_RABs_Admitted_ToBeReleased_SgNBModAckList),
    #[asn(key = 3)]
    Id_E_RABs_NotAdmitted_List(E_RAB_List),
    #[asn(key = 331)]
    Id_LocationInformationSgNB(LocationInformationSgNB),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 272)]
    Id_RRCConfigIndication(RRC_Config_Ind),
    #[asn(key = 346)]
    Id_ReleaseFastMCGRecoveryViaSRB3(ReleaseFastMCGRecoveryViaSRB3),
    #[asn(key = 415)]
    Id_SCG_UE_HistoryInformation(SCG_UE_HistoryInformation),
    #[asn(key = 422)]
    Id_SCGActivationStatus(SCGActivationStatus),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 258)]
    Id_SgNBResourceCoordinationInformation(SgNBResourceCoordinationInformation),
    #[asn(key = 211)]
    Id_SgNBtoMeNBContainer(SgNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationRequestAcknowledgeProtocolIEs(
    pub Vec<SgNBModificationRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationRequestRejectProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationRequestRejectProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationRequestRejectProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationRequestRejectProtocolIEs(
    pub Vec<SgNBModificationRequestRejectProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBModificationRequiredProtocolIEs_EntryValue {
    #[asn(key = 428)]
    Id_CPACinformation_REQD(CPACinformation_REQD),
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 226)]
    Id_E_RABs_ToBeModified_SgNBModReqdList(E_RABs_ToBeModified_SgNBModReqdList),
    #[asn(key = 225)]
    Id_E_RABs_ToBeReleased_SgNBModReqdList(E_RABs_ToBeReleased_SgNBModReqdList),
    #[asn(key = 331)]
    Id_LocationInformationSgNB(LocationInformationSgNB),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 249)]
    Id_PDCPChangeIndication(PDCPChangeIndication),
    #[asn(key = 272)]
    Id_RRCConfigIndication(RRC_Config_Ind),
    #[asn(key = 415)]
    Id_SCG_UE_HistoryInformation(SCG_UE_HistoryInformation),
    #[asn(key = 423)]
    Id_SCGActivationRequest(SCGActivationRequest),
    #[asn(key = 438)]
    Id_SCGreconfigNotification(SCGreconfigNotification),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 258)]
    Id_SgNBResourceCoordinationInformation(SgNBResourceCoordinationInformation),
    #[asn(key = 211)]
    Id_SgNBtoMeNBContainer(SgNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBModificationRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBModificationRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBModificationRequiredProtocolIEs(pub Vec<SgNBModificationRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReconfigurationCompleteProtocolIEs_EntryValue {
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 214)]
    Id_ResponseInformationSgNBReconfComp(ResponseInformationSgNBReconfComp),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReconfigurationCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReconfigurationCompleteProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReconfigurationCompleteProtocolIEs(
    pub Vec<SgNBReconfigurationCompleteProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReleaseConfirmProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 233)]
    Id_E_RABs_ToBeReleased_SgNBRelConfList(E_RABs_ToBeReleased_SgNBRelConfList),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReleaseConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReleaseConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReleaseConfirmProtocolIEs(pub Vec<SgNBReleaseConfirmProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 231)]
    Id_E_RABs_ToBeReleased_SgNBRelReqList(E_RABs_ToBeReleased_SgNBRelReqList),
    #[asn(key = 339)]
    Id_ERABs_transferred_to_MeNB(E_RAB_List),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 206)]
    Id_MeNBtoSgNBContainer(MeNBtoSgNBContainer),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 154)]
    Id_UE_ContextKeptIndicator(UE_ContextKeptIndicator),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReleaseRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReleaseRequestProtocolIEs(pub Vec<SgNBReleaseRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReleaseRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 318)]
    Id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList(
        E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList,
    ),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 415)]
    Id_SCG_UE_HistoryInformation(SCG_UE_HistoryInformation),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReleaseRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReleaseRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReleaseRequestAcknowledgeProtocolIEs(
    pub Vec<SgNBReleaseRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReleaseRequestRejectProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReleaseRequestRejectProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReleaseRequestRejectProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReleaseRequestRejectProtocolIEs(pub Vec<SgNBReleaseRequestRejectProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBReleaseRequiredProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 320)]
    Id_E_RABs_ToBeReleased_SgNBRelReqdList(E_RABs_ToBeReleased_SgNBRelReqdList),
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 415)]
    Id_SCG_UE_HistoryInformation(SCG_UE_HistoryInformation),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 211)]
    Id_SgNBtoMeNBContainer(SgNBtoMeNBContainer),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBReleaseRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SgNBReleaseRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SgNBReleaseRequiredProtocolIEs(pub Vec<SgNBReleaseRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "4400")]
pub struct SgNBResourceCoordinationInformationULCoordinationInformation(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "6", sz_ub = "4400")]
pub struct SgNBResourceCoordinationInformationDLCoordinationInformation(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SgNBResourceCoordinationInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 316)]
    Id_ECGI(ECGI),
    #[asn(key = 324)]
    Id_SgNBCoordinationAssistanceInformation(SgNBCoordinationAssistanceInformation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SgNBResourceCoordinationInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: SgNBResourceCoordinationInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SgNBResourceCoordinationInformationIE_Extensions(
    pub Vec<SgNBResourceCoordinationInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SpecialSubframe_InfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SpecialSubframe_InfoIE_Extensions(pub Vec<SpecialSubframe_InfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SplitSRBIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SplitSRBIE_Extensions(pub Vec<SplitSRBIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SubbandCQIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SubbandCQIIE_Extensions(pub Vec<SubbandCQIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct SubbandCQICodeword0_four_bitCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct SubbandCQICodeword0_two_bitSubbandDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct SubbandCQICodeword0_two_bitDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct SubbandCQICodeword1_four_bitCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7", extensible = true)]
pub struct SubbandCQICodeword1_three_bitSpatialDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct SubbandCQICodeword1_two_bitSubbandDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct SubbandCQICodeword1_two_bitDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "27", extensible = true)]
pub struct SubbandCQIItemSubbandIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SubbandCQIItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SubbandCQIItemIE_Extensions(pub Vec<SubbandCQIItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator(pub u8);
impl Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator {
    pub const PERIODICALLY: u8 = 0u8;
    pub const ONDEMAND: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3600", extensible = true)]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicTime(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoStationaryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoStationaryIndication {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoTrafficProfile(pub u8);
impl Subscription_Based_UE_DifferentiationInfoTrafficProfile {
    pub const SINGLE_PACKET: u8 = 0u8;
    pub const DUAL_PACKETS: u8 = 1u8;
    pub const MULTIPLE_PACKETS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoBatteryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoBatteryIndication {
    pub const BATTERY_POWERED: u8 = 0u8;
    pub const BATTERY_POWERED_NOT_RECHARGEABLE_OR_REPLACEABLE: u8 = 1u8;
    pub const NOT_BATTERY_POWERED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions(
    pub Vec<Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SuccessfulOutcomeValue {
    #[asn(key = 56)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingResponse),
    #[asn(key = 15)]
    Id_cellActivation(CellActivationResponse),
    #[asn(key = 8)]
    Id_eNBConfigurationUpdate(ENBConfigurationUpdateAcknowledge),
    #[asn(key = 41)]
    Id_eUTRANRCellResourceCoordination(EUTRANRCellResourceCoordinationResponse),
    #[asn(key = 39)]
    Id_endcCellActivation(ENDCCellActivationResponse),
    #[asn(key = 37)]
    Id_endcConfigurationUpdate(ENDCConfigurationUpdateAcknowledge),
    #[asn(key = 40)]
    Id_endcPartialReset(ENDCPartialResetConfirm),
    #[asn(key = 43)]
    Id_endcX2Removal(ENDCX2RemovalResponse),
    #[asn(key = 36)]
    Id_endcX2Setup(ENDCX2SetupResponse),
    #[asn(key = 54)]
    Id_endcresourceStatusReportingInitiation(ENDCResourceStatusResponse),
    #[asn(key = 0)]
    Id_handoverPreparation(HandoverRequestAcknowledge),
    #[asn(key = 21)]
    Id_meNBinitiatedSeNBModificationPreparation(SeNBModificationRequestAcknowledge),
    #[asn(key = 29)]
    Id_meNBinitiatedSgNBModificationPreparation(SgNBModificationRequestAcknowledge),
    #[asn(key = 31)]
    Id_meNBinitiatedSgNBRelease(SgNBReleaseRequestAcknowledge),
    #[asn(key = 12)]
    Id_mobilitySettingsChange(MobilityChangeAcknowledge),
    #[asn(key = 7)]
    Id_reset(ResetResponse),
    #[asn(key = 9)]
    Id_resourceStatusReportingInitiation(ResourceStatusResponse),
    #[asn(key = 26)]
    Id_retrieveUEContext(RetrieveUEContextResponse),
    #[asn(key = 19)]
    Id_seNBAdditionPreparation(SeNBAdditionRequestAcknowledge),
    #[asn(key = 22)]
    Id_seNBinitiatedSeNBModification(SeNBModificationConfirm),
    #[asn(key = 24)]
    Id_seNBinitiatedSeNBRelease(SeNBReleaseConfirm),
    #[asn(key = 27)]
    Id_sgNBAdditionPreparation(SgNBAdditionRequestAcknowledge),
    #[asn(key = 34)]
    Id_sgNBChange(SgNBChangeConfirm),
    #[asn(key = 30)]
    Id_sgNBinitiatedSgNBModification(SgNBModificationConfirm),
    #[asn(key = 32)]
    Id_sgNBinitiatedSgNBRelease(SgNBReleaseConfirm),
    #[asn(key = 18)]
    Id_x2Removal(X2RemovalResponse),
    #[asn(key = 6)]
    Id_x2Setup(X2SetupResponse),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024", extensible = true)]
pub struct SupportedSULFreqBandItemFreqBandIndicatorNr(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedSULFreqBandItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SupportedSULFreqBandItemIE_Extensions(
    pub Vec<SupportedSULFreqBandItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedMDTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedMDTIE_Extensions(pub Vec<TABasedMDTIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedQMCIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedQMCIE_Extensions(pub Vec<TABasedQMCIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAI_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_ItemIE_Extensions(pub Vec<TAI_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedMDTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedMDTIE_Extensions(pub Vec<TAIBasedMDTIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedQMCIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedQMCIE_Extensions(pub Vec<TAIBasedQMCIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TDD_InfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 97)]
    Id_AdditionalSpecialSubframe_Info(AdditionalSpecialSubframe_Info),
    #[asn(key = 179)]
    Id_AdditionalSpecialSubframeExtension_Info(AdditionalSpecialSubframeExtension_Info),
    #[asn(key = 338)]
    Id_NBIoT_UL_DL_AlignmentOffset(NBIoT_UL_DL_AlignmentOffset),
    #[asn(key = 177)]
    Id_OffsetOfNbiotChannelNumberToDL_EARFCN(OffsetOfNbiotChannelNumberToEARFCN),
    #[asn(key = 94)]
    Id_eARFCNExtension(EARFCNExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_InfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: TDD_InfoIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TDD_InfoIE_Extensions(pub Vec<TDD_InfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TDD_InfoNeighbourServedNRCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 386)]
    Id_CarrierList(NRCarrierList),
    #[asn(key = 399)]
    Id_IntendedTDD_DL_ULConfiguration_NR(IntendedTDD_DL_ULConfiguration_NR),
    #[asn(key = 385)]
    Id_TDDULDLConfigurationCommonNR(TDDULDLConfigurationCommonNR),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_InfoNeighbourServedNRCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: TDD_InfoNeighbourServedNRCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TDD_InfoNeighbourServedNRCell_InformationIE_Extensions(
    pub Vec<TDD_InfoNeighbourServedNRCell_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TDD_InfoServedNRCell_InformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 386)]
    Id_CarrierList(NRCarrierList),
    #[asn(key = 399)]
    Id_IntendedTDD_DL_ULConfiguration_NR(IntendedTDD_DL_ULConfiguration_NR),
    #[asn(key = 385)]
    Id_TDDULDLConfigurationCommonNR(TDDULDLConfigurationCommonNR),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_InfoServedNRCell_InformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: TDD_InfoServedNRCell_InformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TDD_InfoServedNRCell_InformationIE_Extensions(
    pub Vec<TDD_InfoServedNRCell_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLA_Failed_To_Setup_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLA_Failed_To_Setup_ItemIE_Extensions(
    pub Vec<TNLA_Failed_To_Setup_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLA_Setup_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLA_Setup_ItemIE_Extensions(pub Vec<TNLA_Setup_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLA_To_Add_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLA_To_Add_ItemIE_Extensions(pub Vec<TNLA_To_Add_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLA_To_Remove_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLA_To_Remove_ItemIE_Extensions(pub Vec<TNLA_To_Remove_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLA_To_Update_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLA_To_Update_ItemIE_Extensions(pub Vec<TNLA_To_Update_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16777216", extensible = true)]
pub struct TNLCapacityIndicatorDlTNLMaximumOfferedCapacity(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100", extensible = true)]
pub struct TNLCapacityIndicatorDlTNLAvailableCapacity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16777216", extensible = true)]
pub struct TNLCapacityIndicatorUlTNLMaximumOfferedCapacity(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100", extensible = true)]
pub struct TNLCapacityIndicatorUlTNLAvailableCapacity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLCapacityIndicatorIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLCapacityIndicatorIE_Extensions(pub Vec<TNLCapacityIndicatorIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLConfigurationInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLConfigurationInfoIE_Extensions(pub Vec<TNLConfigurationInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TraceActivationIE_Extensions_EntryExtensionValue {
    #[asn(key = 72)]
    Id_MDTConfiguration(MDT_Configuration),
    #[asn(key = 375)]
    Id_MDTConfigurationNR(MDT_ConfigurationNR),
    #[asn(key = 405)]
    Id_TraceCollectionEntityURI(URI_Address),
    #[asn(key = 195)]
    Id_UEAppLayerMeasConfig(UEAppLayerMeasConfig),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceActivationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: TraceActivationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TraceActivationIE_Extensions(pub Vec<TraceActivationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TraceStartProtocolIEs_EntryValue {
    #[asn(key = 111)]
    Id_MeNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 157)]
    Id_MeNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 13)]
    Id_TraceActivation(TraceActivation),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceStartProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceStartProtocolIEs(pub Vec<TraceStartProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Transport_UP_Layer_Addresses_Info_To_Add_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Transport_UP_Layer_Addresses_Info_To_Add_ItemIE_Extensions(
    pub Vec<Transport_UP_Layer_Addresses_Info_To_Add_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Transport_UP_Layer_Addresses_Info_To_Remove_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Transport_UP_Layer_Addresses_Info_To_Remove_ItemIE_Extensions(
    pub Vec<Transport_UP_Layer_Addresses_Info_To_Remove_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TunnelInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TunnelInformationIE_Extensions(pub Vec<TunnelInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UE_ContextInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 340)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 360)]
    Id_EPCHandoverRestrictionListContainer(EPCHandoverRestrictionListContainer),
    #[asn(key = 408)]
    Id_IMSvoiceEPSfallbackfrom5G(IMSvoiceEPSfallbackfrom5G),
    #[asn(key = 89)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 74)]
    Id_ManagementBasedMDTallowed(ManagementBasedMDTallowed),
    #[asn(key = 371)]
    Id_NRUESidelinkAggregateMaximumBitRate(NRUESidelinkAggregateMaximumBitRate),
    #[asn(key = 378)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 184)]
    Id_UESidelinkAggregateMaximumBitRate(UESidelinkAggregateMaximumBitRate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: UE_ContextInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextInformationIE_Extensions(pub Vec<UE_ContextInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UE_ContextInformation_SgNBModReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 340)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 341)]
    Id_LowerLayerPresenceStatusChange(LowerLayerPresenceStatusChange),
    #[asn(key = 275)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextInformation_SgNBModReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: UE_ContextInformation_SgNBModReqIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextInformation_SgNBModReqIE_Extensions(
    pub Vec<UE_ContextInformation_SgNBModReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UE_ContextInformationRetrieveIE_Extensions_EntryExtensionValue {
    #[asn(key = 340)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 360)]
    Id_EPCHandoverRestrictionListContainer(EPCHandoverRestrictionListContainer),
    #[asn(key = 408)]
    Id_IMSvoiceEPSfallbackfrom5G(IMSvoiceEPSfallbackfrom5G),
    #[asn(key = 371)]
    Id_NRUESidelinkAggregateMaximumBitRate(NRUESidelinkAggregateMaximumBitRate),
    #[asn(key = 378)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 184)]
    Id_UESidelinkAggregateMaximumBitRate(UESidelinkAggregateMaximumBitRate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextInformationRetrieveIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: UE_ContextInformationRetrieveIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextInformationRetrieveIE_Extensions(
    pub Vec<UE_ContextInformationRetrieveIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextInformationSeNBModReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextInformationSeNBModReqIE_Extensions(
    pub Vec<UE_ContextInformationSeNBModReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextReferenceAtSeNBIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextReferenceAtSeNBIE_Extensions(
    pub Vec<UE_ContextReferenceAtSeNBIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextReferenceAtSgNBIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextReferenceAtSgNBIE_Extensions(
    pub Vec<UE_ContextReferenceAtSgNBIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_ContextReferenceAtWTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_ContextReferenceAtWTIE_Extensions(
    pub Vec<UE_ContextReferenceAtWTIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEAggregateMaximumBitRateIE_Extensions_EntryExtensionValue {
    #[asn(key = 200)]
    Id_extended_uEaggregateMaximumBitRateDownlink(ExtendedBitRate),
    #[asn(key = 201)]
    Id_extended_uEaggregateMaximumBitRateUplink(ExtendedBitRate),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAggregateMaximumBitRateIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: UEAggregateMaximumBitRateIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAggregateMaximumBitRateIE_Extensions(
    pub Vec<UEAggregateMaximumBitRateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1000"
)]
pub struct UEAppLayerMeasConfigContainerForAppLayerMeasConfig(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue {
    #[asn(key = 276)]
    Id_serviceType(ServiceType),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAppLayerMeasConfigIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub extension_value: UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAppLayerMeasConfigIE_Extensions(pub Vec<UEAppLayerMeasConfigIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseProtocolIEs_EntryValue {
    #[asn(key = 9)]
    Id_New_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 155)]
    Id_New_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 10)]
    Id_Old_eNB_UE_X2AP_ID(UE_X2AP_ID),
    #[asn(key = 156)]
    Id_Old_eNB_UE_X2AP_ID_Extension(UE_X2AP_ID_Extension),
    #[asn(key = 164)]
    Id_SIPTO_BearerDeactivationIndication(SIPTOBearerDeactivationIndication),
    #[asn(key = 207)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseProtocolIEs(pub Vec<UEContextReleaseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    #[asn(key = 378)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 400)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 378)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESecurityCapabilitiesIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESecurityCapabilitiesIE_Extensions(pub Vec<UESecurityCapabilitiesIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESidelinkAggregateMaximumBitRateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESidelinkAggregateMaximumBitRateIE_Extensions(
    pub Vec<UESidelinkAggregateMaximumBitRateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEsToBeResetList_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEsToBeResetList_ItemIE_Extensions(pub Vec<UEsToBeResetList_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_HighInterferenceIndicationInfo_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_HighInterferenceIndicationInfo_ItemIE_Extensions(
    pub Vec<UL_HighInterferenceIndicationInfo_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ULConfigurationIE_Extensions(pub Vec<ULConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULOnlySharingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ULOnlySharingIE_Extensions(pub Vec<ULOnlySharingIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct ULResourcesULandDLSharing_unchanged;

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULandDLSharingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ULandDLSharingIE_Extensions(pub Vec<ULandDLSharingIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UnsuccessfulOutcomeValue {
    #[asn(key = 15)]
    Id_cellActivation(CellActivationFailure),
    #[asn(key = 8)]
    Id_eNBConfigurationUpdate(ENBConfigurationUpdateFailure),
    #[asn(key = 39)]
    Id_endcCellActivation(ENDCCellActivationFailure),
    #[asn(key = 37)]
    Id_endcConfigurationUpdate(ENDCConfigurationUpdateFailure),
    #[asn(key = 43)]
    Id_endcX2Removal(ENDCX2RemovalFailure),
    #[asn(key = 36)]
    Id_endcX2Setup(ENDCX2SetupFailure),
    #[asn(key = 54)]
    Id_endcresourceStatusReportingInitiation(ENDCResourceStatusFailure),
    #[asn(key = 0)]
    Id_handoverPreparation(HandoverPreparationFailure),
    #[asn(key = 21)]
    Id_meNBinitiatedSeNBModificationPreparation(SeNBModificationRequestReject),
    #[asn(key = 29)]
    Id_meNBinitiatedSgNBModificationPreparation(SgNBModificationRequestReject),
    #[asn(key = 31)]
    Id_meNBinitiatedSgNBRelease(SgNBReleaseRequestReject),
    #[asn(key = 12)]
    Id_mobilitySettingsChange(MobilityChangeFailure),
    #[asn(key = 9)]
    Id_resourceStatusReportingInitiation(ResourceStatusFailure),
    #[asn(key = 26)]
    Id_retrieveUEContext(RetrieveUEContextFailure),
    #[asn(key = 19)]
    Id_seNBAdditionPreparation(SeNBAdditionRequestReject),
    #[asn(key = 22)]
    Id_seNBinitiatedSeNBModification(SeNBModificationRefuse),
    #[asn(key = 27)]
    Id_sgNBAdditionPreparation(SgNBAdditionRequestReject),
    #[asn(key = 34)]
    Id_sgNBChange(SgNBChangeRefuse),
    #[asn(key = 30)]
    Id_sgNBinitiatedSgNBModification(SgNBModificationRefuse),
    #[asn(key = 18)]
    Id_x2Removal(X2RemovalFailure),
    #[asn(key = 6)]
    Id_x2Setup(X2SetupFailure),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct UsableABSInformationFDDUsable_abs_pattern_info(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UsableABSInformationFDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UsableABSInformationFDDIE_Extensions(
    pub Vec<UsableABSInformationFDDIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "70")]
pub struct UsableABSInformationTDDUsaable_abs_pattern_info(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UsableABSInformationTDDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UsableABSInformationTDDIE_Extensions(
    pub Vec<UsableABSInformationTDDIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct V2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct V2XServicesAuthorizedIE_Extensions(pub Vec<V2XServicesAuthorizedIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rssi(pub u8);
impl WLANMeasurementConfigurationWlan_rssi {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rtt(pub u8);
impl WLANMeasurementConfigurationWlan_rtt {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasurementConfigurationIE_Extensions(
    pub Vec<WLANMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct WTID_Type1ShortWTID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct WidebandCQIWidebandCQICodeword0(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WidebandCQIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WidebandCQIIE_Extensions(pub Vec<WidebandCQIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct WidebandCQICodeword1_four_bitCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7", extensible = true)]
pub struct WidebandCQICodeword1_three_bitSpatialDifferentialCQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2APMessageTransferProtocolIEs_EntryValue {
    #[asn(key = 101)]
    Id_RNL_Header(RNL_Header),
    #[asn(key = 102)]
    Id_x2APMessage(X2AP_Message),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2APMessageTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2APMessageTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2APMessageTransferProtocolIEs(pub Vec<X2APMessageTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2ReleaseProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2ReleaseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2ReleaseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2ReleaseProtocolIEs(pub Vec<X2ReleaseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2RemovalFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2RemovalFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2RemovalFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2RemovalFailureProtocolIEs(pub Vec<X2RemovalFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2RemovalRequestProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
    #[asn(key = 169)]
    Id_X2RemovalThreshold(X2BenefitValue),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2RemovalRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2RemovalRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2RemovalRequestProtocolIEs(pub Vec<X2RemovalRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2RemovalResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2RemovalResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2RemovalResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2RemovalResponseProtocolIEs(pub Vec<X2RemovalResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2SetupFailureProtocolIEs_EntryValue {
    #[asn(key = 5)]
    Id_Cause(Cause),
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 22)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2SetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2SetupFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2SetupFailureProtocolIEs(pub Vec<X2SetupFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2SetupRequestProtocolIEs_EntryValue {
    #[asn(key = 24)]
    Id_GUGroupIDList(GUGroupIDList),
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
    #[asn(key = 159)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 20)]
    Id_ServedCells(ServedCells),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2SetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2SetupRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2SetupRequestProtocolIEs(pub Vec<X2SetupRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum X2SetupResponseProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 24)]
    Id_GUGroupIDList(GUGroupIDList),
    #[asn(key = 21)]
    Id_GlobalENB_ID(GlobalENB_ID),
    #[asn(key = 159)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 20)]
    Id_ServedCells(ServedCells),
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2SetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: X2SetupResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: UperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct X2SetupResponseProtocolIEs(pub Vec<X2SetupResponseProtocolIEs_Entry>);
